(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["geo"] = factory();
	else
		root["geo"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/built";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// License headers that will be preserved in distributed bundles.
	/**
	 * GeoJS
	 * @copyright 2013-2016, Kitware, Inc.
	 * @license Apache-2.0
	 *
	 * Bundled with the following libraries:
	 *
	 * vgl
	 * @copyright 2014-2016, Kitware, Inc.
	 * @license Apache-2.0
	 *
	 * Proj4js
	 * @copyright 2014, Mike Adair, Richard Greenwood, Didier Richard, Stephen Irons, Olivier Terral and Calvin Metcalf
	 * @license MIT
	 *
	 * gl-matrix
	 * @copyright 2015, Brandon Jones, Colin MacKenzie IV
	 * @license MIT
	 *
	 * JQuery
	 * @copyright jQuery Foundation and other contributors
	 * @license MIT
	 *
	 * earcut
	 * @copyright 2016, Mapbox
	 * @license ISC
	 */

	var $ = __webpack_require__(1);
	__webpack_require__(2);

	module.exports = $.extend({
	  annotation: __webpack_require__(3),
	  annotationLayer: __webpack_require__(206),
	  camera: __webpack_require__(202),
	  choroplethFeature: __webpack_require__(212),
	  clock: __webpack_require__(214),
	  contourFeature: __webpack_require__(215),
	  domRenderer: __webpack_require__(216),
	  event: __webpack_require__(5),
	  feature: __webpack_require__(78),
	  featureLayer: __webpack_require__(207),
	  fetchQueue: __webpack_require__(218),
	  fileReader: __webpack_require__(219),
	  geo_action: __webpack_require__(208),
	  geomFeature: __webpack_require__(220),
	  graphFeature: __webpack_require__(221),
	  imageTile: __webpack_require__(222),
	  jsonReader: __webpack_require__(224),
	  layer: __webpack_require__(201),
	  lineFeature: __webpack_require__(77),
	  map: __webpack_require__(225),
	  mapInteractor: __webpack_require__(210),
	  object: __webpack_require__(80),
	  osmLayer: __webpack_require__(227),
	  pathFeature: __webpack_require__(230),
	  pointFeature: __webpack_require__(203),
	  polygonFeature: __webpack_require__(205),
	  quadFeature: __webpack_require__(211),
	  heatmapFeature: __webpack_require__(231),
	  renderer: __webpack_require__(217),
	  sceneObject: __webpack_require__(79),
	  tile: __webpack_require__(223),
	  tileCache: __webpack_require__(229),
	  tileLayer: __webpack_require__(228),
	  timestamp: __webpack_require__(195),
	  transform: __webpack_require__(6),
	  vectorFeature: __webpack_require__(232),
	  inherit: __webpack_require__(4),
	  version: __webpack_require__(233),
	  sha: __webpack_require__(234),

	  util: __webpack_require__(196),
	  jQuery: $,
	  d3: __webpack_require__(235),
	  gl: __webpack_require__(247),
	  canvas: __webpack_require__(260),
	  gui: __webpack_require__(266)
	}, __webpack_require__(76));

	if (window && !window.$) {
	  window.$ = $;
	}
	if (window && !window.jQuery) {
	  window.jQuery = $;
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}

			return key === undefined || hasOwn.call( obj, key );
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));


/***/ },
/* 2 */
/***/ function(module, exports) {

	// Add a polyfill for window.requestAnimationFrame.
	if (!window.requestAnimationFrame) {
	  var _animationFrameFunc = [];
	  if (!window.performance || !window.performance.now) {
	    window.performance = {now: function () { return new Date().getTime(); }};
	  }
	  window.requestAnimationFrame = function (func) {
	    'use strict';

	    if (!_animationFrameFunc.length) {
	      var time = window.performance.now();
	      window.setTimeout(function () {
	        var funcs = _animationFrameFunc;
	        _animationFrameFunc = [];
	        var curtime = window.performance.now();
	        for (var i = 0; i < funcs.length; i += 1) {
	          funcs[i].call(window, curtime);
	        }
	      }, 15 - (parseInt(time, 10) % 15));
	    }
	    _animationFrameFunc.push(func);
	  };
	}

	// Add a polyfill for Math.log2
	if (!Math.log2) {
	  Math.log2 = function () {
	    return Math.log.apply(Math, arguments) / Math.LN2;
	  };
	}

	// Add a polyfill for Math.sinh
	Math.sinh = Math.sinh || function (x) {
	  var y = Math.exp(x);
	  return (y - 1 / y) / 2;
	};



/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var inherit = __webpack_require__(4);
	var geo_event = __webpack_require__(5);
	var transform = __webpack_require__(6);
	var registerAnnotation = __webpack_require__(76).registerAnnotation;
	var lineFeature = __webpack_require__(77);
	var pointFeature = __webpack_require__(203);
	var polygonFeature = __webpack_require__(205);

	var annotationId = 0;

	var annotationState = {
	  create: 'create',
	  done: 'done',
	  edit: 'edit'
	};

	/////////////////////////////////////////////////////////////////////////////
	/**
	 * Base annotation class
	 *
	 * @class geo.annotation
	 * @param {string} type the type of annotation.  These should be registered
	 *    with utils.registerAnnotation and can be listed with same function.
	 * @param {object?} options Inidividual annotations have additional options.
	 * @param {string} [options.name] A name for the annotation.  This defaults to
	 *    the type with a unique ID suffixed to it.
	 * @param {geo.annotationLayer} [options.layer] a reference to the controlling
	 *    layer.  This is used for coordinate transforms.
	 * @param {string} [options.state] initial annotation state.  One of the
	 *    annotation.state values.
	 * @returns {geo.annotation}
	 */
	/////////////////////////////////////////////////////////////////////////////
	var annotation = function (type, args) {
	  'use strict';
	  if (!(this instanceof annotation)) {
	    return new annotation(type, args);
	  }

	  annotationId += 1;
	  var m_options = $.extend({}, args || {}),
	      m_id = annotationId,
	      m_name = m_options.name || (
	        type.charAt(0).toUpperCase() + type.substr(1) + ' ' + annotationId),
	      m_type = type,
	      m_layer = m_options.layer,
	      /* one of annotationState.* */
	      m_state = m_options.state || annotationState.done;
	  delete m_options.state;
	  delete m_options.layer;
	  delete m_options.name;

	  /**
	   * Clean up any resources that the annotation is using.
	   */
	  this._exit = function () {
	  };

	  /**
	   * Get a unique annotation id.
	   *
	   * @returns {number} the annotation id.
	   */
	  this.id = function () {
	    return m_id;
	  };

	  /**
	   * Get or set the name of this annotation.
	   *
	   * @param {string|undefined} arg if undefined, return the name, otherwise
	   *    change it.
	   * @returns {this|string} the current name or this annotation.
	   */
	  this.name = function (arg) {
	    if (arg === undefined) {
	      return m_name;
	    }
	    if (arg !== null && ('' + arg).trim()) {
	      m_name = ('' + arg).trim();
	    }
	    return this;
	  };

	  /**
	   * Get or set the annotation layer associated with this annotation.
	   *
	   * @param {geo.annotationLayer|undefined} arg if undefined, return the layer,
	   *    otherwise change it.
	   * @returns {this|geo.annotationLayer} the current layer or this annotation.
	   */
	  this.layer = function (arg) {
	    if (arg === undefined) {
	      return m_layer;
	    }
	    m_layer = arg;
	    return this;
	  };

	  /**
	   * Get or set the state of this annotation.
	   *
	   * @param {string|undefined} arg if undefined, return the state, otherwise
	   *    change it.
	   * @returns {this|string} the current state or this annotation.
	   */
	  this.state = function (arg) {
	    if (arg === undefined) {
	      return m_state;
	    }
	    if (m_state !== arg) {
	      m_state = arg;
	      if (this.layer()) {
	        this.layer().geoTrigger(geo_event.annotation.state, {
	          annotation: this
	        });
	      }
	    }
	    return this;
	  };

	  /**
	   * Set or get options.
	   *
	   * @param {string|object} arg1 if undefined, return the options object.  If
	   *    a string, either set or return the option of that name.  If an object,
	   *    update the options with the object's values.
	   * @param {object} arg2 if arg1 is a string and this is defined, set the
	   *    option to this value.
	   * @returns {object|this} if options are set, return the layer, otherwise
	   *    return the requested option or the set of options.
	   */
	  this.options = function (arg1, arg2) {
	    if (arg1 === undefined) {
	      return m_options;
	    }
	    if (typeof arg1 === 'string' && arg2 === undefined) {
	      return m_options[arg1];
	    }
	    if (arg2 === undefined) {
	      m_options = $.extend(true, m_options, arg1);
	    } else {
	      m_options[arg1] = arg2;
	    }
	    this.modified();
	    return this;
	  };

	  /**
	   * Get the type of this annotation.
	   *
	   * @returns {string} the annotation type.
	   */
	  this.type = function () {
	    return m_type;
	  };

	  /**
	   * Get a list of renderable features for this annotation.  The list index is
	   * functionally a z-index for the feature.  Each entry is a dictionary with
	   * the key as the feature name (such as line, quad, or polygon), and the
	   * value a dictionary of values to pass to the feature constructor, such as
	   * style and coordinates.
	   *
	   * @returns {array} an array of features.
	   */
	  this.features = function () {
	    return [];
	  };

	  /**
	   * Handle a mouse click on this annotation.  If the event is processed,
	   * evt.handled should be set to true to prevent further processing.
	   *
	   * @param {geo.event} evt the mouse click event.
	   * @returns {boolean|string} true to update the annotation, 'done' if the
	   *    annotation was completed (changed from create to done state), 'remove'
	   *    if the annotation should be removed, falsy to not update anything.
	   */
	  this.mouseClick = function (evt) {
	  };

	  /**
	   * Handle a mouse move on this annotation.
	   *
	   * @param {geo.event} evt the mouse move event.
	   * @returns {boolean|string} true to update the annotation, falsy to not
	   *    update anything.
	   */
	  this.mouseMove = function (evt) {
	  };

	  /**
	   * Get coordinates associated with this annotation in the map gcs coordinate
	   * system.
	   *
	   * @returns {array} an array of coordinates.
	   */
	  this._coordinates = function () {
	    return [];
	  };

	  /**
	   * Get coordinates associated with this annotation.
	   *
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.
	   * @returns {array} an array of coordinates.
	   */
	  this.coordinates = function (gcs) {
	    var coord = this._coordinates();
	    if (this.layer()) {
	      var map = this.layer().map();
	      gcs = (gcs === null ? map.gcs() : (
	             gcs === undefined ? map.ingcs() : gcs));
	      if (gcs !== map.gcs()) {
	        coord = transform.transformCoordinates(map.gcs(), gcs, coord);
	      }
	      return coord;
	    }
	  };

	  /**
	   * Mark this annotation as modified.  This just marks the parent layer as
	   * modified.
	   */
	  this.modified = function () {
	    if (this.layer()) {
	      this.layer().modified();
	    }
	    return this;
	  };

	  /**
	   * Draw this annotation.  This just updates and draws the parent layer.
	   */
	  this.draw = function () {
	    if (this.layer()) {
	      this.layer()._update();
	      this.layer().draw();
	    }
	    return this;
	  };

	  /**
	   * TODO: return the annotation as a geojson object
	   */
	  this.geojson = function () {
	    return 'not implemented';
	  };
	};

	/////////////////////////////////////////////////////////////////////////////
	/**
	 * Rectangle annotation class
	 *
	 * Rectangles are always rendered as polygons.  This could be changed -- if no
	 * stroke is specified, the quad feature would be sufficient and work on more
	 * renderers.
	 *
	 * Must specify:
	 *   corners: a list of four corners {x: x, y: y} in map gcs coordinates.
	 * May specify:
	 *   style.
	 *     fill, fillColor, fillOpacity, stroke, strokeWidth, strokeColor,
	 *     strokeOpacity
	 */
	/////////////////////////////////////////////////////////////////////////////
	var rectangleAnnotation = function (args) {
	  'use strict';
	  if (!(this instanceof rectangleAnnotation)) {
	    return new rectangleAnnotation(args);
	  }
	  args = $.extend(true, {}, {
	    style: {
	      fill: true,
	      fillColor: {r: 0, g: 1, b: 0},
	      fillOpacity: 0.25,
	      polygon: function (d) { return d.polygon; },
	      stroke: true,
	      strokeColor: {r: 0, g: 0, b: 0},
	      strokeOpacity: 1,
	      strokeWidth: 3,
	      uniformPolygon: true
	    }
	  }, args || {});
	  annotation.call(this, 'rectangle', args);

	  /**
	   * Get a list of renderable features for this annotation.
	   *
	   * @returns {array} an array of features.
	   */
	  this.features = function () {
	    var opt = this.options();
	    return [{
	      polygon: {
	        polygon: opt.corners,
	        style: opt.style
	      }
	    }];
	  };

	  /**
	   * Get coordinates associated with this annotation in the map gcs coordinate
	   * system.
	   *
	   * @returns {array} an array of coordinates.
	   */
	  this._coordinates = function () {
	    return this.options('corners');
	  };
	};
	inherit(rectangleAnnotation, annotation);

	var rectangleRequiredFeatures = {};
	rectangleRequiredFeatures[polygonFeature.capabilities.feature] = true;
	registerAnnotation('rectangle', rectangleAnnotation, rectangleRequiredFeatures);

	/////////////////////////////////////////////////////////////////////////////
	/**
	 * Polygon annotation class
	 *
	 * When complete, polygons are rendered as polygons.  During creation they are
	 * rendered as lines and polygons.
	 *
	 * Must specify:
	 *   vertices: a list of vertices {x: x, y: y} in map gcs coordinates.
	 * May specify:
	 *   style.
	 *     fill, fillColor, fillOpacity, stroke, strokeWidth, strokeColor,
	 *     strokeOpacity
	 *   editstyle.
	 *     fill, fillColor, fillOpacity, stroke, strokeWidth, strokeColor,
	 *     strokeOpacity
	 */
	/////////////////////////////////////////////////////////////////////////////
	var polygonAnnotation = function (args) {
	  'use strict';
	  if (!(this instanceof polygonAnnotation)) {
	    return new polygonAnnotation(args);
	  }

	  var m_this = this;

	  args = $.extend(true, {}, {
	    vertices: [],
	    style: {
	      fill: true,
	      fillColor: {r: 0, g: 1, b: 0},
	      fillOpacity: 0.25,
	      polygon: function (d) { return d.polygon; },
	      stroke: true,
	      strokeColor: {r: 0, g: 0, b: 0},
	      strokeOpacity: 1,
	      strokeWidth: 3,
	      uniformPolygon: true
	    },
	    editstyle: {
	      closed: false,
	      fill: true,
	      fillColor: {r: 0.3, g: 0.3, b: 0.3},
	      fillOpacity: 0.25,
	      line: function (d) {
	        /* Return an array that has the same number of items as we have
	         * vertices. */
	        return Array.apply(null, Array(m_this.options('vertices').length)).map(
	            function () { return d; });
	      },
	      polygon: function (d) { return d.polygon; },
	      position: function (d, i) {
	        return m_this.options('vertices')[i];
	      },
	      stroke: false,
	      strokeColor: {r: 0, g: 0, b: 1},
	      strokeOpacity: 1,
	      strokeWidth: 3,
	      uniformPolygon: true
	    }
	  }, args || {});
	  annotation.call(this, 'polygon', args);

	  /**
	   * Get a list of renderable features for this annotation.  When the polygon
	   * is done, this is just a single polygon.  During creation this can be a
	   * polygon and line at z-levels 1 and 2.
	   *
	   * @returns {array} an array of features.
	   */
	  this.features = function () {
	    var opt = this.options(),
	        state = this.state(),
	        features;
	    switch (state) {
	      case annotationState.create:
	        features = [];
	        if (opt.vertices && opt.vertices.length >= 3) {
	          features[1] = {
	            polygon: {
	              polygon: opt.vertices,
	              style: opt.editstyle
	            }
	          };
	        }
	        if (opt.vertices && opt.vertices.length >= 2) {
	          features[2] = {
	            line: {
	              line: opt.vertices,
	              style: opt.editstyle
	            }
	          };
	        }
	        break;
	      default:
	        features = [{
	          polygon: {
	            polygon: opt.vertices,
	            style: opt.style
	          }
	        }];
	        break;
	    }
	    return features;
	  };

	  /**
	   * Get coordinates associated with this annotation in the map gcs coordinate
	   * system.
	   *
	   * @returns {array} an array of coordinates.
	   */
	  this._coordinates = function () {
	    return this.options('vertices');
	  };

	  /**
	   * Handle a mouse move on this annotation.
	   *
	   * @param {geo.event} evt the mouse move event.
	   * @returns {boolean|string} true to update the annotation, falsy to not
	   *    update anything.
	   */
	  this.mouseMove = function (evt) {
	    if (this.state() !== annotationState.create) {
	      return;
	    }
	    var vertices = this.options('vertices');
	    if (vertices.length) {
	      vertices[vertices.length - 1] = evt.mapgcs;
	      return true;
	    }
	  };

	  /**
	   * Handle a mouse click on this annotation.  If the event is processed,
	   * evt.handled should be set to true to prevent further processing.
	   *
	   * @param {geo.event} evt the mouse click event.
	   * @returns {boolean|string} true to update the annotation, 'done' if the
	   *    annotation was completed (changed from create to done state), 'remove'
	   *    if the annotation should be removed, falsy to not update anything.
	   */
	  this.mouseClick = function (evt) {
	    var layer = this.layer();
	    if (this.state() !== annotationState.create || !layer) {
	      return;
	    }
	    var end = !!evt.buttonsDown.right, skip;
	    if (!evt.buttonsDown.left && !evt.buttonsDown.right) {
	      return;
	    }
	    var vertices = this.options('vertices');
	    if (evt.buttonsDown.right && !vertices.length) {
	      return;
	    }
	    evt.handled = true;
	    if (evt.buttonsDown.left) {
	      if (vertices.length) {
	        if (vertices.length >= 2 && layer.displayDistance(
	            vertices[vertices.length - 2], null, evt.map, 'display') <=
	            layer.options('adjacentPointProximity')) {
	          skip = true;
	          if (this.lastClick &&
	              evt.time - this.lastClick < layer.options('dblClickTime')) {
	            end = true;
	          }
	        } else if (vertices.length >= 2 && layer.displayDistance(
	            vertices[0], null, evt.map, 'display') <=
	            layer.options('finalPointProximity')) {
	          end = true;
	        } else {
	          vertices[vertices.length - 1] = evt.mapgcs;
	        }
	      } else {
	        vertices.push(evt.mapgcs);
	      }
	      if (!end && !skip) {
	        vertices.push(evt.mapgcs);
	      }
	      this.lastClick = evt.time;
	    }
	    if (end) {
	      if (vertices.length < 4) {
	        return 'remove';
	      }
	      vertices.pop();
	      this.state(annotationState.done);
	      return 'done';
	    }
	    return (end || !skip);
	  };
	};
	inherit(polygonAnnotation, annotation);

	var polygonRequiredFeatures = {};
	polygonRequiredFeatures[polygonFeature.capabilities.feature] = true;
	polygonRequiredFeatures[lineFeature.capabilities.basic] = [annotationState.create];
	registerAnnotation('polygon', polygonAnnotation, polygonRequiredFeatures);

	/////////////////////////////////////////////////////////////////////////////
	/**
	 * Point annotation class
	 *
	 * Must specify:
	 *   position: {x: x, y: y} in map gcs coordinates.
	 * May specify:
	 *   style.
	 *     radius, fill, fillColor, fillOpacity, stroke, strokeWidth, strokeColor,
	 *     strokeOpacity
	 */
	/////////////////////////////////////////////////////////////////////////////
	var pointAnnotation = function (args) {
	  'use strict';
	  if (!(this instanceof pointAnnotation)) {
	    return new pointAnnotation(args);
	  }
	  args = $.extend(true, {}, {
	    style: {
	      fill: true,
	      fillColor: {r: 0, g: 1, b: 0},
	      fillOpacity: 0.25,
	      radius: 10,
	      stroke: true,
	      strokeColor: {r: 0, g: 0, b: 0},
	      strokeOpacity: 1,
	      strokeWidth: 3
	    }
	  }, args || {});
	  annotation.call(this, 'point', args);

	  /**
	   * Get a list of renderable features for this annotation.
	   *
	   * @returns {array} an array of features.
	   */
	  this.features = function () {
	    var opt = this.options(),
	        state = this.state(),
	        features;
	    switch (state) {
	      case annotationState.create:
	        features = [];
	        break;
	      default:
	        features = [{
	          point: {
	            x: opt.position.x,
	            y: opt.position.y,
	            style: opt.style
	          }
	        }];
	        break;
	    }
	    return features;
	  };

	  /**
	   * Get coordinates associated with this annotation in the map gcs coordinate
	   * system.
	   *
	   * @returns {array} an array of coordinates.
	   */
	  this._coordinates = function () {
	    if (this.state() === annotationState.create) {
	      return [];
	    }
	    return [this.options('position')];
	  };

	  /**
	   * Handle a mouse click on this annotation.  If the event is processed,
	   * evt.handled should be set to true to prevent further processing.
	   *
	   * @param {geo.event} evt the mouse click event.
	   * @returns {boolean|string} true to update the annotation, 'done' if the
	   *    annotation was completed (changed from create to done state), 'remove'
	   *    if the annotation should be removed, falsy to not update anything.
	   */
	  this.mouseClick = function (evt) {
	    if (this.state() !== annotationState.create) {
	      return;
	    }
	    if (!evt.buttonsDown.left) {
	      return;
	    }
	    evt.handled = true;
	    this.options('position', evt.mapgcs);
	    this.state(annotationState.done);
	    return 'done';
	  };
	};
	inherit(pointAnnotation, annotation);

	var pointRequiredFeatures = {};
	pointRequiredFeatures[pointFeature.capabilities.feature] = true;
	registerAnnotation('point', pointAnnotation, pointRequiredFeatures);

	module.exports = {
	  state: annotationState,
	  annotation: annotation,
	  pointAnnotation: pointAnnotation,
	  polygonAnnotation: polygonAnnotation,
	  rectangleAnnotation: rectangleAnnotation
	};


/***/ },
/* 4 */
/***/ function(module, exports) {

	function newfunc() {
	  return function () {};
	}

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Convenient function to define JS inheritance
	 */
	//////////////////////////////////////////////////////////////////////////////
	module.exports = function (C, P) {
	  var F = newfunc();
	  F.prototype = P.prototype;
	  C.prototype = new F();
	  C.prototype.constructor = C;
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Common object containing all event types that are provided by the GeoJS
	 * API.  Each property contained here is a valid target for event handling
	 * via {@link geo.object#geoOn}.  The event object provided to handlers is
	 * different for each event type.  Each handler will generally be called
	 * with a the <code>this</code> context being the class that caused the event.<br>
	 * <br>
	 * The following properties are common to all event objects:
	 *
	 * @namespace geo.event
	 * @property {string} type The event type that was triggered
	 * @property {object} geo A universal event object for controlling propagation
	 *
	 * @example
	 * map.geoOn(geo.event.layerAdd, function (event) {
	 *   // event is an object with type: {@link geo.event.layerAdd}
	 * });
	 *
	 */
	//////////////////////////////////////////////////////////////////////////////
	var geo_event = {};

	//////////////////////////////////////////////////////////////////////////////
	/*
	 * Event types
	 */
	//////////////////////////////////////////////////////////////////////////////

	// The following were not triggered nor used anywhere.  Removing until their
	// purpose is defined more clearly.
	//
	// geo.event.update = 'geo_update';
	// geo.event.opacityUpdate = 'geo_opacityUpdate';
	// geo.event.layerSelect = 'geo_layerSelect';
	// geo.event.layerUnselect = 'geo_layerUnselect';
	// geo.event.query = 'geo_query';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when a layer is added to the map.
	 *
	 * @property {geo.map} target The current map
	 * @property {geo.layer} layer The new layer
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.layerAdd = 'geo_layerAdd';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when a layer is removed from the map.
	 *
	 * @property {geo.map} target The current map
	 * @property {geo.layer} layer The old layer
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.layerRemove = 'geo_layerRemove';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the map's zoom level is changed.  Note that zoom is never
	 * triggered on the map itself.  Instead it is triggered individually on
	 * layers, starting with the base layer.
	 *
	 * @property {number} zoomLevel New zoom level
	 * @property {object} screenPosition The screen position of mouse pointer
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.zoom = 'geo_zoom';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the map is rotated around the current map center (pointing
	 * downward so that positive angles are clockwise rotations).
	 *
	 * @property {number} angle The angle of the rotation in radians
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.rotate = 'geo_rotate';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the map is panned either by user interaction or map
	 * transition.
	 *
	 * @property {object} screenDelta The number of pixels to pan the map by
	 * @property {object} center The new map center
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.pan = 'geo_pan';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the map's canvas is resized.
	 *
	 * @property {number} width The new width in pixels
	 * @property {number} height The new height in pixels
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.resize = 'geo_resize';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the world coordinate system changes.  Data in GCS
	 * coordinates can be transformed by the following formulas:
	 *
	 *   x <- (x - origin.x) * scale.x
	 *   y <- (y - origin.y) * scale.y
	 *   z <- (z - origin.z) * scale.z
	 *
	 * Data in world coordinates can be updated using the following formulas:
	 *
	 *   x <- (x * scaleChange.x - origin.x * (scale.x + scaleChange.x)
	 *          - scale.x * originChange.x) * scale.x / scaleChange.x
	 *   y <- (y * scaleChange.y - origin.y * (scale.y + scaleChange.y)
	 *          - scale.y * originChange.y) * scale.y / scaleChange.y
	 *   z <- (z * scaleChange.z - origin.z * (scale.z + scaleChange.z)
	 *          - scale.z * originChange.z) * scale.z / scaleChange.z
	 *
	 * @property {geo.map} map The map whose coordinates changed
	 * @property {object} origin The new origin in GCS coordinates
	 * @property {number} origin.x
	 * @property {number} origin.y
	 * @property {number} origin.z
	 * @property {object} scale The new scale factor
	 * @property {number} scale.x
	 * @property {number} scale.y
	 * @property {number} scale.z
	 * @property {object} originChange Relative change from the old origin defined
	 *   as `origin - oldorigin`.
	 * @property {object} scaleChange Relative change from the old scale defined
	 *   as `scale / oldscale`.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.worldChanged = 'geo_worldChanged';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered on every call to {@link geo.map#draw} before the map is rendered.
	 *
	 * @property {geo.map} target The current map
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.draw = 'geo_draw';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered on every call to {@link geo.map#draw} after the map is rendered.
	 *
	 * @property {geo.map} target The current map
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.drawEnd = 'geo_drawEnd';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered on every 'mousemove' over the map's DOM element.  The event
	 * object extends {@link geo.mouseState}.
	 * @mixes geo.mouseState
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.mousemove = 'geo_mousemove';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered on every 'mousedown' over the map's DOM element.  The event
	 * object extends {@link geo.mouseState}.
	 * @mixes geo.mouseState
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.mouseclick = 'geo_mouseclick';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered on every 'mousemove' during a brushing selection.
	 * The event object extends {@link geo.brushSelection}.
	 * @mixes geo.brushSelection
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.brush = 'geo_brush';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a brush selection ends.
	 * The event object extends {@link geo.brushSelection}.
	 * @mixes geo.brushSelection
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.brushend = 'geo_brushend';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when a brush selection starts.
	 * The event object extends {@link geo.brushSelection}.
	 * @mixes geo.brushSelection
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.brushstart = 'geo_brushstart';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a selection ends.
	 * The event object extends {@link geo.brushSelection}.
	 * @mixes geo.brushSelection
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.select = 'geo_select';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a zoom selection ends.
	 * The event object extends {@link geo.brushSelection}.
	 * @mixes geo.brushSelection
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.zoomselect = 'geo_zoomselect';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after an unzoom selection ends.
	 * The event object extends {@link geo.brushSelection}.
	 * @mixes geo.brushSelection
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.unzoomselect = 'geo_unzoomselect';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an action is initiated with mouse down
	 *
	 * @property {object} state The action state
	 * @property {geo.mouseState} mouse The mouse state
	 * @property {object} event The triggering event
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.actiondown = 'geo_actiondown';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an action is being processed during mouse movement.
	 *
	 * @property {object} state The action state
	 * @property {geo.mouseState} mouse The mouse state
	 * @property {object} event The triggering event
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.actionmove = 'geo_actionmove';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an action is ended with a mouse up.
	 *
	 * @property {object} state The action state
	 * @property {geo.mouseState} mouse The mouse state
	 * @property {object} event The triggering event
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.actionup = 'geo_actionup';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an action results in a selection.
	 *
	 * @property {object} state The action state
	 * @property {geo.mouseState} mouse The mouse state
	 * @property {object} event The triggering event
	 * @property {object} lowerLeft Lower left of selection in screen coordinates
	 * @property {object} upperRight Upper right of selection in screen coordinates
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.actionselection = 'geo_actionselection';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an action is triggered with a mouse wheel event.
	 *
	 * @property {object} state The action state
	 * @property {geo.mouseState} mouse The mouse state
	 * @property {object} event The triggering event
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.actionwheel = 'geo_actionwheel';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered before a map navigation animation begins.  Set
	 * <code>event.geo.cancelAnimation</code> to cancel the animation
	 * of the navigation.  This will cause the map to navigate to the
	 * target location immediately.  Set <code>event.geo.cancelNavigation</code>
	 * to cancel the navigation completely.  The transition options can
	 * be modified in place.
	 *
	 * @property {geo.geoPosition} center The target center
	 * @property {number} zoom The target zoom level
	 * @property {number} duration The duration of the transition in milliseconds
	 * @property {function} ease The easing function
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.transitionstart = 'geo_transitionstart';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a map navigation animation ends.
	 *
	 * @property {geo.geoPosition} center The target center
	 * @property {number} zoom The target zoom level
	 * @property {number} duration The duration of the transition in milliseconds
	 * @property {function} ease The easing function
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.transitionend = 'geo_transitionend';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered if a map navigation animation is cancelled.
	 *
	 * @property {geo.geoPosition} center The target center
	 * @property {number} zoom The target zoom level
	 * @property {number} duration The duration of the transition in milliseconds
	 * @property {function} ease The easing function
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.transitioncancel = 'geo_transitioncancel';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the parallel projection mode is changes.
	 *
	 * @property paralellProjection {boolean} True if parallel projection is turned
	 *                                        on.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.parallelprojection = 'geo_parallelprojection';

	////////////////////////////////////////////////////////////////////////////
	/**
	 * @namespace
	 */
	////////////////////////////////////////////////////////////////////////////
	geo_event.clock = {
	  play: 'geo_clock_play',
	  stop: 'geo_clock_stop',
	  pause: 'geo_clock_pause',
	  change: 'geo_clock_change'
	};

	////////////////////////////////////////////////////////////////////////////
	/**
	 * This event object provides mouse/keyboard events that can be handled
	 * by the features.  This provides a similar interface as core events,
	 * but with different names so the events don't interfere.  Subclasses
	 * can override this to provide custom events.
	 *
	 * These events will only be triggered on features which were instantiated
	 * with the option 'selectionAPI'.
	 * @namespace geo.event.feature
	 */
	////////////////////////////////////////////////////////////////////////////
	geo_event.feature = {
	  mousemove:  'geo_feature_mousemove',
	  mouseover:  'geo_feature_mouseover',
	  mouseout:   'geo_feature_mouseout',
	  mouseon:    'geo_feature_mouseon',
	  mouseoff:   'geo_feature_mouseoff',
	  mouseclick: 'geo_feature_mouseclick',
	  brushend:   'geo_feature_brushend',
	  brush:      'geo_feature_brush'
	};

	////////////////////////////////////////////////////////////////////////////
	/**
	 * These events are triggered by the camera when it's internal state is
	 * mutated.
	 * @namespace geo.event.camera
	 */
	////////////////////////////////////////////////////////////////////////////
	geo_event.camera = {};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a general view matrix change (any change in the visible
	 * bounds).  This is equivalent to the union of pan and zoom.
	 *
	 * @property {geo.camera} camera The camera instance
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.camera.view = 'geo_camera_view';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a pan in the x/y plane (no zoom level change).
	 *
	 * @property {geo.camera} camera The camera instance
	 * @property {object} delta The translation delta in world coordinates.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.camera.pan = 'geo_camera_pan';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a view matrix change that is not a simple pan.  This
	 * includes, but is not limited to, pure zooms.
	 *
	 * @property {geo.camera} camera The camera instance
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.camera.zoom = 'geo_camera_zoom';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a projection change.
	 *
	 * @property {geo.camera} camera The camera instance
	 * @property {string} type The projection type ('perspective'|'parallel')
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.camera.projection = 'geo_camera_projection';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered after a viewport change.
	 *
	 * @property {geo.camera} camera The camera instance
	 * @property {object} viewport The new viewport
	 * @property {number} viewport.width The new width
	 * @property {number} viewport.height The new height
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.camera.viewport = 'geo_camera_viewport';

	////////////////////////////////////////////////////////////////////////////
	/**
	 * These events are triggered by the annotation layer.
	 * @namespace geo.event.annotation
	 */
	////////////////////////////////////////////////////////////////////////////
	geo_event.annotation = {};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an annotation has been added.
	 *
	 * @property {geo.annotation} annotation The annotation that was added.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.annotation.add = 'geo_annotation_add';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an annotation is about to be added.
	 *
	 * @property {geo.annotation} annotation The annotation that will be added.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.annotation.add_before = 'geo_annotation_add_before';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an annotation has been removed.
	 *
	 * @property {geo.annotation} annotation The annotation that was removed.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.annotation.remove = 'geo_annotation_remove';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when an annotation's state changes.
	 *
	 * @property {geo.annotation} annotation The annotation that changed/
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.annotation.state = 'geo_annotation_state';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Triggered when the annotation mode is changed.
	 *
	 * @property {string|null} mode the new annotation mode.
	 */
	//////////////////////////////////////////////////////////////////////////////
	geo_event.annotation.mode = 'geo_annotation_mode';

	module.exports = geo_event;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var proj4 = __webpack_require__(7);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * This purpose of this class is to provide a generic interface for computing
	 * coordinate transformationss.  The interface is taken from the proj4js,
	 * which also provides the geospatial projection implementation.  The
	 * interface is intentionally simple to allow for custom, non-geospatial use
	 * cases. For further details, see http://proj4js.org/
	 *
	 * The default transforms lat/long coordinates into web mercator
	 * for use with standard tile sets.
	 *
	 * This class is intended to be extended in the future to support 2.5 and 3
	 * dimensional transformations.  The forward/inverse methods take optional
	 * z values that are ignored in current mapping context, but will in the
	 * future perform more general 3D transformations.
	 *
	 * @class geo.transform
	 * @param {object} options Constructor options
	 * @param {string} options.source A proj4 string for the source projection
	 * @param {string} options.target A proj4 string for the target projection
	 * @returns {geo.transform}
	 */
	//////////////////////////////////////////////////////////////////////////////

	var transformCache = {};
	/* Up to maxTransformCacheSize squared might be cached.  When the maximum cache
	 * size is reached, the cache is completely emptied.  Since we probably won't
	 * be rapidly switching between a large number of transforms, this is adequate
	 * simple behavior. */
	var maxTransformCacheSize = 10;

	var transform = function (options) {
	  'use strict';
	  if (!(this instanceof transform)) {
	    options = options || {};
	    if (!(options.source in transformCache)) {
	      if (Object.size(transformCache) >= maxTransformCacheSize) {
	        transformCache = {};
	      }
	      transformCache[options.source] = {};
	    }
	    if (!(options.target in transformCache[options.source])) {
	      if (Object.size(transformCache[options.source]) >= maxTransformCacheSize) {
	        transformCache[options.source] = {};
	      }
	      transformCache[options.source][options.target] = new transform(options);
	    }
	    return transformCache[options.source][options.target];
	  }

	  var m_this = this,
	      m_proj,   // The raw proj4js object
	      m_source, // The source projection
	      m_target; // The target projection

	  /**
	   * Generate the internal proj4 object.
	   * @private
	   */
	  function generate_proj4() {
	    m_proj = new proj4(
	      m_this.source(),
	      m_this.target()
	    );
	  }

	  /**
	   * Get/Set the source projection
	   */
	  this.source = function (arg) {
	    if (arg === undefined) {
	      return m_source || 'EPSG:4326';
	    }
	    m_source = arg;
	    generate_proj4();
	    return m_this;
	  };

	  /**
	   * Get/Set the target projection
	   */
	  this.target = function (arg) {
	    if (arg === undefined) {
	      return m_target || 'EPSG:3857';
	    }
	    m_target = arg;
	    generate_proj4();
	    return m_this;
	  };

	  /**
	   * Perform a forward transformation (source -> target)
	   * @protected
	   *
	   * @param {object}   point      The point coordinates
	   * @param {number}   point.x    The x-coordinate (i.e. longitude)
	   * @param {number}   point.y    The y-coordinate (i.e. latitude)
	   * @param {number}  [point.z=0] The z-coordinate (i.e. elevation)
	   *
	   * @returns {object} A point object in the target coordinates
	   */
	  this._forward = function (point) {
	    var pt = m_proj.forward(point);
	    pt.z = point.z || 0;
	    return pt;
	  };

	  /**
	   * Perform an inverse transformation (target -> source)
	   * @protected
	   *
	   * @param {object}   point     The point coordinates
	   * @param {number}   point.x   The x-coordinate (i.e. longitude)
	   * @param {number}   point.y   The y-coordinate (i.e. latitude)
	   * @param {number}  [point.z=0] The z-coordinate (i.e. elevation)
	   *
	   * @returns {object} A point object in the source coordinates
	   */
	  this._inverse = function (point) {
	    var pt = m_proj.inverse(point);
	    pt.z = point.z || 0;
	    return pt;
	  };

	  /**
	   * Perform a forward transformation (source -> target) in place
	   *
	   * @param {object[]} point      The point coordinates or array of points
	   * @param {number}   point.x    The x-coordinate (i.e. longitude)
	   * @param {number}   point.y    The y-coordinate (i.e. latitude)
	   * @param {number}  [point.z=0] The z-coordinate (i.e. elevation)
	   *
	   * @returns {object} A point object or array in the target coordinates
	   */
	  this.forward = function (point) {
	    if (Array.isArray(point)) {
	      return point.map(m_this._forward);
	    }
	    return m_this._forward(point);
	  };

	  /**
	   * Perform an inverse transformation (target -> source) in place
	   * @protected
	   *
	   * @param {object[]} point      The point coordinates or array of points
	   * @param {number}   point.x    The x-coordinate (i.e. longitude)
	   * @param {number}   point.y    The y-coordinate (i.e. latitude)
	   * @param {number}  [point.z=0] The z-coordinate (i.e. elevation)
	   *
	   * @returns {object} A point object in the source coordinates
	   */
	  this.inverse = function (point) {
	    if (Array.isArray(point)) {
	      return point.map(m_this._inverse);
	    }
	    return m_this._inverse(point);
	  };

	  // Set defaults given by the constructor
	  options = options || {};
	  try {
	    this.source(options.source);
	  } catch (err) {
	    console.error('Can\'t use transform source: ' + options.source);
	    this.source('EPSG:4326');
	  }
	  try {
	    this.target(options.target);
	  } catch (err) {
	    console.error('Can\'t use transform target: ' + options.target);
	    this.target('EPSG:3857');
	  }

	  return this;
	};

	/**
	 * Contains a reference to `proj4.defs`.  The functions serves two
	 * purposes.
	 *
	 *   1. It is a key value mapping of all loaded projection definitions
	 *   2. It is a function that will add additional definitions.
	 *
	 * See:
	 *   http://proj4js.org/
	 */
	transform.defs = proj4.defs;

	/**
	 * Look up a projection definition from epsg.io
	 * For the moment, we only handle `EPSG` codes.
	 *
	 * @param {string} projection A projection alias (e.g. EPSG:4326)
	 * @returns {promise} Resolves with the proj4 definition
	 */
	transform.lookup = function (projection) {
	  var $ = __webpack_require__(1);
	  var code, defer = new $.Deferred(), parts;

	  if (proj4.defs.hasOwnProperty(projection)) {
	    return defer.resolve(proj4.defs[projection]);
	  }

	  parts = projection.split(':');
	  if (parts.length !== 2 || parts[0].toUpperCase() !== 'EPSG') {
	    return defer.reject('Invalid projection code').promise();
	  }
	  code = parts[1];

	  return $.ajax({
	    url: 'http://epsg.io/?q=' + code + '&format=json'
	  }).then(function (data) {
	    var result = (data.results || [])[0];
	    if (!result || !result.proj4) {
	      return defer.reject(data).promise();
	    }

	    proj4.defs(projection, result.proj4);
	    return $.when(proj4.defs[projection]);
	  });
	};

	/**
	 * Transform an array of coordinates from one projection into another.  The
	 * transformation may occur in place (modifying the input coordinate array),
	 * depending on the input format.  The coordinates can be an object with x, y,
	 * and (optionally z) or an array of 2 or 3 values, or an array of either of
	 * those, or a single flat array with 2 or 3 components per coordinate.  Arrays
	 * are always modified in place.  Individual point objects are not altered; new
	 * point objects are returned unless no transform is needed.
	 *
	 * @param {string}        srcPrj The source projection
	 * @param {string}        tgtPrj The destination projection
	 * @param {geoPosition[]} coordinates An array of coordinate objects
	 * @param {number}        numberOfComponents for flat arrays, either 2 or 3.
	 *
	 * @returns {geoPosition[]} The transformed coordinates
	 */
	transform.transformCoordinates = function (
	        srcPrj, tgtPrj, coordinates, numberOfComponents) {
	  'use strict';

	  if (srcPrj === tgtPrj) {
	    return coordinates;
	  }

	  var trans = transform({source: srcPrj, target: tgtPrj}), output;
	  if (coordinates instanceof Object && 'x' in coordinates && 'y' in coordinates) {
	    output = trans.forward({x: coordinates.x, y: coordinates.y, z: coordinates.z || 0});
	    if ('z' in coordinates) {
	      return output;
	    }
	    return {x: output.x, y: output.y};
	  }
	  if (coordinates instanceof Array && coordinates.length === 1 && coordinates[0] instanceof Object && 'x' in coordinates[0] && 'y' in coordinates[0]) {
	    output = trans.forward({x: coordinates[0].x, y: coordinates[0].y, z: coordinates[0].z || 0});
	    if ('z' in coordinates[0]) {
	      return [output];
	    }
	    return [{x: output.x, y: output.y}];
	  }
	  return transform.transformCoordinatesArray(trans, coordinates, numberOfComponents);
	};

	/**
	 * Transform an array of coordinates from one projection into another.  The
	 * transformation may occur in place (modifying the input coordinate array),
	 * depending on the input format.  The coordinates can be an array of 2 or 3
	 * values, or an array of either of those, or a single flat array with 2 or 3
	 * components per coordinate.  The array is modified in place.
	 *
	 * @param {object} trans The transformation object.
	 * @param {geoPosition[]} coordinates An array of coordinate objects
	 * @param {number} numberOfComponents for flat arrays, either 2 or 3.
	 *
	 * @returns {geoPosition[]} The transformed coordinates
	 */
	transform.transformCoordinatesArray = function (trans, coordinates, numberOfComponents) {
	  var i, count, offset, xAcc, yAcc, zAcc, writer, output, projPoint;

	  /// Default Z accessor
	  zAcc = function () {
	    return 0.0;
	  };

	  /// Helper methods
	  function handleArrayCoordinates() {
	    if (coordinates[0] instanceof Array) {
	      if (coordinates[0].length === 2) {
	        xAcc = function (index) {
	          return coordinates[index][0];
	        };
	        yAcc = function (index) {
	          return coordinates[index][1];
	        };
	        writer = function (index, x, y) {
	          output[index] = [x, y];
	        };
	      } else if (coordinates[0].length === 3) {
	        xAcc = function (index) {
	          return coordinates[index][0];
	        };
	        yAcc = function (index) {
	          return coordinates[index][1];
	        };
	        zAcc = function (index) {
	          return coordinates[index][2];
	        };
	        writer = function (index, x, y, z) {
	          output[index] = [x, y, z];
	        };
	      } else {
	        throw new Error('Invalid coordinates. Requires two or three components per array');
	      }
	    } else {
	      if (coordinates.length === 2) {
	        offset = 2;

	        xAcc = function (index) {
	          return coordinates[index * offset];
	        };
	        yAcc = function (index) {
	          return coordinates[index * offset + 1];
	        };
	        writer = function (index, x, y) {
	          output[index] = x;
	          output[index + 1] = y;
	        };
	      } else if (coordinates.length === 3) {
	        offset = 3;

	        xAcc = function (index) {
	          return coordinates[index * offset];
	        };
	        yAcc = function (index) {
	          return coordinates[index * offset + 1];
	        };
	        zAcc = function (index) {
	          return coordinates[index * offset + 2];
	        };
	        writer = function (index, x, y, z) {
	          output[index] = x;
	          output[index + 1] = y;
	          output[index + 2] = z;
	        };
	      } else if (numberOfComponents) {
	        if (numberOfComponents === 2 || numberOfComponents === 3) {
	          offset = numberOfComponents;

	          xAcc = function (index) {
	            return coordinates[index];
	          };
	          yAcc = function (index) {
	            return coordinates[index + 1];
	          };
	          if (numberOfComponents === 2) {
	            writer = function (index, x, y) {
	              output[index] = x;
	              output[index + 1] = y;
	            };
	          } else {
	            zAcc = function (index) {
	              return coordinates[index + 2];
	            };
	            writer = function (index, x, y, z) {
	              output[index] = x;
	              output[index + 1] = y;
	              output[index + 2] = z;
	            };
	          }
	        } else {
	          throw new Error('Number of components should be two or three');
	        }
	      } else {
	        throw new Error('Invalid coordinates');
	      }
	    }
	  }

	  /// Helper methods
	  function handleObjectCoordinates() {
	    if (coordinates[0] &&
	        'x' in coordinates[0] &&
	        'y' in coordinates[0]) {
	      xAcc = function (index) {
	        return coordinates[index].x;
	      };
	      yAcc = function (index) {
	        return coordinates[index].y;
	      };

	      if ('z' in coordinates[0]) {
	        zAcc = function (index) {
	          return coordinates[index].z;
	        };
	        writer = function (index, x, y, z) {
	          output[i] = {x: x, y: y, z: z};
	        };
	      } else {
	        writer = function (index, x, y) {
	          output[index] = {x: x, y: y};
	        };
	      }
	    } else {
	      throw new Error('Invalid coordinates');
	    }
	  }

	  if (coordinates instanceof Array) {
	    output = [];
	    output.length = coordinates.length;
	    count = coordinates.length;

	    if (!coordinates.length) {
	      return output;
	    }
	    if (coordinates[0] instanceof Array ||
	        coordinates[0] instanceof Object) {
	      offset = 1;

	      if (coordinates[0] instanceof Array) {
	        handleArrayCoordinates();
	      } else if (coordinates[0] instanceof Object) {
	        handleObjectCoordinates();
	      }
	    } else {
	      handleArrayCoordinates();
	    }
	  } else {
	    throw new Error('Coordinates are not valid');
	  }

	  for (i = 0; i < count; i += offset) {
	    projPoint = trans.forward({x: xAcc(i), y: yAcc(i), z: zAcc(i)});
	    writer(i, projPoint.x, projPoint.y, projPoint.z);
	  }
	  return output;
	};

	/**
	 * Apply an affine transformation consisting of a translation
	 * then a scaling to the given coordinate array.  Note, the
	 * transformation occurs in place so the input coordinate
	 * object are mutated.
	 *
	 * (Possibly extend to support rotations as well)
	 *
	 * @param {object} def
	 * @param {object} def.origin The transformed origin
	 * @param {object} def.scale The transformed scale factor
	 * @param {object[]} coords An array of coordinate objects
	 *
	 * @returns {object[]} The transformed coordinates
	 */
	transform.affineForward = function (def, coords) {
	  'use strict';
	  var i, origin = def.origin, scale = def.scale || {x: 1, y: 1, z: 1};
	  for (i = 0; i < coords.length; i += 1) {
	    coords[i].x = (coords[i].x - origin.x) * scale.x;
	    coords[i].y = (coords[i].y - origin.y) * scale.y;
	    coords[i].z = ((coords[i].z || 0) - (origin.z || 0)) * scale.z;
	  }
	  return coords;
	};

	/**
	 * Apply an inverse affine transformation which is the
	 * inverse to {@link geo.transform.affineForward}.  Note, the
	 * transformation occurs in place so the input coordinate
	 * object are mutated.
	 *
	 * (Possibly extend to support rotations as well)
	 *
	 * @param {object} def
	 * @param {object} def.origin The transformed origin
	 * @param {object} def.scale The transformed scale factor
	 * @param {object[]} coords An array of coordinate objects
	 *
	 * @returns {object[]} The transformed coordinates
	 */
	transform.affineInverse = function (def, coords) {
	  'use strict';
	  var i, origin = def.origin, scale = def.scale || {x: 1, y: 1, z: 1};
	  for (i = 0; i < coords.length; i += 1) {
	    coords[i].x = coords[i].x / scale.x + origin.x;
	    coords[i].y = coords[i].y / scale.y + origin.y;
	    coords[i].z = (coords[i].z || 0) / scale.z + (origin.z || 0);
	  }
	  return coords;
	};

	module.exports = transform;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var proj4 = __webpack_require__(8);
	proj4.defaultDatum = 'WGS84'; //default datum
	proj4.Proj = __webpack_require__(9);
	proj4.WGS84 = new proj4.Proj('WGS84');
	proj4.Point = __webpack_require__(34);
	proj4.toPoint = __webpack_require__(33);
	proj4.defs = __webpack_require__(11);
	proj4.transform = __webpack_require__(30);
	proj4.mgrs = __webpack_require__(35);
	proj4.version = __webpack_require__(36).version;
	__webpack_require__(37)(proj4);
	module.exports = proj4;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var proj = __webpack_require__(9);
	var transform = __webpack_require__(30);
	var wgs84 = proj('WGS84');

	function transformer(from, to, coords) {
	  var transformedArray;
	  if (Array.isArray(coords)) {
	    transformedArray = transform(from, to, coords);
	    if (coords.length === 3) {
	      return [transformedArray.x, transformedArray.y, transformedArray.z];
	    }
	    else {
	      return [transformedArray.x, transformedArray.y];
	    }
	  }
	  else {
	    return transform(from, to, coords);
	  }
	}

	function checkProj(item) {
	  if (item instanceof proj) {
	    return item;
	  }
	  if (item.oProj) {
	    return item.oProj;
	  }
	  return proj(item);
	}
	function proj4(fromProj, toProj, coord) {
	  fromProj = checkProj(fromProj);
	  var single = false;
	  var obj;
	  if (typeof toProj === 'undefined') {
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  }
	  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
	    coord = toProj;
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  }
	  toProj = checkProj(toProj);
	  if (coord) {
	    return transformer(fromProj, toProj, coord);
	  }
	  else {
	    obj = {
	      forward: function(coords) {
	        return transformer(fromProj, toProj, coords);
	      },
	      inverse: function(coords) {
	        return transformer(toProj, fromProj, coords);
	      }
	    };
	    if (single) {
	      obj.oProj = toProj;
	    }
	    return obj;
	  }
	}
	module.exports = proj4;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var parseCode = __webpack_require__(10);
	var extend = __webpack_require__(17);
	var projections = __webpack_require__(18);
	var deriveConstants = __webpack_require__(26);

	function Projection(srsCode,callback) {
	  if (!(this instanceof Projection)) {
	    return new Projection(srsCode);
	  }
	  callback = callback || function(error){
	    if(error){
	      throw error;
	    }
	  };
	  var json = parseCode(srsCode);
	  if(typeof json !== 'object'){
	    callback(srsCode);
	    return;
	  }
	  var modifiedJSON = deriveConstants(json);
	  var ourProj = Projection.projections.get(modifiedJSON.projName);
	  if(ourProj){
	    extend(this, modifiedJSON);
	    extend(this, ourProj);
	    this.init();
	    callback(null, this);
	  }else{
	    callback(srsCode);
	  }
	}
	Projection.projections = projections;
	Projection.projections.start();
	module.exports = Projection;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var defs = __webpack_require__(11);
	var wkt = __webpack_require__(16);
	var projStr = __webpack_require__(13);
	function testObj(code){
	  return typeof code === 'string';
	}
	function testDef(code){
	  return code in defs;
	}
	function testWKT(code){
	  var codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];
	  return codeWords.reduce(function(a,b){
	    return a+1+code.indexOf(b);
	  },0);
	}
	function testProj(code){
	  return code[0] === '+';
	}
	function parse(code){
	  if (testObj(code)) {
	    //check to see if this is a WKT string
	    if (testDef(code)) {
	      return defs[code];
	    }
	    else if (testWKT(code)) {
	      return wkt(code);
	    }
	    else if (testProj(code)) {
	      return projStr(code);
	    }
	  }else{
	    return code;
	  }
	}

	module.exports = parse;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var globals = __webpack_require__(12);
	var parseProj = __webpack_require__(13);
	var wkt = __webpack_require__(16);

	function defs(name) {
	  /*global console*/
	  var that = this;
	  if (arguments.length === 2) {
	    var def = arguments[1];
	    if (typeof def === 'string') {
	      if (def.charAt(0) === '+') {
	        defs[name] = parseProj(arguments[1]);
	      }
	      else {
	        defs[name] = wkt(arguments[1]);
	      }
	    } else {
	      defs[name] = def;
	    }
	  }
	  else if (arguments.length === 1) {
	    if (Array.isArray(name)) {
	      return name.map(function(v) {
	        if (Array.isArray(v)) {
	          defs.apply(that, v);
	        }
	        else {
	          defs(v);
	        }
	      });
	    }
	    else if (typeof name === 'string') {
	      if (name in defs) {
	        return defs[name];
	      }
	    }
	    else if ('EPSG' in name) {
	      defs['EPSG:' + name.EPSG] = name;
	    }
	    else if ('ESRI' in name) {
	      defs['ESRI:' + name.ESRI] = name;
	    }
	    else if ('IAU2000' in name) {
	      defs['IAU2000:' + name.IAU2000] = name;
	    }
	    else {
	      console.log(name);
	    }
	    return;
	  }


	}
	globals(defs);
	module.exports = defs;


/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = function(defs) {
	  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
	  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
	  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

	  defs.WGS84 = defs['EPSG:4326'];
	  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
	  defs.GOOGLE = defs['EPSG:3857'];
	  defs['EPSG:900913'] = defs['EPSG:3857'];
	  defs['EPSG:102113'] = defs['EPSG:3857'];
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var D2R = 0.01745329251994329577;
	var PrimeMeridian = __webpack_require__(14);
	var units = __webpack_require__(15);

	module.exports = function(defData) {
	  var self = {};
	  var paramObj = {};
	  defData.split("+").map(function(v) {
	    return v.trim();
	  }).filter(function(a) {
	    return a;
	  }).forEach(function(a) {
	    var split = a.split("=");
	    split.push(true);
	    paramObj[split[0].toLowerCase()] = split[1];
	  });
	  var paramName, paramVal, paramOutname;
	  var params = {
	    proj: 'projName',
	    datum: 'datumCode',
	    rf: function(v) {
	      self.rf = parseFloat(v);
	    },
	    lat_0: function(v) {
	      self.lat0 = v * D2R;
	    },
	    lat_1: function(v) {
	      self.lat1 = v * D2R;
	    },
	    lat_2: function(v) {
	      self.lat2 = v * D2R;
	    },
	    lat_ts: function(v) {
	      self.lat_ts = v * D2R;
	    },
	    lon_0: function(v) {
	      self.long0 = v * D2R;
	    },
	    lon_1: function(v) {
	      self.long1 = v * D2R;
	    },
	    lon_2: function(v) {
	      self.long2 = v * D2R;
	    },
	    alpha: function(v) {
	      self.alpha = parseFloat(v) * D2R;
	    },
	    lonc: function(v) {
	      self.longc = v * D2R;
	    },
	    x_0: function(v) {
	      self.x0 = parseFloat(v);
	    },
	    y_0: function(v) {
	      self.y0 = parseFloat(v);
	    },
	    k_0: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    k: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    a: function(v) {
	      self.a = parseFloat(v);
	    },
	    b: function(v) {
	      self.b = parseFloat(v);
	    },
	    r_a: function() {
	      self.R_A = true;
	    },
	    zone: function(v) {
	      self.zone = parseInt(v, 10);
	    },
	    south: function() {
	      self.utmSouth = true;
	    },
	    towgs84: function(v) {
	      self.datum_params = v.split(",").map(function(a) {
	        return parseFloat(a);
	      });
	    },
	    to_meter: function(v) {
	      self.to_meter = parseFloat(v);
	    },
	    units: function(v) {
	      self.units = v;
	      if (units[v]) {
	        self.to_meter = units[v].to_meter;
	      }
	    },
	    from_greenwich: function(v) {
	      self.from_greenwich = v * D2R;
	    },
	    pm: function(v) {
	      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
	    },
	    nadgrids: function(v) {
	      if (v === '@null') {
	        self.datumCode = 'none';
	      }
	      else {
	        self.nadgrids = v;
	      }
	    },
	    axis: function(v) {
	      var legalAxis = "ewnsud";
	      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
	        self.axis = v;
	      }
	    }
	  };
	  for (paramName in paramObj) {
	    paramVal = paramObj[paramName];
	    if (paramName in params) {
	      paramOutname = params[paramName];
	      if (typeof paramOutname === 'function') {
	        paramOutname(paramVal);
	      }
	      else {
	        self[paramOutname] = paramVal;
	      }
	    }
	    else {
	      self[paramName] = paramVal;
	    }
	  }
	  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
	    self.datumCode = self.datumCode.toLowerCase();
	  }
	  return self;
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	exports.greenwich = 0.0; //"0dE",
	exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
	exports.paris = 2.337229166667; //"2d20'14.025\"E",
	exports.bogota = -74.080916666667; //"74d04'51.3\"W",
	exports.madrid = -3.687938888889; //"3d41'16.58\"W",
	exports.rome = 12.452333333333; //"12d27'8.4\"E",
	exports.bern = 7.439583333333; //"7d26'22.5\"E",
	exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
	exports.ferro = -17.666666666667; //"17d40'W",
	exports.brussels = 4.367975; //"4d22'4.71\"E",
	exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
	exports.athens = 23.7163375; //"23d42'58.815\"E",
	exports.oslo = 10.722916666667; //"10d43'22.5\"E"

/***/ },
/* 15 */
/***/ function(module, exports) {

	exports.ft = {to_meter: 0.3048};
	exports['us-ft'] = {to_meter: 1200 / 3937};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var D2R = 0.01745329251994329577;
	var extend = __webpack_require__(17);

	function mapit(obj, key, v) {
	  obj[key] = v.map(function(aa) {
	    var o = {};
	    sExpr(aa, o);
	    return o;
	  }).reduce(function(a, b) {
	    return extend(a, b);
	  }, {});
	}

	function sExpr(v, obj) {
	  var key;
	  if (!Array.isArray(v)) {
	    obj[v] = true;
	    return;
	  }
	  else {
	    key = v.shift();
	    if (key === 'PARAMETER') {
	      key = v.shift();
	    }
	    if (v.length === 1) {
	      if (Array.isArray(v[0])) {
	        obj[key] = {};
	        sExpr(v[0], obj[key]);
	      }
	      else {
	        obj[key] = v[0];
	      }
	    }
	    else if (!v.length) {
	      obj[key] = true;
	    }
	    else if (key === 'TOWGS84') {
	      obj[key] = v;
	    }
	    else {
	      obj[key] = {};
	      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {
	        obj[key] = {
	          name: v[0].toLowerCase(),
	          convert: v[1]
	        };
	        if (v.length === 3) {
	          obj[key].auth = v[2];
	        }
	      }
	      else if (key === 'SPHEROID') {
	        obj[key] = {
	          name: v[0],
	          a: v[1],
	          rf: v[2]
	        };
	        if (v.length === 4) {
	          obj[key].auth = v[3];
	        }
	      }
	      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {
	        v[0] = ['name', v[0]];
	        mapit(obj, key, v);
	      }
	      else if (v.every(function(aa) {
	        return Array.isArray(aa);
	      })) {
	        mapit(obj, key, v);
	      }
	      else {
	        sExpr(v, obj[key]);
	      }
	    }
	  }
	}

	function rename(obj, params) {
	  var outName = params[0];
	  var inName = params[1];
	  if (!(outName in obj) && (inName in obj)) {
	    obj[outName] = obj[inName];
	    if (params.length === 3) {
	      obj[outName] = params[2](obj[outName]);
	    }
	  }
	}

	function d2r(input) {
	  return input * D2R;
	}

	function cleanWKT(wkt) {
	  if (wkt.type === 'GEOGCS') {
	    wkt.projName = 'longlat';
	  }
	  else if (wkt.type === 'LOCAL_CS') {
	    wkt.projName = 'identity';
	    wkt.local = true;
	  }
	  else {
	    if (typeof wkt.PROJECTION === "object") {
	      wkt.projName = Object.keys(wkt.PROJECTION)[0];
	    }
	    else {
	      wkt.projName = wkt.PROJECTION;
	    }
	  }
	  if (wkt.UNIT) {
	    wkt.units = wkt.UNIT.name.toLowerCase();
	    if (wkt.units === 'metre') {
	      wkt.units = 'meter';
	    }
	    if (wkt.UNIT.convert) {
	      if (wkt.type === 'GEOGCS') {
	        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
	          wkt.to_meter = parseFloat(wkt.UNIT.convert, 10)*wkt.DATUM.SPHEROID.a;
	        }
	      } else {
	        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
	      }
	    }
	  }

	  if (wkt.GEOGCS) {
	    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
	    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
	    //}
	    if (wkt.GEOGCS.DATUM) {
	      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
	    }
	    else {
	      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
	    }
	    if (wkt.datumCode.slice(0, 2) === 'd_') {
	      wkt.datumCode = wkt.datumCode.slice(2);
	    }
	    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
	      wkt.datumCode = 'nzgd49';
	    }
	    if (wkt.datumCode === "wgs_1984") {
	      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
	        wkt.sphere = true;
	      }
	      wkt.datumCode = 'wgs84';
	    }
	    if (wkt.datumCode.slice(-6) === '_ferro') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 6);
	    }
	    if (wkt.datumCode.slice(-8) === '_jakarta') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 8);
	    }
	    if (~wkt.datumCode.indexOf('belge')) {
	      wkt.datumCode = "rnb72";
	    }
	    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
	      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
	      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
	        wkt.ellps = 'intl';
	      }

	      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
	      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
	    }
	    if (~wkt.datumCode.indexOf('osgb_1936')) {
	      wkt.datumCode = "osgb36";
	    }
	  }
	  if (wkt.b && !isFinite(wkt.b)) {
	    wkt.b = wkt.a;
	  }

	  function toMeter(input) {
	    var ratio = wkt.to_meter || 1;
	    return parseFloat(input, 10) * ratio;
	  }
	  var renamer = function(a) {
	    return rename(wkt, a);
	  };
	  var list = [
	    ['standard_parallel_1', 'Standard_Parallel_1'],
	    ['standard_parallel_2', 'Standard_Parallel_2'],
	    ['false_easting', 'False_Easting'],
	    ['false_northing', 'False_Northing'],
	    ['central_meridian', 'Central_Meridian'],
	    ['latitude_of_origin', 'Latitude_Of_Origin'],
	    ['latitude_of_origin', 'Central_Parallel'],
	    ['scale_factor', 'Scale_Factor'],
	    ['k0', 'scale_factor'],
	    ['latitude_of_center', 'Latitude_of_center'],
	    ['lat0', 'latitude_of_center', d2r],
	    ['longitude_of_center', 'Longitude_Of_Center'],
	    ['longc', 'longitude_of_center', d2r],
	    ['x0', 'false_easting', toMeter],
	    ['y0', 'false_northing', toMeter],
	    ['long0', 'central_meridian', d2r],
	    ['lat0', 'latitude_of_origin', d2r],
	    ['lat0', 'standard_parallel_1', d2r],
	    ['lat1', 'standard_parallel_1', d2r],
	    ['lat2', 'standard_parallel_2', d2r],
	    ['alpha', 'azimuth', d2r],
	    ['srsCode', 'name']
	  ];
	  list.forEach(renamer);
	  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
	    wkt.long0 = wkt.longc;
	  }
	  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
	    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
	    wkt.lat_ts = wkt.lat1;
	  }
	}
	module.exports = function(wkt, self) {
	  var lisp = JSON.parse(("," + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/,''));
	  var type = lisp.shift();
	  var name = lisp.shift();
	  lisp.unshift(['name', name]);
	  lisp.unshift(['type', type]);
	  lisp.unshift('output');
	  var obj = {};
	  sExpr(lisp, obj);
	  cleanWKT(obj.output);
	  return extend(self, obj.output);
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(destination, source) {
	  destination = destination || {};
	  var value, property;
	  if (!source) {
	    return destination;
	  }
	  for (property in source) {
	    value = source[property];
	    if (value !== undefined) {
	      destination[property] = value;
	    }
	  }
	  return destination;
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var projs = [
	  __webpack_require__(19),
	  __webpack_require__(25)
	];
	var names = {};
	var projStore = [];

	function add(proj, i) {
	  var len = projStore.length;
	  if (!proj.names) {
	    console.log(i);
	    return true;
	  }
	  projStore[len] = proj;
	  proj.names.forEach(function(n) {
	    names[n.toLowerCase()] = len;
	  });
	  return this;
	}

	exports.add = add;

	exports.get = function(name) {
	  if (!name) {
	    return false;
	  }
	  var n = name.toLowerCase();
	  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
	    return projStore[names[n]];
	  }
	};
	exports.start = function() {
	  projs.forEach(add);
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var msfnz = __webpack_require__(20);
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var R2D = 57.29577951308232088;
	var adjust_lon = __webpack_require__(21);
	var FORTPI = Math.PI/4;
	var tsfnz = __webpack_require__(23);
	var phi2z = __webpack_require__(24);
	exports.init = function() {
	  var con = this.b / this.a;
	  this.es = 1 - con * con;
	  if(!('x0' in this)){
	    this.x0 = 0;
	  }
	  if(!('y0' in this)){
	    this.y0 = 0;
	  }
	  this.e = Math.sqrt(this.es);
	  if (this.lat_ts) {
	    if (this.sphere) {
	      this.k0 = Math.cos(this.lat_ts);
	    }
	    else {
	      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	    }
	  }
	  else {
	    if (!this.k0) {
	      if (this.k) {
	        this.k0 = this.k;
	      }
	      else {
	        this.k0 = 1;
	      }
	    }
	  }
	};

	/* Mercator forward equations--mapping lat,long to x,y
	  --------------------------------------------------*/

	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  // convert to radians
	  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
	    return null;
	  }

	  var x, y;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    return null;
	  }
	  else {
	    if (this.sphere) {
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
	    }
	    else {
	      var sinphi = Math.sin(lat);
	      var ts = tsfnz(this.e, lat, sinphi);
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 - this.a * this.k0 * Math.log(ts);
	    }
	    p.x = x;
	    p.y = y;
	    return p;
	  }
	};


	/* Mercator inverse equations--mapping x,y to lat/long
	  --------------------------------------------------*/
	exports.inverse = function(p) {

	  var x = p.x - this.x0;
	  var y = p.y - this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
	  }
	  else {
	    var ts = Math.exp(-y / (this.a * this.k0));
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

	  p.x = lon;
	  p.y = lat;
	  return p;
	};

	exports.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];


/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(eccent, sinphi, cosphi) {
	  var con = eccent * sinphi;
	  return cosphi / (Math.sqrt(1 - con * con));
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var TWO_PI = Math.PI * 2;
	// SPI is slightly greater than Math.PI, so values that exceed the -180..180
	// degree range by a tiny amount don't get wrapped. This prevents points that
	// have drifted from their original location along the 180th meridian (due to
	// floating point error) from changing their sign.
	var SPI = 3.14159265359;
	var sign = __webpack_require__(22);

	module.exports = function(x) {
	  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
	};

/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = function(x) {
	  return x<0 ? -1 : 1;
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	var HALF_PI = Math.PI/2;

	module.exports = function(eccent, phi, sinphi) {
	  var con = eccent * sinphi;
	  var com = 0.5 * eccent;
	  con = Math.pow(((1 - con) / (1 + con)), com);
	  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var HALF_PI = Math.PI/2;
	module.exports = function(eccent, ts) {
	  var eccnth = 0.5 * eccent;
	  var con, dphi;
	  var phi = HALF_PI - 2 * Math.atan(ts);
	  for (var i = 0; i <= 15; i++) {
	    con = eccent * Math.sin(phi);
	    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }
	  //console.log("phi2z has NoConvergence");
	  return -9999;
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	exports.init = function() {
	  //no-op for longlat
	};

	function identity(pt) {
	  return pt;
	}
	exports.forward = identity;
	exports.inverse = identity;
	exports.names = ["longlat", "identity"];


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var Datum = __webpack_require__(27);
	var Ellipsoid = __webpack_require__(28);
	var extend = __webpack_require__(17);
	var datum = __webpack_require__(29);
	var EPSLN = 1.0e-10;
	// ellipoid pj_set_ell.c
	var SIXTH = 0.1666666666666666667;
	/* 1/6 */
	var RA4 = 0.04722222222222222222;
	/* 17/360 */
	var RA6 = 0.02215608465608465608;
	module.exports = function(json) {
	  // DGR 2011-03-20 : nagrids -> nadgrids
	  if (json.datumCode && json.datumCode !== 'none') {
	    var datumDef = Datum[json.datumCode];
	    if (datumDef) {
	      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
	      json.ellps = datumDef.ellipse;
	      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
	    }
	  }
	  if (!json.a) { // do we have an ellipsoid?
	    var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
	    extend(json, ellipse);
	  }
	  if (json.rf && !json.b) {
	    json.b = (1.0 - 1.0 / json.rf) * json.a;
	  }
	  if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
	    json.sphere = true;
	    json.b = json.a;
	  }
	  json.a2 = json.a * json.a; // used in geocentric
	  json.b2 = json.b * json.b; // used in geocentric
	  json.es = (json.a2 - json.b2) / json.a2; // e ^ 2
	  json.e = Math.sqrt(json.es); // eccentricity
	  if (json.R_A) {
	    json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
	    json.a2 = json.a * json.a;
	    json.b2 = json.b * json.b;
	    json.es = 0;
	  }
	  json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric
	  if (!json.k0) {
	    json.k0 = 1.0; //default value
	  }
	  //DGR 2010-11-12: axis
	  if (!json.axis) {
	    json.axis = "enu";
	  }

	  if (!json.datum) {
	    json.datum = datum(json);
	  }
	  return json;
	};


/***/ },
/* 27 */
/***/ function(module, exports) {

	exports.wgs84 = {
	  towgs84: "0,0,0",
	  ellipse: "WGS84",
	  datumName: "WGS84"
	};
	exports.ch1903 = {
	  towgs84: "674.374,15.056,405.346",
	  ellipse: "bessel",
	  datumName: "swiss"
	};
	exports.ggrs87 = {
	  towgs84: "-199.87,74.79,246.62",
	  ellipse: "GRS80",
	  datumName: "Greek_Geodetic_Reference_System_1987"
	};
	exports.nad83 = {
	  towgs84: "0,0,0",
	  ellipse: "GRS80",
	  datumName: "North_American_Datum_1983"
	};
	exports.nad27 = {
	  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
	  ellipse: "clrk66",
	  datumName: "North_American_Datum_1927"
	};
	exports.potsdam = {
	  towgs84: "606.0,23.0,413.0",
	  ellipse: "bessel",
	  datumName: "Potsdam Rauenberg 1950 DHDN"
	};
	exports.carthage = {
	  towgs84: "-263.0,6.0,431.0",
	  ellipse: "clark80",
	  datumName: "Carthage 1934 Tunisia"
	};
	exports.hermannskogel = {
	  towgs84: "653.0,-212.0,449.0",
	  ellipse: "bessel",
	  datumName: "Hermannskogel"
	};
	exports.ire65 = {
	  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	  ellipse: "mod_airy",
	  datumName: "Ireland 1965"
	};
	exports.rassadiran = {
	  towgs84: "-133.63,-157.5,-158.62",
	  ellipse: "intl",
	  datumName: "Rassadiran"
	};
	exports.nzgd49 = {
	  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
	  ellipse: "intl",
	  datumName: "New Zealand Geodetic Datum 1949"
	};
	exports.osgb36 = {
	  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
	  ellipse: "airy",
	  datumName: "Airy 1830"
	};
	exports.s_jtsk = {
	  towgs84: "589,76,480",
	  ellipse: 'bessel',
	  datumName: 'S-JTSK (Ferro)'
	};
	exports.beduaram = {
	  towgs84: '-106,-87,188',
	  ellipse: 'clrk80',
	  datumName: 'Beduaram'
	};
	exports.gunung_segara = {
	  towgs84: '-403,684,41',
	  ellipse: 'bessel',
	  datumName: 'Gunung Segara Jakarta'
	};
	exports.rnb72 = {
	  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
	  ellipse: "intl",
	  datumName: "Reseau National Belge 1972"
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	exports.MERIT = {
	  a: 6378137.0,
	  rf: 298.257,
	  ellipseName: "MERIT 1983"
	};
	exports.SGS85 = {
	  a: 6378136.0,
	  rf: 298.257,
	  ellipseName: "Soviet Geodetic System 85"
	};
	exports.GRS80 = {
	  a: 6378137.0,
	  rf: 298.257222101,
	  ellipseName: "GRS 1980(IUGG, 1980)"
	};
	exports.IAU76 = {
	  a: 6378140.0,
	  rf: 298.257,
	  ellipseName: "IAU 1976"
	};
	exports.airy = {
	  a: 6377563.396,
	  b: 6356256.910,
	  ellipseName: "Airy 1830"
	};
	exports.APL4 = {
	  a: 6378137,
	  rf: 298.25,
	  ellipseName: "Appl. Physics. 1965"
	};
	exports.NWL9D = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "Naval Weapons Lab., 1965"
	};
	exports.mod_airy = {
	  a: 6377340.189,
	  b: 6356034.446,
	  ellipseName: "Modified Airy"
	};
	exports.andrae = {
	  a: 6377104.43,
	  rf: 300.0,
	  ellipseName: "Andrae 1876 (Den., Iclnd.)"
	};
	exports.aust_SA = {
	  a: 6378160.0,
	  rf: 298.25,
	  ellipseName: "Australian Natl & S. Amer. 1969"
	};
	exports.GRS67 = {
	  a: 6378160.0,
	  rf: 298.2471674270,
	  ellipseName: "GRS 67(IUGG 1967)"
	};
	exports.bessel = {
	  a: 6377397.155,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841"
	};
	exports.bess_nam = {
	  a: 6377483.865,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841 (Namibia)"
	};
	exports.clrk66 = {
	  a: 6378206.4,
	  b: 6356583.8,
	  ellipseName: "Clarke 1866"
	};
	exports.clrk80 = {
	  a: 6378249.145,
	  rf: 293.4663,
	  ellipseName: "Clarke 1880 mod."
	};
	exports.clrk58 = {
	  a: 6378293.645208759,
	  rf: 294.2606763692654,
	  ellipseName: "Clarke 1858"
	};
	exports.CPM = {
	  a: 6375738.7,
	  rf: 334.29,
	  ellipseName: "Comm. des Poids et Mesures 1799"
	};
	exports.delmbr = {
	  a: 6376428.0,
	  rf: 311.5,
	  ellipseName: "Delambre 1810 (Belgium)"
	};
	exports.engelis = {
	  a: 6378136.05,
	  rf: 298.2566,
	  ellipseName: "Engelis 1985"
	};
	exports.evrst30 = {
	  a: 6377276.345,
	  rf: 300.8017,
	  ellipseName: "Everest 1830"
	};
	exports.evrst48 = {
	  a: 6377304.063,
	  rf: 300.8017,
	  ellipseName: "Everest 1948"
	};
	exports.evrst56 = {
	  a: 6377301.243,
	  rf: 300.8017,
	  ellipseName: "Everest 1956"
	};
	exports.evrst69 = {
	  a: 6377295.664,
	  rf: 300.8017,
	  ellipseName: "Everest 1969"
	};
	exports.evrstSS = {
	  a: 6377298.556,
	  rf: 300.8017,
	  ellipseName: "Everest (Sabah & Sarawak)"
	};
	exports.fschr60 = {
	  a: 6378166.0,
	  rf: 298.3,
	  ellipseName: "Fischer (Mercury Datum) 1960"
	};
	exports.fschr60m = {
	  a: 6378155.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1960"
	};
	exports.fschr68 = {
	  a: 6378150.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1968"
	};
	exports.helmert = {
	  a: 6378200.0,
	  rf: 298.3,
	  ellipseName: "Helmert 1906"
	};
	exports.hough = {
	  a: 6378270.0,
	  rf: 297.0,
	  ellipseName: "Hough"
	};
	exports.intl = {
	  a: 6378388.0,
	  rf: 297.0,
	  ellipseName: "International 1909 (Hayford)"
	};
	exports.kaula = {
	  a: 6378163.0,
	  rf: 298.24,
	  ellipseName: "Kaula 1961"
	};
	exports.lerch = {
	  a: 6378139.0,
	  rf: 298.257,
	  ellipseName: "Lerch 1979"
	};
	exports.mprts = {
	  a: 6397300.0,
	  rf: 191.0,
	  ellipseName: "Maupertius 1738"
	};
	exports.new_intl = {
	  a: 6378157.5,
	  b: 6356772.2,
	  ellipseName: "New International 1967"
	};
	exports.plessis = {
	  a: 6376523.0,
	  rf: 6355863.0,
	  ellipseName: "Plessis 1817 (France)"
	};
	exports.krass = {
	  a: 6378245.0,
	  rf: 298.3,
	  ellipseName: "Krassovsky, 1942"
	};
	exports.SEasia = {
	  a: 6378155.0,
	  b: 6356773.3205,
	  ellipseName: "Southeast Asia"
	};
	exports.walbeck = {
	  a: 6376896.0,
	  b: 6355834.8467,
	  ellipseName: "Walbeck"
	};
	exports.WGS60 = {
	  a: 6378165.0,
	  rf: 298.3,
	  ellipseName: "WGS 60"
	};
	exports.WGS66 = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "WGS 66"
	};
	exports.WGS7 = {
	  a: 6378135.0,
	  rf: 298.26,
	  ellipseName: "WGS 72"
	};
	exports.WGS84 = {
	  a: 6378137.0,
	  rf: 298.257223563,
	  ellipseName: "WGS 84"
	};
	exports.sphere = {
	  a: 6370997.0,
	  b: 6370997.0,
	  ellipseName: "Normal Sphere (r=6370997)"
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	var HALF_PI = Math.PI/2;
	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var PJD_GRIDSHIFT = 3;
	var PJD_WGS84 = 4; // WGS84 or equivalent
	var PJD_NODATUM = 5; // WGS84 or equivalent
	var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	var AD_C = 1.0026000;
	var COS_67P5 = 0.38268343236508977;
	var datum = function(proj) {
	  if (!(this instanceof datum)) {
	    return new datum(proj);
	  }
	  this.datum_type = PJD_WGS84; //default setting
	  if (!proj) {
	    return;
	  }
	  if (proj.datumCode && proj.datumCode === 'none') {
	    this.datum_type = PJD_NODATUM;
	  }

	  if (proj.datum_params) {
	    this.datum_params = proj.datum_params.map(parseFloat);
	    if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {
	      this.datum_type = PJD_3PARAM;
	    }
	    if (this.datum_params.length > 3) {
	      if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {
	        this.datum_type = PJD_7PARAM;
	        this.datum_params[3] *= SEC_TO_RAD;
	        this.datum_params[4] *= SEC_TO_RAD;
	        this.datum_params[5] *= SEC_TO_RAD;
	        this.datum_params[6] = (this.datum_params[6] / 1000000.0) + 1.0;
	      }
	    }
	  }

	  // DGR 2011-03-21 : nadgrids support
	  this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;

	  this.a = proj.a; //datum object also uses these values
	  this.b = proj.b;
	  this.es = proj.es;
	  this.ep2 = proj.ep2;
	  if (this.datum_type === PJD_GRIDSHIFT) {
	    this.grids = proj.grids;
	  }
	};
	datum.prototype = {


	  /****************************************************************/
	  // cs_compare_datums()
	  //   Returns TRUE if the two datums match, otherwise FALSE.
	  compare_datums: function(dest) {
	    if (this.datum_type !== dest.datum_type) {
	      return false; // false, datums are not equal
	    }
	    else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {
	      // the tolerence for es is to ensure that GRS80 and WGS84
	      // are considered identical
	      return false;
	    }
	    else if (this.datum_type === PJD_3PARAM) {
	      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2]);
	    }
	    else if (this.datum_type === PJD_7PARAM) {
	      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6]);
	    }
	    else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
	      //alert("ERROR: Grid shift transformations are not implemented.");
	      //return false
	      //DGR 2012-07-29 lazy ...
	      return this.nadgrids === dest.nadgrids;
	    }
	    else {
	      return true; // datums are equal
	    }
	  }, // cs_compare_datums()

	  /*
	   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
	   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
	   * according to the current ellipsoid parameters.
	   *
	   *    Latitude  : Geodetic latitude in radians                     (input)
	   *    Longitude : Geodetic longitude in radians                    (input)
	   *    Height    : Geodetic height, in meters                       (input)
	   *    X         : Calculated Geocentric X coordinate, in meters    (output)
	   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
	   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
	   *
	   */
	  geodetic_to_geocentric: function(p) {
	    var Longitude = p.x;
	    var Latitude = p.y;
	    var Height = p.z ? p.z : 0; //Z value not always supplied
	    var X; // output
	    var Y;
	    var Z;

	    var Error_Code = 0; //  GEOCENT_NO_ERROR;
	    var Rn; /*  Earth radius at location  */
	    var Sin_Lat; /*  Math.sin(Latitude)  */
	    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
	    var Cos_Lat; /*  Math.cos(Latitude)  */

	    /*
	     ** Don't blow up if Latitude is just a little out of the value
	     ** range as it may just be a rounding issue.  Also removed longitude
	     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
	     */
	    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
	      Latitude = -HALF_PI;
	    }
	    else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
	      Latitude = HALF_PI;
	    }
	    else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
	      /* Latitude out of range */
	      //..reportError('geocent:lat out of range:' + Latitude);
	      return null;
	    }

	    if (Longitude > Math.PI) {
	      Longitude -= (2 * Math.PI);
	    }
	    Sin_Lat = Math.sin(Latitude);
	    Cos_Lat = Math.cos(Latitude);
	    Sin2_Lat = Sin_Lat * Sin_Lat;
	    Rn = this.a / (Math.sqrt(1.0e0 - this.es * Sin2_Lat));
	    X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
	    Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
	    Z = ((Rn * (1 - this.es)) + Height) * Sin_Lat;

	    p.x = X;
	    p.y = Y;
	    p.z = Z;
	    return Error_Code;
	  }, // cs_geodetic_to_geocentric()


	  geocentric_to_geodetic: function(p) {
	    /* local defintions and variables */
	    /* end-criterium of loop, accuracy of sin(Latitude) */
	    var genau = 1e-12;
	    var genau2 = (genau * genau);
	    var maxiter = 30;

	    var P; /* distance between semi-minor axis and location */
	    var RR; /* distance between center and location */
	    var CT; /* sin of geocentric latitude */
	    var ST; /* cos of geocentric latitude */
	    var RX;
	    var RK;
	    var RN; /* Earth radius at location */
	    var CPHI0; /* cos of start or old geodetic latitude in iterations */
	    var SPHI0; /* sin of start or old geodetic latitude in iterations */
	    var CPHI; /* cos of searched geodetic latitude */
	    var SPHI; /* sin of searched geodetic latitude */
	    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
	    var At_Pole; /* indicates location is in polar region */
	    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

	    var X = p.x;
	    var Y = p.y;
	    var Z = p.z ? p.z : 0.0; //Z value not always supplied
	    var Longitude;
	    var Latitude;
	    var Height;

	    At_Pole = false;
	    P = Math.sqrt(X * X + Y * Y);
	    RR = Math.sqrt(X * X + Y * Y + Z * Z);

	    /*      special cases for latitude and longitude */
	    if (P / this.a < genau) {

	      /*  special case, if P=0. (X=0., Y=0.) */
	      At_Pole = true;
	      Longitude = 0.0;

	      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
	       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
	      if (RR / this.a < genau) {
	        Latitude = HALF_PI;
	        Height = -this.b;
	        return;
	      }
	    }
	    else {
	      /*  ellipsoidal (geodetic) longitude
	       *  interval: -PI < Longitude <= +PI */
	      Longitude = Math.atan2(Y, X);
	    }

	    /* --------------------------------------------------------------
	     * Following iterative algorithm was developped by
	     * "Institut for Erdmessung", University of Hannover, July 1988.
	     * Internet: www.ife.uni-hannover.de
	     * Iterative computation of CPHI,SPHI and Height.
	     * Iteration of CPHI and SPHI to 10**-12 radian resp.
	     * 2*10**-7 arcsec.
	     * --------------------------------------------------------------
	     */
	    CT = Z / RR;
	    ST = P / RR;
	    RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);
	    CPHI0 = ST * (1.0 - this.es) * RX;
	    SPHI0 = CT * RX;
	    iter = 0;

	    /* loop to find sin(Latitude) resp. Latitude
	     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
	    do {
	      iter++;
	      RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);

	      /*  ellipsoidal (geodetic) height */
	      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);

	      RK = this.es * RN / (RN + Height);
	      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
	      CPHI = ST * (1.0 - RK) * RX;
	      SPHI = CT * RX;
	      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
	      CPHI0 = CPHI;
	      SPHI0 = SPHI;
	    }
	    while (SDPHI * SDPHI > genau2 && iter < maxiter);

	    /*      ellipsoidal (geodetic) latitude */
	    Latitude = Math.atan(SPHI / Math.abs(CPHI));

	    p.x = Longitude;
	    p.y = Latitude;
	    p.z = Height;
	    return p;
	  }, // cs_geocentric_to_geodetic()

	  /** Convert_Geocentric_To_Geodetic
	   * The method used here is derived from 'An Improved Algorithm for
	   * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996
	   */
	  geocentric_to_geodetic_noniter: function(p) {
	    var X = p.x;
	    var Y = p.y;
	    var Z = p.z ? p.z : 0; //Z value not always supplied
	    var Longitude;
	    var Latitude;
	    var Height;

	    var W; /* distance from Z axis */
	    var W2; /* square of distance from Z axis */
	    var T0; /* initial estimate of vertical component */
	    var T1; /* corrected estimate of vertical component */
	    var S0; /* initial estimate of horizontal component */
	    var S1; /* corrected estimate of horizontal component */
	    var Sin_B0; /* Math.sin(B0), B0 is estimate of Bowring aux variable */
	    var Sin3_B0; /* cube of Math.sin(B0) */
	    var Cos_B0; /* Math.cos(B0) */
	    var Sin_p1; /* Math.sin(phi1), phi1 is estimated latitude */
	    var Cos_p1; /* Math.cos(phi1) */
	    var Rn; /* Earth radius at location */
	    var Sum; /* numerator of Math.cos(phi1) */
	    var At_Pole; /* indicates location is in polar region */

	    X = parseFloat(X); // cast from string to float
	    Y = parseFloat(Y);
	    Z = parseFloat(Z);

	    At_Pole = false;
	    if (X !== 0.0) {
	      Longitude = Math.atan2(Y, X);
	    }
	    else {
	      if (Y > 0) {
	        Longitude = HALF_PI;
	      }
	      else if (Y < 0) {
	        Longitude = -HALF_PI;
	      }
	      else {
	        At_Pole = true;
	        Longitude = 0.0;
	        if (Z > 0.0) { /* north pole */
	          Latitude = HALF_PI;
	        }
	        else if (Z < 0.0) { /* south pole */
	          Latitude = -HALF_PI;
	        }
	        else { /* center of earth */
	          Latitude = HALF_PI;
	          Height = -this.b;
	          return;
	        }
	      }
	    }
	    W2 = X * X + Y * Y;
	    W = Math.sqrt(W2);
	    T0 = Z * AD_C;
	    S0 = Math.sqrt(T0 * T0 + W2);
	    Sin_B0 = T0 / S0;
	    Cos_B0 = W / S0;
	    Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
	    T1 = Z + this.b * this.ep2 * Sin3_B0;
	    Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
	    S1 = Math.sqrt(T1 * T1 + Sum * Sum);
	    Sin_p1 = T1 / S1;
	    Cos_p1 = Sum / S1;
	    Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);
	    if (Cos_p1 >= COS_67P5) {
	      Height = W / Cos_p1 - Rn;
	    }
	    else if (Cos_p1 <= -COS_67P5) {
	      Height = W / -Cos_p1 - Rn;
	    }
	    else {
	      Height = Z / Sin_p1 + Rn * (this.es - 1.0);
	    }
	    if (At_Pole === false) {
	      Latitude = Math.atan(Sin_p1 / Cos_p1);
	    }

	    p.x = Longitude;
	    p.y = Latitude;
	    p.z = Height;
	    return p;
	  }, // geocentric_to_geodetic_noniter()

	  /****************************************************************/
	  // pj_geocentic_to_wgs84( p )
	  //  p = point to transform in geocentric coordinates (x,y,z)
	  geocentric_to_wgs84: function(p) {

	    if (this.datum_type === PJD_3PARAM) {
	      // if( x[io] === HUGE_VAL )
	      //    continue;
	      p.x += this.datum_params[0];
	      p.y += this.datum_params[1];
	      p.z += this.datum_params[2];

	    }
	    else if (this.datum_type === PJD_7PARAM) {
	      var Dx_BF = this.datum_params[0];
	      var Dy_BF = this.datum_params[1];
	      var Dz_BF = this.datum_params[2];
	      var Rx_BF = this.datum_params[3];
	      var Ry_BF = this.datum_params[4];
	      var Rz_BF = this.datum_params[5];
	      var M_BF = this.datum_params[6];
	      // if( x[io] === HUGE_VAL )
	      //    continue;
	      var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
	      var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
	      var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
	      p.x = x_out;
	      p.y = y_out;
	      p.z = z_out;
	    }
	  }, // cs_geocentric_to_wgs84

	  /****************************************************************/
	  // pj_geocentic_from_wgs84()
	  //  coordinate system definition,
	  //  point to transform in geocentric coordinates (x,y,z)
	  geocentric_from_wgs84: function(p) {

	    if (this.datum_type === PJD_3PARAM) {
	      //if( x[io] === HUGE_VAL )
	      //    continue;
	      p.x -= this.datum_params[0];
	      p.y -= this.datum_params[1];
	      p.z -= this.datum_params[2];

	    }
	    else if (this.datum_type === PJD_7PARAM) {
	      var Dx_BF = this.datum_params[0];
	      var Dy_BF = this.datum_params[1];
	      var Dz_BF = this.datum_params[2];
	      var Rx_BF = this.datum_params[3];
	      var Ry_BF = this.datum_params[4];
	      var Rz_BF = this.datum_params[5];
	      var M_BF = this.datum_params[6];
	      var x_tmp = (p.x - Dx_BF) / M_BF;
	      var y_tmp = (p.y - Dy_BF) / M_BF;
	      var z_tmp = (p.z - Dz_BF) / M_BF;
	      //if( x[io] === HUGE_VAL )
	      //    continue;

	      p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
	      p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
	      p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
	    } //cs_geocentric_from_wgs84()
	  }
	};

	/** point object, nothing fancy, just allows values to be
	    passed back and forth by reference rather than by value.
	    Other point classes may be used as long as they have
	    x and y properties, which will get modified in the transform method.
	*/
	module.exports = datum;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var D2R = 0.01745329251994329577;
	var R2D = 57.29577951308232088;
	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var datum_transform = __webpack_require__(31);
	var adjust_axis = __webpack_require__(32);
	var proj = __webpack_require__(9);
	var toPoint = __webpack_require__(33);
	module.exports = function transform(source, dest, point) {
	  var wgs84;
	  if (Array.isArray(point)) {
	    point = toPoint(point);
	  }
	  function checkNotWGS(source, dest) {
	    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84");
	  }

	  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
	  if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
	    wgs84 = new proj('WGS84');
	    transform(source, wgs84, point);
	    source = wgs84;
	  }
	  // DGR, 2010/11/12
	  if (source.axis !== "enu") {
	    adjust_axis(source, false, point);
	  }
	  // Transform source points to long/lat, if they aren't already.
	  if (source.projName === "longlat") {
	    point.x *= D2R; // convert degrees to radians
	    point.y *= D2R;
	  }
	  else {
	    if (source.to_meter) {
	      point.x *= source.to_meter;
	      point.y *= source.to_meter;
	    }
	    source.inverse(point); // Convert Cartesian to longlat
	  }
	  // Adjust for the prime meridian if necessary
	  if (source.from_greenwich) {
	    point.x += source.from_greenwich;
	  }

	  // Convert datums if needed, and if possible.
	  point = datum_transform(source.datum, dest.datum, point);

	  // Adjust for the prime meridian if necessary
	  if (dest.from_greenwich) {
	    point.x -= dest.from_greenwich;
	  }

	  if (dest.projName === "longlat") {
	    // convert radians to decimal degrees
	    point.x *= R2D;
	    point.y *= R2D;
	  }
	  else { // else project
	    dest.forward(point);
	    if (dest.to_meter) {
	      point.x /= dest.to_meter;
	      point.y /= dest.to_meter;
	    }
	  }

	  // DGR, 2010/11/12
	  if (dest.axis !== "enu") {
	    adjust_axis(dest, true, point);
	  }

	  return point;
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var PJD_GRIDSHIFT = 3;
	var PJD_NODATUM = 5; // WGS84 or equivalent
	var SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms
	var SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29
	module.exports = function(source, dest, point) {
	  var wp, i, l;

	  function checkParams(fallback) {
	    return (fallback === PJD_3PARAM || fallback === PJD_7PARAM);
	  }
	  // Short cut if the datums are identical.
	  if (source.compare_datums(dest)) {
	    return point; // in this case, zero is sucess,
	    // whereas cs_compare_datums returns 1 to indicate TRUE
	    // confusing, should fix this
	  }

	  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
	  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
	    return point;
	  }

	  //DGR: 2012-07-29 : add nadgrids support (begin)
	  var src_a = source.a;
	  var src_es = source.es;

	  var dst_a = dest.a;
	  var dst_es = dest.es;

	  var fallback = source.datum_type;
	  // If this datum requires grid shifts, then apply it to geodetic coordinates.
	  if (fallback === PJD_GRIDSHIFT) {
	    if (this.apply_gridshift(source, 0, point) === 0) {
	      source.a = SRS_WGS84_SEMIMAJOR;
	      source.es = SRS_WGS84_ESQUARED;
	    }
	    else {
	      // try 3 or 7 params transformation or nothing ?
	      if (!source.datum_params) {
	        source.a = src_a;
	        source.es = source.es;
	        return point;
	      }
	      wp = 1;
	      for (i = 0, l = source.datum_params.length; i < l; i++) {
	        wp *= source.datum_params[i];
	      }
	      if (wp === 0) {
	        source.a = src_a;
	        source.es = source.es;
	        return point;
	      }
	      if (source.datum_params.length > 3) {
	        fallback = PJD_7PARAM;
	      }
	      else {
	        fallback = PJD_3PARAM;
	      }
	    }
	  }
	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    dest.a = SRS_WGS84_SEMIMAJOR;
	    dest.es = SRS_WGS84_ESQUARED;
	  }
	  // Do we need to go through geocentric coordinates?
	  if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
	    //DGR: 2012-07-29 : add nadgrids support (end)
	    // Convert to geocentric coordinates.
	    source.geodetic_to_geocentric(point);
	    // CHECK_RETURN;
	    // Convert between datums
	    if (checkParams(source.datum_type)) {
	      source.geocentric_to_wgs84(point);
	      // CHECK_RETURN;
	    }
	    if (checkParams(dest.datum_type)) {
	      dest.geocentric_from_wgs84(point);
	      // CHECK_RETURN;
	    }
	    // Convert back to geodetic coordinates
	    dest.geocentric_to_geodetic(point);
	    // CHECK_RETURN;
	  }
	  // Apply grid shift to destination if required
	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    this.apply_gridshift(dest, 1, point);
	    // CHECK_RETURN;
	  }

	  source.a = src_a;
	  source.es = src_es;
	  dest.a = dst_a;
	  dest.es = dst_es;

	  return point;
	};



/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = function(crs, denorm, point) {
	  var xin = point.x,
	    yin = point.y,
	    zin = point.z || 0.0;
	  var v, t, i;
	  for (i = 0; i < 3; i++) {
	    if (denorm && i === 2 && point.z === undefined) {
	      continue;
	    }
	    if (i === 0) {
	      v = xin;
	      t = 'x';
	    }
	    else if (i === 1) {
	      v = yin;
	      t = 'y';
	    }
	    else {
	      v = zin;
	      t = 'z';
	    }
	    switch (crs.axis[i]) {
	    case 'e':
	      point[t] = v;
	      break;
	    case 'w':
	      point[t] = -v;
	      break;
	    case 'n':
	      point[t] = v;
	      break;
	    case 's':
	      point[t] = -v;
	      break;
	    case 'u':
	      if (point[t] !== undefined) {
	        point.z = v;
	      }
	      break;
	    case 'd':
	      if (point[t] !== undefined) {
	        point.z = -v;
	      }
	      break;
	    default:
	      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
	      return null;
	    }
	  }
	  return point;
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = function (array){
	  var out = {
	    x: array[0],
	    y: array[1]
	  };
	  if (array.length>2) {
	    out.z = array[2];
	  }
	  if (array.length>3) {
	    out.m = array[3];
	  }
	  return out;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var mgrs = __webpack_require__(35);

	function Point(x, y, z) {
	  if (!(this instanceof Point)) {
	    return new Point(x, y, z);
	  }
	  if (Array.isArray(x)) {
	    this.x = x[0];
	    this.y = x[1];
	    this.z = x[2] || 0.0;
	  } else if(typeof x === 'object') {
	    this.x = x.x;
	    this.y = x.y;
	    this.z = x.z || 0.0;
	  } else if (typeof x === 'string' && typeof y === 'undefined') {
	    var coords = x.split(',');
	    this.x = parseFloat(coords[0], 10);
	    this.y = parseFloat(coords[1], 10);
	    this.z = parseFloat(coords[2], 10) || 0.0;
	  } else {
	    this.x = x;
	    this.y = y;
	    this.z = z || 0.0;
	  }
	  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
	}

	Point.fromMGRS = function(mgrsStr) {
	  return new Point(mgrs.toPoint(mgrsStr));
	};
	Point.prototype.toMGRS = function(accuracy) {
	  return mgrs.forward([this.x, this.y], accuracy);
	};
	module.exports = Point;


/***/ },
/* 35 */
/***/ function(module, exports) {

	


	/**
	 * UTM zones are grouped, and assigned to one of a group of 6
	 * sets.
	 *
	 * {int} @private
	 */
	var NUM_100K_SETS = 6;

	/**
	 * The column letters (for easting) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

	/**
	 * The row letters (for northing) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

	var A = 65; // A
	var I = 73; // I
	var O = 79; // O
	var V = 86; // V
	var Z = 90; // Z

	/**
	 * Conversion of lat/lon to MGRS.
	 *
	 * @param {object} ll Object literal with lat and lon properties on a
	 *     WGS84 ellipsoid.
	 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
	 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
	 * @return {string} the MGRS string for the given location and accuracy.
	 */
	exports.forward = function(ll, accuracy) {
	  accuracy = accuracy || 5; // default accuracy 1m
	  return encode(LLtoUTM({
	    lat: ll[1],
	    lon: ll[0]
	  }), accuracy);
	};

	/**
	 * Conversion of MGRS to lat/lon.
	 *
	 * @param {string} mgrs MGRS string.
	 * @return {array} An array with left (longitude), bottom (latitude), right
	 *     (longitude) and top (latitude) values in WGS84, representing the
	 *     bounding box for the provided MGRS reference.
	 */
	exports.inverse = function(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  if (bbox.lat && bbox.lon) {
	    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
	  }
	  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
	};

	exports.toPoint = function(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  if (bbox.lat && bbox.lon) {
	    return [bbox.lon, bbox.lat];
	  }
	  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
	};
	/**
	 * Conversion from degrees to radians.
	 *
	 * @private
	 * @param {number} deg the angle in degrees.
	 * @return {number} the angle in radians.
	 */
	function degToRad(deg) {
	  return (deg * (Math.PI / 180.0));
	}

	/**
	 * Conversion from radians to degrees.
	 *
	 * @private
	 * @param {number} rad the angle in radians.
	 * @return {number} the angle in degrees.
	 */
	function radToDeg(rad) {
	  return (180.0 * (rad / Math.PI));
	}

	/**
	 * Converts a set of Longitude and Latitude co-ordinates to UTM
	 * using the WGS84 ellipsoid.
	 *
	 * @private
	 * @param {object} ll Object literal with lat and lon properties
	 *     representing the WGS84 coordinate to be converted.
	 * @return {object} Object literal containing the UTM value with easting,
	 *     northing, zoneNumber and zoneLetter properties, and an optional
	 *     accuracy property in digits. Returns null if the conversion failed.
	 */
	function LLtoUTM(ll) {
	  var Lat = ll.lat;
	  var Long = ll.lon;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var k0 = 0.9996;
	  var LongOrigin;
	  var eccPrimeSquared;
	  var N, T, C, A, M;
	  var LatRad = degToRad(Lat);
	  var LongRad = degToRad(Long);
	  var LongOriginRad;
	  var ZoneNumber;
	  // (int)
	  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

	  //Make sure the longitude 180.00 is in Zone 60
	  if (Long === 180) {
	    ZoneNumber = 60;
	  }

	  // Special zone for Norway
	  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
	    ZoneNumber = 32;
	  }

	  // Special zones for Svalbard
	  if (Lat >= 72.0 && Lat < 84.0) {
	    if (Long >= 0.0 && Long < 9.0) {
	      ZoneNumber = 31;
	    }
	    else if (Long >= 9.0 && Long < 21.0) {
	      ZoneNumber = 33;
	    }
	    else if (Long >= 21.0 && Long < 33.0) {
	      ZoneNumber = 35;
	    }
	    else if (Long >= 33.0 && Long < 42.0) {
	      ZoneNumber = 37;
	    }
	  }

	  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
	  // in middle of
	  // zone
	  LongOriginRad = degToRad(LongOrigin);

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
	  T = Math.tan(LatRad) * Math.tan(LatRad);
	  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
	  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

	  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

	  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

	  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
	  if (Lat < 0.0) {
	    UTMNorthing += 10000000.0; //10000000 meter offset for
	    // southern hemisphere
	  }

	  return {
	    northing: Math.round(UTMNorthing),
	    easting: Math.round(UTMEasting),
	    zoneNumber: ZoneNumber,
	    zoneLetter: getLetterDesignator(Lat)
	  };
	}

	/**
	 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
	 * class where the Zone can be specified as a single string eg."60N" which
	 * is then broken down into the ZoneNumber and ZoneLetter.
	 *
	 * @private
	 * @param {object} utm An object literal with northing, easting, zoneNumber
	 *     and zoneLetter properties. If an optional accuracy property is
	 *     provided (in meters), a bounding box will be returned instead of
	 *     latitude and longitude.
	 * @return {object} An object literal containing either lat and lon values
	 *     (if no accuracy was provided), or top, right, bottom and left values
	 *     for the bounding box calculated according to the provided accuracy.
	 *     Returns null if the conversion failed.
	 */
	function UTMtoLL(utm) {

	  var UTMNorthing = utm.northing;
	  var UTMEasting = utm.easting;
	  var zoneLetter = utm.zoneLetter;
	  var zoneNumber = utm.zoneNumber;
	  // check the ZoneNummber is valid
	  if (zoneNumber < 0 || zoneNumber > 60) {
	    return null;
	  }

	  var k0 = 0.9996;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var eccPrimeSquared;
	  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
	  var N1, T1, C1, R1, D, M;
	  var LongOrigin;
	  var mu, phi1Rad;

	  // remove 500,000 meter offset for longitude
	  var x = UTMEasting - 500000.0;
	  var y = UTMNorthing;

	  // We must know somehow if we are in the Northern or Southern
	  // hemisphere, this is the only time we use the letter So even
	  // if the Zone letter isn't exactly correct it should indicate
	  // the hemisphere correctly
	  if (zoneLetter < 'N') {
	    y -= 10000000.0; // remove 10,000,000 meter offset used
	    // for southern hemisphere
	  }

	  // There are 60 zones with zone 1 being at West -180 to -174
	  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
	  // in middle of
	  // zone

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  M = y / k0;
	  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

	  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
	  // double phi1 = ProjMath.radToDeg(phi1Rad);

	  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
	  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
	  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
	  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
	  D = x / (N1 * k0);

	  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
	  lat = radToDeg(lat);

	  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
	  lon = LongOrigin + radToDeg(lon);

	  var result;
	  if (utm.accuracy) {
	    var topRight = UTMtoLL({
	      northing: utm.northing + utm.accuracy,
	      easting: utm.easting + utm.accuracy,
	      zoneLetter: utm.zoneLetter,
	      zoneNumber: utm.zoneNumber
	    });
	    result = {
	      top: topRight.lat,
	      right: topRight.lon,
	      bottom: lat,
	      left: lon
	    };
	  }
	  else {
	    result = {
	      lat: lat,
	      lon: lon
	    };
	  }
	  return result;
	}

	/**
	 * Calculates the MGRS letter designator for the given latitude.
	 *
	 * @private
	 * @param {number} lat The latitude in WGS84 to get the letter designator
	 *     for.
	 * @return {char} The letter designator.
	 */
	function getLetterDesignator(lat) {
	  //This is here as an error flag to show that the Latitude is
	  //outside MGRS limits
	  var LetterDesignator = 'Z';

	  if ((84 >= lat) && (lat >= 72)) {
	    LetterDesignator = 'X';
	  }
	  else if ((72 > lat) && (lat >= 64)) {
	    LetterDesignator = 'W';
	  }
	  else if ((64 > lat) && (lat >= 56)) {
	    LetterDesignator = 'V';
	  }
	  else if ((56 > lat) && (lat >= 48)) {
	    LetterDesignator = 'U';
	  }
	  else if ((48 > lat) && (lat >= 40)) {
	    LetterDesignator = 'T';
	  }
	  else if ((40 > lat) && (lat >= 32)) {
	    LetterDesignator = 'S';
	  }
	  else if ((32 > lat) && (lat >= 24)) {
	    LetterDesignator = 'R';
	  }
	  else if ((24 > lat) && (lat >= 16)) {
	    LetterDesignator = 'Q';
	  }
	  else if ((16 > lat) && (lat >= 8)) {
	    LetterDesignator = 'P';
	  }
	  else if ((8 > lat) && (lat >= 0)) {
	    LetterDesignator = 'N';
	  }
	  else if ((0 > lat) && (lat >= -8)) {
	    LetterDesignator = 'M';
	  }
	  else if ((-8 > lat) && (lat >= -16)) {
	    LetterDesignator = 'L';
	  }
	  else if ((-16 > lat) && (lat >= -24)) {
	    LetterDesignator = 'K';
	  }
	  else if ((-24 > lat) && (lat >= -32)) {
	    LetterDesignator = 'J';
	  }
	  else if ((-32 > lat) && (lat >= -40)) {
	    LetterDesignator = 'H';
	  }
	  else if ((-40 > lat) && (lat >= -48)) {
	    LetterDesignator = 'G';
	  }
	  else if ((-48 > lat) && (lat >= -56)) {
	    LetterDesignator = 'F';
	  }
	  else if ((-56 > lat) && (lat >= -64)) {
	    LetterDesignator = 'E';
	  }
	  else if ((-64 > lat) && (lat >= -72)) {
	    LetterDesignator = 'D';
	  }
	  else if ((-72 > lat) && (lat >= -80)) {
	    LetterDesignator = 'C';
	  }
	  return LetterDesignator;
	}

	/**
	 * Encodes a UTM location as MGRS string.
	 *
	 * @private
	 * @param {object} utm An object literal with easting, northing,
	 *     zoneLetter, zoneNumber
	 * @param {number} accuracy Accuracy in digits (1-5).
	 * @return {string} MGRS string for the given UTM location.
	 */
	function encode(utm, accuracy) {
	  // prepend with leading zeroes
	  var seasting = "00000" + utm.easting,
	    snorthing = "00000" + utm.northing;

	  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
	}

	/**
	 * Get the two letter 100k designator for a given UTM easting,
	 * northing and zone number value.
	 *
	 * @private
	 * @param {number} easting
	 * @param {number} northing
	 * @param {number} zoneNumber
	 * @return the two letter 100k designator for the given UTM location.
	 */
	function get100kID(easting, northing, zoneNumber) {
	  var setParm = get100kSetForZone(zoneNumber);
	  var setColumn = Math.floor(easting / 100000);
	  var setRow = Math.floor(northing / 100000) % 20;
	  return getLetter100kID(setColumn, setRow, setParm);
	}

	/**
	 * Given a UTM zone number, figure out the MGRS 100K set it is in.
	 *
	 * @private
	 * @param {number} i An UTM zone number.
	 * @return {number} the 100k set the UTM zone is in.
	 */
	function get100kSetForZone(i) {
	  var setParm = i % NUM_100K_SETS;
	  if (setParm === 0) {
	    setParm = NUM_100K_SETS;
	  }

	  return setParm;
	}

	/**
	 * Get the two-letter MGRS 100k designator given information
	 * translated from the UTM northing, easting and zone number.
	 *
	 * @private
	 * @param {number} column the column index as it relates to the MGRS
	 *        100k set spreadsheet, created from the UTM easting.
	 *        Values are 1-8.
	 * @param {number} row the row index as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM northing value. Values
	 *        are from 0-19.
	 * @param {number} parm the set block, as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM zone. Values are from
	 *        1-60.
	 * @return two letter MGRS 100k code.
	 */
	function getLetter100kID(column, row, parm) {
	  // colOrigin and rowOrigin are the letters at the origin of the set
	  var index = parm - 1;
	  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
	  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

	  // colInt and rowInt are the letters to build to return
	  var colInt = colOrigin + column - 1;
	  var rowInt = rowOrigin + row;
	  var rollover = false;

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	    rollover = true;
	  }

	  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
	    colInt++;
	  }

	  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
	    colInt++;

	    if (colInt === I) {
	      colInt++;
	    }
	  }

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	    rollover = true;
	  }
	  else {
	    rollover = false;
	  }

	  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
	    rowInt++;
	  }

	  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
	    rowInt++;

	    if (rowInt === I) {
	      rowInt++;
	    }
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	  }

	  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
	  return twoLetter;
	}

	/**
	 * Decode the UTM parameters from a MGRS string.
	 *
	 * @private
	 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
	 * @return {object} An object literal with easting, northing, zoneLetter,
	 *     zoneNumber and accuracy (in meters) properties.
	 */
	function decode(mgrsString) {

	  if (mgrsString && mgrsString.length === 0) {
	    throw ("MGRSPoint coverting from nothing");
	  }

	  var length = mgrsString.length;

	  var hunK = null;
	  var sb = "";
	  var testChar;
	  var i = 0;

	  // get Zone number
	  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
	    if (i >= 2) {
	      throw ("MGRSPoint bad conversion from: " + mgrsString);
	    }
	    sb += testChar;
	    i++;
	  }

	  var zoneNumber = parseInt(sb, 10);

	  if (i === 0 || i + 3 > length) {
	    // A good MGRS string has to be 4-5 digits long,
	    // ##AAA/#AAA at least.
	    throw ("MGRSPoint bad conversion from: " + mgrsString);
	  }

	  var zoneLetter = mgrsString.charAt(i++);

	  // Should we check the zone letter here? Why not.
	  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
	    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
	  }

	  hunK = mgrsString.substring(i, i += 2);

	  var set = get100kSetForZone(zoneNumber);

	  var east100k = getEastingFromChar(hunK.charAt(0), set);
	  var north100k = getNorthingFromChar(hunK.charAt(1), set);

	  // We have a bug where the northing may be 2000000 too low.
	  // How
	  // do we know when to roll over?

	  while (north100k < getMinNorthing(zoneLetter)) {
	    north100k += 2000000;
	  }

	  // calculate the char index for easting/northing separator
	  var remainder = length - i;

	  if (remainder % 2 !== 0) {
	    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
	  }

	  var sep = remainder / 2;

	  var sepEasting = 0.0;
	  var sepNorthing = 0.0;
	  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
	  if (sep > 0) {
	    accuracyBonus = 100000.0 / Math.pow(10, sep);
	    sepEastingString = mgrsString.substring(i, i + sep);
	    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
	    sepNorthingString = mgrsString.substring(i + sep);
	    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
	  }

	  easting = sepEasting + east100k;
	  northing = sepNorthing + north100k;

	  return {
	    easting: easting,
	    northing: northing,
	    zoneLetter: zoneLetter,
	    zoneNumber: zoneNumber,
	    accuracy: accuracyBonus
	  };
	}

	/**
	 * Given the first letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the easting value that
	 * should be added to the other, secondary easting value.
	 *
	 * @private
	 * @param {char} e The first letter from a two-letter MGRS 100k zone.
	 * @param {number} set The MGRS table set for the zone number.
	 * @return {number} The easting value for the given letter and set.
	 */
	function getEastingFromChar(e, set) {
	  // colOrigin is the letter at the origin of the set for the
	  // column
	  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
	  var eastingValue = 100000.0;
	  var rewindMarker = false;

	  while (curCol !== e.charCodeAt(0)) {
	    curCol++;
	    if (curCol === I) {
	      curCol++;
	    }
	    if (curCol === O) {
	      curCol++;
	    }
	    if (curCol > Z) {
	      if (rewindMarker) {
	        throw ("Bad character: " + e);
	      }
	      curCol = A;
	      rewindMarker = true;
	    }
	    eastingValue += 100000.0;
	  }

	  return eastingValue;
	}

	/**
	 * Given the second letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the northing value that
	 * should be added to the other, secondary northing value. You have to
	 * remember that Northings are determined from the equator, and the vertical
	 * cycle of letters mean a 2000000 additional northing meters. This happens
	 * approx. every 18 degrees of latitude. This method does *NOT* count any
	 * additional northings. You have to figure out how many 2000000 meters need
	 * to be added for the zone letter of the MGRS coordinate.
	 *
	 * @private
	 * @param {char} n Second letter of the MGRS 100k zone
	 * @param {number} set The MGRS table set number, which is dependent on the
	 *     UTM zone number.
	 * @return {number} The northing value for the given letter and set.
	 */
	function getNorthingFromChar(n, set) {

	  if (n > 'V') {
	    throw ("MGRSPoint given invalid Northing " + n);
	  }

	  // rowOrigin is the letter at the origin of the set for the
	  // column
	  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
	  var northingValue = 0.0;
	  var rewindMarker = false;

	  while (curRow !== n.charCodeAt(0)) {
	    curRow++;
	    if (curRow === I) {
	      curRow++;
	    }
	    if (curRow === O) {
	      curRow++;
	    }
	    // fixing a bug making whole application hang in this loop
	    // when 'n' is a wrong character
	    if (curRow > V) {
	      if (rewindMarker) { // making sure that this loop ends
	        throw ("Bad character: " + n);
	      }
	      curRow = A;
	      rewindMarker = true;
	    }
	    northingValue += 100000.0;
	  }

	  return northingValue;
	}

	/**
	 * The function getMinNorthing returns the minimum northing value of a MGRS
	 * zone.
	 *
	 * Ported from Geotrans' c Lattitude_Band_Value structure table.
	 *
	 * @private
	 * @param {char} zoneLetter The MGRS zone to get the min northing for.
	 * @return {number}
	 */
	function getMinNorthing(zoneLetter) {
	  var northing;
	  switch (zoneLetter) {
	  case 'C':
	    northing = 1100000.0;
	    break;
	  case 'D':
	    northing = 2000000.0;
	    break;
	  case 'E':
	    northing = 2800000.0;
	    break;
	  case 'F':
	    northing = 3700000.0;
	    break;
	  case 'G':
	    northing = 4600000.0;
	    break;
	  case 'H':
	    northing = 5500000.0;
	    break;
	  case 'J':
	    northing = 6400000.0;
	    break;
	  case 'K':
	    northing = 7300000.0;
	    break;
	  case 'L':
	    northing = 8200000.0;
	    break;
	  case 'M':
	    northing = 9100000.0;
	    break;
	  case 'N':
	    northing = 0.0;
	    break;
	  case 'P':
	    northing = 800000.0;
	    break;
	  case 'Q':
	    northing = 1700000.0;
	    break;
	  case 'R':
	    northing = 2600000.0;
	    break;
	  case 'S':
	    northing = 3500000.0;
	    break;
	  case 'T':
	    northing = 4400000.0;
	    break;
	  case 'U':
	    northing = 5300000.0;
	    break;
	  case 'V':
	    northing = 6200000.0;
	    break;
	  case 'W':
	    northing = 7000000.0;
	    break;
	  case 'X':
	    northing = 7900000.0;
	    break;
	  default:
	    northing = -1.0;
	  }
	  if (northing >= 0.0) {
	    return northing;
	  }
	  else {
	    throw ("Invalid zone letter: " + zoneLetter);
	  }

	}


/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "proj4@^2.3.14",
					"scope": null,
					"escapedName": "proj4",
					"name": "proj4",
					"rawSpec": "^2.3.14",
					"spec": ">=2.3.14 <3.0.0",
					"type": "range"
				},
				"/home/kotfic/src/jupyter/geojs"
			]
		],
		"_from": "proj4@>=2.3.14 <3.0.0",
		"_id": "proj4@2.3.14",
		"_inCache": true,
		"_installable": true,
		"_location": "/proj4",
		"_nodeVersion": "4.2.6",
		"_npmOperationalInternal": {
			"host": "packages-13-west.internal.npmjs.com",
			"tmp": "tmp/proj4-2.3.14.tgz_1457689264880_0.9409773757215589"
		},
		"_npmUser": {
			"name": "ahocevar",
			"email": "andreas.hocevar@gmail.com"
		},
		"_npmVersion": "2.14.12",
		"_phantomChildren": {},
		"_requested": {
			"raw": "proj4@^2.3.14",
			"scope": null,
			"escapedName": "proj4",
			"name": "proj4",
			"rawSpec": "^2.3.14",
			"spec": ">=2.3.14 <3.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"#DEV:/"
		],
		"_resolved": "https://registry.npmjs.org/proj4/-/proj4-2.3.14.tgz",
		"_shasum": "928906144388980c914c5a357fc493aba59a747a",
		"_shrinkwrap": null,
		"_spec": "proj4@^2.3.14",
		"_where": "/home/kotfic/src/jupyter/geojs",
		"author": "",
		"bugs": {
			"url": "https://github.com/proj4js/proj4js/issues"
		},
		"contributors": [
			{
				"name": "Mike Adair",
				"email": "madair@dmsolutions.ca"
			},
			{
				"name": "Richard Greenwood",
				"email": "rich@greenwoodmap.com"
			},
			{
				"name": "Calvin Metcalf",
				"email": "calvin.metcalf@gmail.com"
			},
			{
				"name": "Richard Marsden",
				"url": "http://www.winwaed.com"
			},
			{
				"name": "T. Mittan"
			},
			{
				"name": "D. Steinwand"
			},
			{
				"name": "S. Nelson"
			}
		],
		"dependencies": {
			"mgrs": "~0.0.2"
		},
		"description": "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
		"devDependencies": {
			"browserify": "~12.0.1",
			"chai": "~1.8.1",
			"curl": "git://github.com/cujojs/curl.git",
			"grunt": "~0.4.2",
			"grunt-browserify": "~4.0.1",
			"grunt-cli": "~0.1.13",
			"grunt-contrib-connect": "~0.6.0",
			"grunt-contrib-jshint": "~0.8.0",
			"grunt-contrib-uglify": "~0.11.1",
			"grunt-mocha-phantomjs": "~0.4.0",
			"istanbul": "~0.2.4",
			"mocha": "~1.17.1",
			"tin": "~0.4.0"
		},
		"directories": {
			"test": "test",
			"doc": "docs"
		},
		"dist": {
			"shasum": "928906144388980c914c5a357fc493aba59a747a",
			"tarball": "https://registry.npmjs.org/proj4/-/proj4-2.3.14.tgz"
		},
		"gitHead": "7619c8a63df1eae5bad0b9ad31ca1d87b0549243",
		"homepage": "https://github.com/proj4js/proj4js#readme",
		"jam": {
			"main": "dist/proj4.js",
			"include": [
				"dist/proj4.js",
				"README.md",
				"AUTHORS",
				"LICENSE.md"
			]
		},
		"license": "MIT",
		"main": "lib/index.js",
		"maintainers": [
			{
				"name": "cwmma",
				"email": "calvin.metcalf@gmail.com"
			},
			{
				"name": "ahocevar",
				"email": "andreas.hocevar@gmail.com"
			}
		],
		"name": "proj4",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git://github.com/proj4js/proj4js.git"
		},
		"scripts": {
			"test": "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"
		},
		"version": "2.3.14"
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var projs = [
	  __webpack_require__(38),
	  __webpack_require__(45),
	  __webpack_require__(46),
	  __webpack_require__(49),
	  __webpack_require__(50),
	  __webpack_require__(51),
	  __webpack_require__(52),
	  __webpack_require__(53),
	  __webpack_require__(54),
	  __webpack_require__(58),
	  __webpack_require__(60),
	  __webpack_require__(61),
	  __webpack_require__(62),
	  __webpack_require__(64),
	  __webpack_require__(65),
	  __webpack_require__(66),
	  __webpack_require__(67),
	  __webpack_require__(68),
	  __webpack_require__(72),
	  __webpack_require__(73),
	  __webpack_require__(74),
	  __webpack_require__(75)
	];
	module.exports = function(proj4){
	  projs.forEach(function(proj){
	    proj4.Proj.projections.add(proj);
	  });
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var e0fn = __webpack_require__(39);
	var e1fn = __webpack_require__(40);
	var e2fn = __webpack_require__(41);
	var e3fn = __webpack_require__(42);
	var mlfn = __webpack_require__(43);
	var adjust_lon = __webpack_require__(21);
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var sign = __webpack_require__(22);
	var asinz = __webpack_require__(44);

	exports.init = function() {
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);
	  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	};

	/**
	    Transverse Mercator Forward  - long/lat to x/y
	    long/lat in radians
	  */
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var con;
	  var x, y;
	  var sin_phi = Math.sin(lat);
	  var cos_phi = Math.cos(lat);

	  if (this.sphere) {
	    var b = cos_phi * Math.sin(delta_lon);
	    if ((Math.abs(Math.abs(b) - 1)) < 0.0000000001) {
	      return (93);
	    }
	    else {
	      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
	      con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
	      if (lat < 0) {
	        con = -con;
	      }
	      y = this.a * this.k0 * (con - this.lat0);
	    }
	  }
	  else {
	    var al = cos_phi * delta_lon;
	    var als = Math.pow(al, 2);
	    var c = this.ep2 * Math.pow(cos_phi, 2);
	    var tq = Math.tan(lat);
	    var t = Math.pow(tq, 2);
	    con = 1 - this.es * Math.pow(sin_phi, 2);
	    var n = this.a / Math.sqrt(con);
	    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);

	    x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
	    y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;

	  }
	  p.x = x;
	  p.y = y;
	  return p;
	};

	/**
	    Transverse Mercator Inverse  -  x/y to long/lat
	  */
	exports.inverse = function(p) {
	  var con, phi;
	  var delta_phi;
	  var i;
	  var max_iter = 6;
	  var lat, lon;

	  if (this.sphere) {
	    var f = Math.exp(p.x / (this.a * this.k0));
	    var g = 0.5 * (f - 1 / f);
	    var temp = this.lat0 + p.y / (this.a * this.k0);
	    var h = Math.cos(temp);
	    con = Math.sqrt((1 - h * h) / (1 + g * g));
	    lat = asinz(con);
	    if (temp < 0) {
	      lat = -lat;
	    }
	    if ((g === 0) && (h === 0)) {
	      lon = this.long0;
	    }
	    else {
	      lon = adjust_lon(Math.atan2(g, h) + this.long0);
	    }
	  }
	  else { // ellipsoidal form
	    var x = p.x - this.x0;
	    var y = p.y - this.y0;

	    con = (this.ml0 + y / this.k0) / this.a;
	    phi = con;
	    for (i = 0; true; i++) {
	      delta_phi = ((con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0) - phi;
	      phi += delta_phi;
	      if (Math.abs(delta_phi) <= EPSLN) {
	        break;
	      }
	      if (i >= max_iter) {
	        return (95);
	      }
	    } // for()
	    if (Math.abs(phi) < HALF_PI) {
	      var sin_phi = Math.sin(phi);
	      var cos_phi = Math.cos(phi);
	      var tan_phi = Math.tan(phi);
	      var c = this.ep2 * Math.pow(cos_phi, 2);
	      var cs = Math.pow(c, 2);
	      var t = Math.pow(tan_phi, 2);
	      var ts = Math.pow(t, 2);
	      con = 1 - this.es * Math.pow(sin_phi, 2);
	      var n = this.a / Math.sqrt(con);
	      var r = n * (1 - this.es) / con;
	      var d = x / (n * this.k0);
	      var ds = Math.pow(d, 2);
	      lat = phi - (n * tan_phi * ds / r) * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
	      lon = adjust_lon(this.long0 + (d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi));
	    }
	    else {
	      lat = HALF_PI * sign(y);
	      lon = this.long0;
	    }
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];


/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = function(x) {
	  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = function(x) {
	  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = function(x) {
	  return (0.05859375 * x * x * (1 + 0.75 * x));
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = function(x) {
	  return (x * x * x * (35 / 3072));
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = function(e0, e1, e2, e3, phi) {
	  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = function(x) {
	  if (Math.abs(x) > 1) {
	    x = (x > 1) ? 1 : -1;
	  }
	  return Math.asin(x);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var D2R = 0.01745329251994329577;
	var tmerc = __webpack_require__(38);
	exports.dependsOn = 'tmerc';
	exports.init = function() {
	  if (!this.zone) {
	    return;
	  }
	  this.lat0 = 0;
	  this.long0 = ((6 * Math.abs(this.zone)) - 183) * D2R;
	  this.x0 = 500000;
	  this.y0 = this.utmSouth ? 10000000 : 0;
	  this.k0 = 0.9996;

	  tmerc.init.apply(this);
	  this.forward = tmerc.forward;
	  this.inverse = tmerc.inverse;
	};
	exports.names = ["Universal Transverse Mercator System", "utm"];


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var gauss = __webpack_require__(47);
	var adjust_lon = __webpack_require__(21);
	exports.init = function() {
	  gauss.init.apply(this);
	  if (!this.rc) {
	    return;
	  }
	  this.sinc0 = Math.sin(this.phic0);
	  this.cosc0 = Math.cos(this.phic0);
	  this.R2 = 2 * this.rc;
	  if (!this.title) {
	    this.title = "Oblique Stereographic Alternative";
	  }
	};

	exports.forward = function(p) {
	  var sinc, cosc, cosl, k;
	  p.x = adjust_lon(p.x - this.long0);
	  gauss.forward.apply(this, [p]);
	  sinc = Math.sin(p.y);
	  cosc = Math.cos(p.y);
	  cosl = Math.cos(p.x);
	  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
	  p.x = k * cosc * Math.sin(p.x);
	  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
	  p.x = this.a * p.x + this.x0;
	  p.y = this.a * p.y + this.y0;
	  return p;
	};

	exports.inverse = function(p) {
	  var sinc, cosc, lon, lat, rho;
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;
	  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    var c = 2 * Math.atan2(rho, this.R2);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);
	    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
	    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  gauss.inverse.apply(this, [p]);
	  p.x = adjust_lon(p.x + this.long0);
	  return p;
	};

	exports.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var FORTPI = Math.PI/4;
	var srat = __webpack_require__(48);
	var HALF_PI = Math.PI/2;
	var MAX_ITER = 20;
	exports.init = function() {
	  var sphi = Math.sin(this.lat0);
	  var cphi = Math.cos(this.lat0);
	  cphi *= cphi;
	  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
	  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
	  this.phic0 = Math.asin(sphi / this.C);
	  this.ratexp = 0.5 * this.C * this.e;
	  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
	};

	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;

	  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
	  p.x = this.C * lon;
	  return p;
	};

	exports.inverse = function(p) {
	  var DEL_TOL = 1e-14;
	  var lon = p.x / this.C;
	  var lat = p.y;
	  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
	  for (var i = MAX_ITER; i > 0; --i) {
	    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
	    if (Math.abs(lat - p.y) < DEL_TOL) {
	      break;
	    }
	    p.y = lat;
	  }
	  /* convergence failed */
	  if (!i) {
	    return null;
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["gauss"];


/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = function(esinp, exp) {
	  return (Math.pow((1 - esinp) / (1 + esinp), exp));
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var sign = __webpack_require__(22);
	var msfnz = __webpack_require__(20);
	var tsfnz = __webpack_require__(23);
	var phi2z = __webpack_require__(24);
	var adjust_lon = __webpack_require__(21);
	exports.ssfn_ = function(phit, sinphi, eccen) {
	  sinphi *= eccen;
	  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
	};

	exports.init = function() {
	  this.coslat0 = Math.cos(this.lat0);
	  this.sinlat0 = Math.sin(this.lat0);
	  if (this.sphere) {
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
	    }
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (this.lat0 > 0) {
	        //North pole
	        //trace('stere:north pole');
	        this.con = 1;
	      }
	      else {
	        //South pole
	        //trace('stere:south pole');
	        this.con = -1;
	      }
	    }
	    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
	    }
	    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
	    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
	    this.cosX0 = Math.cos(this.X0);
	    this.sinX0 = Math.sin(this.X0);
	  }
	};

	// Stereographic forward equations--mapping lat,long to x,y
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinlat = Math.sin(lat);
	  var coslat = Math.cos(lat);
	  var A, X, sinX, cosX, ts, rh;
	  var dlon = adjust_lon(lon - this.long0);

	  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
	    //case of the origine point
	    //trace('stere:this is the origin point');
	    p.x = NaN;
	    p.y = NaN;
	    return p;
	  }
	  if (this.sphere) {
	    //trace('stere:sphere case');
	    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
	    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
	    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
	    return p;
	  }
	  else {
	    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
	    cosX = Math.cos(X);
	    sinX = Math.sin(X);
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
	      rh = 2 * this.a * this.k0 * ts / this.cons;
	      p.x = this.x0 + rh * Math.sin(lon - this.long0);
	      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
	      //trace(p.toString());
	      return p;
	    }
	    else if (Math.abs(this.sinlat0) < EPSLN) {
	      //Eq
	      //trace('stere:equateur');
	      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
	      p.y = A * sinX;
	    }
	    else {
	      //other case
	      //trace('stere:normal case');
	      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
	      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
	    }
	    p.x = A * cosX * Math.sin(dlon) + this.x0;
	  }
	  //trace(p.toString());
	  return p;
	};


	//* Stereographic inverse equations--mapping x,y to lat/long
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat, ts, ce, Chi;
	  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
	  if (this.sphere) {
	    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
	    lon = this.long0;
	    lat = this.lat0;
	    if (rh <= EPSLN) {
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
	    if (Math.abs(this.coslat0) < EPSLN) {
	      if (this.lat0 > 0) {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      }
	      else {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      }
	    }
	    else {
	      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
	    }
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (rh <= EPSLN) {
	        lat = this.lat0;
	        lon = this.long0;
	        p.x = lon;
	        p.y = lat;
	        //trace(p.toString());
	        return p;
	      }
	      p.x *= this.con;
	      p.y *= this.con;
	      ts = rh * this.cons / (2 * this.a * this.k0);
	      lat = this.con * phi2z(this.e, ts);
	      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
	    }
	    else {
	      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
	      lon = this.long0;
	      if (rh <= EPSLN) {
	        Chi = this.X0;
	      }
	      else {
	        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
	      }
	      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
	    }
	  }
	  p.x = lon;
	  p.y = lat;

	  //trace(p.toString());
	  return p;

	};
	exports.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];


/***/ },
/* 50 */
/***/ function(module, exports) {

	/*
	  references:
	    Formules et constantes pour le Calcul pour la
	    projection cylindrique conforme  axe oblique et pour la transformation entre
	    des systmes de rfrence.
	    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
	  */
	exports.init = function() {
	  var phy0 = this.lat0;
	  this.lambda0 = this.long0;
	  var sinPhy0 = Math.sin(phy0);
	  var semiMajorAxis = this.a;
	  var invF = this.rf;
	  var flattening = 1 / invF;
	  var e2 = 2 * flattening - Math.pow(flattening, 2);
	  var e = this.e = Math.sqrt(e2);
	  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
	  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
	  this.b0 = Math.asin(sinPhy0 / this.alpha);
	  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
	  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
	  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
	  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
	};


	exports.forward = function(p) {
	  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
	  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
	  var S = -this.alpha * (Sa1 + Sa2) + this.K;

	  // spheric latitude
	  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

	  // spheric longitude
	  var I = this.alpha * (p.x - this.lambda0);

	  // psoeudo equatorial rotation
	  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

	  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

	  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
	  p.x = this.R * rotI + this.x0;
	  return p;
	};

	exports.inverse = function(p) {
	  var Y = p.x - this.x0;
	  var X = p.y - this.y0;

	  var rotI = Y / this.R;
	  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

	  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
	  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

	  var lambda = this.lambda0 + I / this.alpha;

	  var S = 0;
	  var phy = b;
	  var prevPhy = -1000;
	  var iteration = 0;
	  while (Math.abs(phy - prevPhy) > 0.0000001) {
	    if (++iteration > 20) {
	      //...reportError("omercFwdInfinity");
	      return;
	    }
	    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
	    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
	    prevPhy = phy;
	    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
	  }

	  p.x = lambda;
	  p.y = phy;
	  return p;
	};

	exports.names = ["somerc"];


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var tsfnz = __webpack_require__(23);
	var adjust_lon = __webpack_require__(21);
	var phi2z = __webpack_require__(24);
	var HALF_PI = Math.PI/2;
	var FORTPI = Math.PI/4;
	var EPSLN = 1.0e-10;

	/* Initialize the Oblique Mercator  projection
	    ------------------------------------------*/
	exports.init = function() {
	  this.no_off = this.no_off || false;
	  this.no_rot = this.no_rot || false;

	  if (isNaN(this.k0)) {
	    this.k0 = 1;
	  }
	  var sinlat = Math.sin(this.lat0);
	  var coslat = Math.cos(this.lat0);
	  var con = this.e * sinlat;

	  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
	  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
	  var t0 = tsfnz(this.e, this.lat0, sinlat);
	  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
	  if (dl * dl < 1) {
	    dl = 1;
	  }
	  var fl;
	  var gl;
	  if (!isNaN(this.longc)) {
	    //Central point and azimuth method

	    if (this.lat0 >= 0) {
	      fl = dl + Math.sqrt(dl * dl - 1);
	    }
	    else {
	      fl = dl - Math.sqrt(dl * dl - 1);
	    }
	    this.el = fl * Math.pow(t0, this.bl);
	    gl = 0.5 * (fl - 1 / fl);
	    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
	    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

	  }
	  else {
	    //2 points method
	    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
	    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
	    if (this.lat0 >= 0) {
	      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	    }
	    else {
	      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	    }
	    var hl = Math.pow(t1, this.bl);
	    var ll = Math.pow(t2, this.bl);
	    fl = this.el / hl;
	    gl = 0.5 * (fl - 1 / fl);
	    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
	    var pl = (ll - hl) / (ll + hl);
	    var dlon12 = adjust_lon(this.long1 - this.long2);
	    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
	    this.long0 = adjust_lon(this.long0);
	    var dlon10 = adjust_lon(this.long1 - this.long0);
	    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
	    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
	  }

	  if (this.no_off) {
	    this.uc = 0;
	  }
	  else {
	    if (this.lat0 >= 0) {
	      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	    }
	    else {
	      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	    }
	  }

	};


	/* Oblique Mercator forward equations--mapping lat,long to x,y
	    ----------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var dlon = adjust_lon(lon - this.long0);
	  var us, vs;
	  var con;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    if (lat > 0) {
	      con = -1;
	    }
	    else {
	      con = 1;
	    }
	    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
	    us = -1 * con * HALF_PI * this.al / this.bl;
	  }
	  else {
	    var t = tsfnz(this.e, lat, Math.sin(lat));
	    var ql = this.el / Math.pow(t, this.bl);
	    var sl = 0.5 * (ql - 1 / ql);
	    var tl = 0.5 * (ql + 1 / ql);
	    var vl = Math.sin(this.bl * (dlon));
	    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
	    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
	      vs = Number.POSITIVE_INFINITY;
	    }
	    else {
	      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
	    }
	    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
	      us = this.al * this.bl * (dlon);
	    }
	    else {
	      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
	    }
	  }

	  if (this.no_rot) {
	    p.x = this.x0 + us;
	    p.y = this.y0 + vs;
	  }
	  else {

	    us -= this.uc;
	    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
	    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
	  }
	  return p;
	};

	exports.inverse = function(p) {
	  var us, vs;
	  if (this.no_rot) {
	    vs = p.y - this.y0;
	    us = p.x - this.x0;
	  }
	  else {
	    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
	    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
	    us += this.uc;
	  }
	  var qp = Math.exp(-1 * this.bl * vs / this.al);
	  var sp = 0.5 * (qp - 1 / qp);
	  var tp = 0.5 * (qp + 1 / qp);
	  var vp = Math.sin(this.bl * us / this.al);
	  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
	  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
	  if (Math.abs(up - 1) < EPSLN) {
	    p.x = this.long0;
	    p.y = HALF_PI;
	  }
	  else if (Math.abs(up + 1) < EPSLN) {
	    p.x = this.long0;
	    p.y = -1 * HALF_PI;
	  }
	  else {
	    p.y = phi2z(this.e, ts);
	    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
	  }
	  return p;
	};

	exports.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var EPSLN = 1.0e-10;
	var msfnz = __webpack_require__(20);
	var tsfnz = __webpack_require__(23);
	var HALF_PI = Math.PI/2;
	var sign = __webpack_require__(22);
	var adjust_lon = __webpack_require__(21);
	var phi2z = __webpack_require__(24);
	exports.init = function() {

	  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
	  //double c_lat;                   /* center latitude                      */
	  //double c_lon;                   /* center longitude                     */
	  //double lat1;                    /* first standard parallel              */
	  //double lat2;                    /* second standard parallel             */
	  //double r_maj;                   /* major axis                           */
	  //double r_min;                   /* minor axis                           */
	  //double false_east;              /* x offset in meters                   */
	  //double false_north;             /* y offset in meters                   */

	  if (!this.lat2) {
	    this.lat2 = this.lat1;
	  } //if lat2 is not defined
	  if (!this.k0) {
	    this.k0 = 1;
	  }
	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }

	  var temp = this.b / this.a;
	  this.e = Math.sqrt(1 - temp * temp);

	  var sin1 = Math.sin(this.lat1);
	  var cos1 = Math.cos(this.lat1);
	  var ms1 = msfnz(this.e, sin1, cos1);
	  var ts1 = tsfnz(this.e, this.lat1, sin1);

	  var sin2 = Math.sin(this.lat2);
	  var cos2 = Math.cos(this.lat2);
	  var ms2 = msfnz(this.e, sin2, cos2);
	  var ts2 = tsfnz(this.e, this.lat2, sin2);

	  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
	  }
	  else {
	    this.ns = sin1;
	  }
	  if (isNaN(this.ns)) {
	    this.ns = sin1;
	  }
	  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
	  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
	  if (!this.title) {
	    this.title = "Lambert Conformal Conic";
	  }
	};


	// Lambert Conformal conic forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  // singular cases :
	  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
	    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
	  }

	  var con = Math.abs(Math.abs(lat) - HALF_PI);
	  var ts, rh1;
	  if (con > EPSLN) {
	    ts = tsfnz(this.e, lat, Math.sin(lat));
	    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
	  }
	  else {
	    con = lat * this.ns;
	    if (con <= 0) {
	      return null;
	    }
	    rh1 = 0;
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
	  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

	  return p;
	};

	// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	exports.inverse = function(p) {

	  var rh1, con, ts;
	  var lat, lon;
	  var x = (p.x - this.x0) / this.k0;
	  var y = (this.rh - (p.y - this.y0) / this.k0);
	  if (this.ns > 0) {
	    rh1 = Math.sqrt(x * x + y * y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(x * x + y * y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2((con * x), (con * y));
	  }
	  if ((rh1 !== 0) || (this.ns > 0)) {
	    con = 1 / this.ns;
	    ts = Math.pow((rh1 / (this.a * this.f0)), con);
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  else {
	    lat = -HALF_PI;
	  }
	  lon = adjust_lon(theta / this.ns + this.long0);

	  p.x = lon;
	  p.y = lat;
	  return p;
	};

	exports.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	exports.init = function() {
	  this.a = 6377397.155;
	  this.es = 0.006674372230614;
	  this.e = Math.sqrt(this.es);
	  if (!this.lat0) {
	    this.lat0 = 0.863937979737193;
	  }
	  if (!this.long0) {
	    this.long0 = 0.7417649320975901 - 0.308341501185665;
	  }
	  /* if scale not set default to 0.9999 */
	  if (!this.k0) {
	    this.k0 = 0.9999;
	  }
	  this.s45 = 0.785398163397448; /* 45 */
	  this.s90 = 2 * this.s45;
	  this.fi0 = this.lat0;
	  this.e2 = this.es;
	  this.e = Math.sqrt(this.e2);
	  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
	  this.uq = 1.04216856380474;
	  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
	  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
	  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
	  this.k1 = this.k0;
	  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
	  this.s0 = 1.37008346281555;
	  this.n = Math.sin(this.s0);
	  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
	  this.ad = this.s90 - this.uq;
	};

	/* ellipsoid */
	/* calculate xy from lat/lon */
	/* Constants, identical to inverse transform function */
	exports.forward = function(p) {
	  var gfi, u, deltav, s, d, eps, ro;
	  var lon = p.x;
	  var lat = p.y;
	  var delta_lon = adjust_lon(lon - this.long0);
	  /* Transformation */
	  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
	  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
	  deltav = -delta_lon * this.alfa;
	  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
	  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
	  eps = this.n * d;
	  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
	  p.y = ro * Math.cos(eps) / 1;
	  p.x = ro * Math.sin(eps) / 1;

	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  return (p);
	};

	/* calculate lat/lon from xy */
	exports.inverse = function(p) {
	  var u, deltav, s, d, eps, ro, fi1;
	  var ok;

	  /* Transformation */
	  /* revert y, x*/
	  var tmp = p.x;
	  p.x = p.y;
	  p.y = tmp;
	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  ro = Math.sqrt(p.x * p.x + p.y * p.y);
	  eps = Math.atan2(p.y, p.x);
	  d = eps / Math.sin(this.s0);
	  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
	  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
	  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
	  p.x = this.long0 - deltav / this.alfa;
	  fi1 = u;
	  ok = 0;
	  var iter = 0;
	  do {
	    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
	    if (Math.abs(fi1 - p.y) < 0.0000000001) {
	      ok = 1;
	    }
	    fi1 = p.y;
	    iter += 1;
	  } while (ok === 0 && iter < 15);
	  if (iter >= 15) {
	    return null;
	  }

	  return (p);
	};
	exports.names = ["Krovak", "krovak"];


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var mlfn = __webpack_require__(43);
	var e0fn = __webpack_require__(39);
	var e1fn = __webpack_require__(40);
	var e2fn = __webpack_require__(41);
	var e3fn = __webpack_require__(42);
	var gN = __webpack_require__(55);
	var adjust_lon = __webpack_require__(21);
	var adjust_lat = __webpack_require__(56);
	var imlfn = __webpack_require__(57);
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	exports.init = function() {
	  if (!this.sphere) {
	    this.e0 = e0fn(this.es);
	    this.e1 = e1fn(this.es);
	    this.e2 = e2fn(this.es);
	    this.e3 = e3fn(this.es);
	    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  }
	};



	/* Cassini forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	exports.forward = function(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y;
	  var lam = p.x;
	  var phi = p.y;
	  lam = adjust_lon(lam - this.long0);

	  if (this.sphere) {
	    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
	    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
	  }
	  else {
	    //ellipsoid
	    var sinphi = Math.sin(phi);
	    var cosphi = Math.cos(phi);
	    var nl = gN(this.a, this.e, sinphi);
	    var tl = Math.tan(phi) * Math.tan(phi);
	    var al = lam * Math.cos(phi);
	    var asq = al * al;
	    var cl = this.es * cosphi * cosphi / (1 - this.es);
	    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

	    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
	    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


	  }

	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	};

	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var phi, lam;

	  if (this.sphere) {
	    var dd = y + this.lat0;
	    phi = Math.asin(Math.sin(dd) * Math.cos(x));
	    lam = Math.atan2(Math.tan(x), Math.cos(dd));
	  }
	  else {
	    /* ellipsoid */
	    var ml1 = this.ml0 / this.a + y;
	    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
	    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
	      p.x = this.long0;
	      p.y = HALF_PI;
	      if (y < 0) {
	        p.y *= -1;
	      }
	      return p;
	    }
	    var nl1 = gN(this.a, this.e, Math.sin(phi1));

	    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
	    var tl1 = Math.pow(Math.tan(phi1), 2);
	    var dl = x * this.a / nl1;
	    var dsq = dl * dl;
	    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
	    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

	  }

	  p.x = adjust_lon(lam + this.long0);
	  p.y = adjust_lat(phi);
	  return p;

	};
	exports.names = ["Cassini", "Cassini_Soldner", "cass"];

/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = function(a, e, sinphi) {
	  var temp = e * sinphi;
	  return a / Math.sqrt(1 - temp * temp);
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var HALF_PI = Math.PI/2;
	var sign = __webpack_require__(22);

	module.exports = function(x) {
	  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
	};

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = function(ml, e0, e1, e2, e3) {
	  var phi;
	  var dphi;

	  phi = ml / e0;
	  for (var i = 0; i < 15; i++) {
	    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
	  return NaN;
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var HALF_PI = Math.PI/2;
	var FORTPI = Math.PI/4;
	var EPSLN = 1.0e-10;
	var qsfnz = __webpack_require__(59);
	var adjust_lon = __webpack_require__(21);
	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */

	exports.S_POLE = 1;
	exports.N_POLE = 2;
	exports.EQUIT = 3;
	exports.OBLIQ = 4;


	/* Initialize the Lambert Azimuthal Equal Area projection
	  ------------------------------------------------------*/
	exports.init = function() {
	  var t = Math.abs(this.lat0);
	  if (Math.abs(t - HALF_PI) < EPSLN) {
	    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
	  }
	  else if (Math.abs(t) < EPSLN) {
	    this.mode = this.EQUIT;
	  }
	  else {
	    this.mode = this.OBLIQ;
	  }
	  if (this.es > 0) {
	    var sinphi;

	    this.qp = qsfnz(this.e, 1);
	    this.mmf = 0.5 / (1 - this.es);
	    this.apa = this.authset(this.es);
	    switch (this.mode) {
	    case this.N_POLE:
	      this.dd = 1;
	      break;
	    case this.S_POLE:
	      this.dd = 1;
	      break;
	    case this.EQUIT:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      this.dd = 1 / this.rq;
	      this.xmf = 1;
	      this.ymf = 0.5 * this.qp;
	      break;
	    case this.OBLIQ:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      sinphi = Math.sin(this.lat0);
	      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
	      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
	      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
	      this.ymf = (this.xmf = this.rq) / this.dd;
	      this.xmf *= this.dd;
	      break;
	    }
	  }
	  else {
	    if (this.mode === this.OBLIQ) {
	      this.sinph0 = Math.sin(this.lat0);
	      this.cosph0 = Math.cos(this.lat0);
	    }
	  }
	};

	/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	exports.forward = function(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
	  var lam = p.x;
	  var phi = p.y;

	  lam = adjust_lon(lam - this.long0);

	  if (this.sphere) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    coslam = Math.cos(lam);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	      if (y <= EPSLN) {
	        return null;
	      }
	      y = Math.sqrt(2 / y);
	      x = y * cosphi * Math.sin(lam);
	      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        coslam = -coslam;
	      }
	      if (Math.abs(phi + this.phi0) < EPSLN) {
	        return null;
	      }
	      y = FORTPI - phi * 0.5;
	      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
	      x = y * Math.sin(lam);
	      y *= coslam;
	    }
	  }
	  else {
	    sinb = 0;
	    cosb = 0;
	    b = 0;
	    coslam = Math.cos(lam);
	    sinlam = Math.sin(lam);
	    sinphi = Math.sin(phi);
	    q = qsfnz(this.e, sinphi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinb = q / this.qp;
	      cosb = Math.sqrt(1 - sinb * sinb);
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
	      break;
	    case this.EQUIT:
	      b = 1 + cosb * coslam;
	      break;
	    case this.N_POLE:
	      b = HALF_PI + phi;
	      q = this.qp - q;
	      break;
	    case this.S_POLE:
	      b = phi - HALF_PI;
	      q = this.qp + q;
	      break;
	    }
	    if (Math.abs(b) < EPSLN) {
	      return null;
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	    case this.EQUIT:
	      b = Math.sqrt(2 / b);
	      if (this.mode === this.OBLIQ) {
	        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
	      }
	      else {
	        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
	      }
	      x = this.xmf * b * cosb * sinlam;
	      break;
	    case this.N_POLE:
	    case this.S_POLE:
	      if (q >= 0) {
	        x = (b = Math.sqrt(q)) * sinlam;
	        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
	      }
	      else {
	        x = y = 0;
	      }
	      break;
	    }
	  }

	  p.x = this.a * x + this.x0;
	  p.y = this.a * y + this.y0;
	  return p;
	};

	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var lam, phi, cCe, sCe, q, rho, ab;

	  if (this.sphere) {
	    var cosz = 0,
	      rh, sinz = 0;

	    rh = Math.sqrt(x * x + y * y);
	    phi = rh * 0.5;
	    if (phi > 1) {
	      return null;
	    }
	    phi = 2 * Math.asin(phi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinz = Math.sin(phi);
	      cosz = Math.cos(phi);
	    }
	    switch (this.mode) {
	    case this.EQUIT:
	      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
	      x *= sinz;
	      y = cosz * rh;
	      break;
	    case this.OBLIQ:
	      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
	      x *= sinz * this.cosph0;
	      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
	      break;
	    case this.N_POLE:
	      y = -y;
	      phi = HALF_PI - phi;
	      break;
	    case this.S_POLE:
	      phi -= HALF_PI;
	      break;
	    }
	    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
	  }
	  else {
	    ab = 0;
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      x /= this.dd;
	      y *= this.dd;
	      rho = Math.sqrt(x * x + y * y);
	      if (rho < EPSLN) {
	        p.x = 0;
	        p.y = this.phi0;
	        return p;
	      }
	      sCe = 2 * Math.asin(0.5 * rho / this.rq);
	      cCe = Math.cos(sCe);
	      x *= (sCe = Math.sin(sCe));
	      if (this.mode === this.OBLIQ) {
	        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
	        q = this.qp * ab;
	        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
	      }
	      else {
	        ab = y * sCe / rho;
	        q = this.qp * ab;
	        y = rho * cCe;
	      }
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        y = -y;
	      }
	      q = (x * x + y * y);
	      if (!q) {
	        p.x = 0;
	        p.y = this.phi0;
	        return p;
	      }
	      ab = 1 - q / this.qp;
	      if (this.mode === this.S_POLE) {
	        ab = -ab;
	      }
	    }
	    lam = Math.atan2(x, y);
	    phi = this.authlat(Math.asin(ab), this.apa);
	  }


	  p.x = adjust_lon(this.long0 + lam);
	  p.y = phi;
	  return p;
	};

	/* determine latitude from authalic latitude */
	exports.P00 = 0.33333333333333333333;
	exports.P01 = 0.17222222222222222222;
	exports.P02 = 0.10257936507936507936;
	exports.P10 = 0.06388888888888888888;
	exports.P11 = 0.06640211640211640211;
	exports.P20 = 0.01641501294219154443;

	exports.authset = function(es) {
	  var t;
	  var APA = [];
	  APA[0] = es * this.P00;
	  t = es * es;
	  APA[0] += t * this.P01;
	  APA[1] = t * this.P10;
	  t *= es;
	  APA[0] += t * this.P02;
	  APA[1] += t * this.P11;
	  APA[2] = t * this.P20;
	  return APA;
	};

	exports.authlat = function(beta, APA) {
	  var t = beta + beta;
	  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
	};
	exports.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];


/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = function(eccent, sinphi) {
	  var con;
	  if (eccent > 1.0e-7) {
	    con = eccent * sinphi;
	    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
	  }
	  else {
	    return (2 * sinphi);
	  }
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var EPSLN = 1.0e-10;
	var msfnz = __webpack_require__(20);
	var qsfnz = __webpack_require__(59);
	var adjust_lon = __webpack_require__(21);
	var asinz = __webpack_require__(44);
	exports.init = function() {

	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e3 = Math.sqrt(this.es);

	  this.sin_po = Math.sin(this.lat1);
	  this.cos_po = Math.cos(this.lat1);
	  this.t1 = this.sin_po;
	  this.con = this.sin_po;
	  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat2);
	  this.cos_po = Math.cos(this.lat2);
	  this.t2 = this.sin_po;
	  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat0);
	  this.cos_po = Math.cos(this.lat0);
	  this.t3 = this.sin_po;
	  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
	  }
	  else {
	    this.ns0 = this.con;
	  }
	  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
	  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
	};

	/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
	  -------------------------------------------------------------------*/
	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  this.sin_phi = Math.sin(lat);
	  this.cos_phi = Math.cos(lat);

	  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
	  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
	  var theta = this.ns0 * adjust_lon(lon - this.long0);
	  var x = rh1 * Math.sin(theta) + this.x0;
	  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	};


	exports.inverse = function(p) {
	  var rh1, qs, con, theta, lon, lat;

	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  if (this.ns0 >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }
	  con = rh1 * this.ns0 / this.a;
	  if (this.sphere) {
	    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
	  }
	  else {
	    qs = (this.c - con * con) / this.ns0;
	    lat = this.phi1z(this.e3, qs);
	  }

	  lon = adjust_lon(theta / this.ns0 + this.long0);
	  p.x = lon;
	  p.y = lat;
	  return p;
	};

	/* Function to compute phi1, the latitude for the inverse of the
	   Albers Conical Equal-Area projection.
	-------------------------------------------*/
	exports.phi1z = function(eccent, qs) {
	  var sinphi, cosphi, con, com, dphi;
	  var phi = asinz(0.5 * qs);
	  if (eccent < EPSLN) {
	    return phi;
	  }

	  var eccnts = eccent * eccent;
	  for (var i = 1; i <= 25; i++) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    con = eccent * sinphi;
	    com = 1 - con * con;
	    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi = phi + dphi;
	    if (Math.abs(dphi) <= 1e-7) {
	      return phi;
	    }
	  }
	  return null;
	};
	exports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var EPSLN = 1.0e-10;
	var asinz = __webpack_require__(44);

	/*
	  reference:
	    Wolfram Mathworld "Gnomonic Projection"
	    http://mathworld.wolfram.com/GnomonicProjection.html
	    Accessed: 12th November 2009
	  */
	exports.init = function() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.sin_p14 = Math.sin(this.lat0);
	  this.cos_p14 = Math.cos(this.lat0);
	  // Approximation for projecting points to the horizon (infinity)
	  this.infinity_dist = 1000 * this.a;
	  this.rc = 1;
	};


	/* Gnomonic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	exports.forward = function(p) {
	  var sinphi, cosphi; /* sin and cos value        */
	  var dlon; /* delta longitude value      */
	  var coslon; /* cos of longitude        */
	  var ksp; /* scale factor          */
	  var g;
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  dlon = adjust_lon(lon - this.long0);

	  sinphi = Math.sin(lat);
	  cosphi = Math.cos(lat);

	  coslon = Math.cos(dlon);
	  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	  ksp = 1;
	  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
	    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
	  }
	  else {

	    // Point is in the opposing hemisphere and is unprojectable
	    // We still need to return a reasonable point, so we project 
	    // to infinity, on a bearing 
	    // equivalent to the northern hemisphere equivalent
	    // This is a reasonable approximation for short shapes and lines that 
	    // straddle the horizon.

	    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
	    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

	  }
	  p.x = x;
	  p.y = y;
	  return p;
	};


	exports.inverse = function(p) {
	  var rh; /* Rho */
	  var sinc, cosc;
	  var c;
	  var lon, lat;

	  /* Inverse equations
	      -----------------*/
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;

	  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    c = Math.atan2(rh, this.rc);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);

	    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
	    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
	    lon = adjust_lon(this.long0 + lon);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["gnom"];


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var qsfnz = __webpack_require__(59);
	var msfnz = __webpack_require__(20);
	var iqsfnz = __webpack_require__(63);
	/*
	  reference:  
	    "Cartographic Projection Procedures for the UNIX Environment-
	    A User's Manual" by Gerald I. Evenden,
	    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
	*/
	exports.init = function() {
	  //no-op
	  if (!this.sphere) {
	    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	  }
	};


	/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  if (this.sphere) {
	    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
	    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
	  }
	  else {
	    var qs = qsfnz(this.e, Math.sin(lat));
	    x = this.x0 + this.a * this.k0 * dlon;
	    y = this.y0 + this.a * qs * 0.5 / this.k0;
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
	    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
	  }
	  else {
	    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
	    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["cea"];


/***/ },
/* 63 */
/***/ function(module, exports) {

	var HALF_PI = Math.PI/2;

	module.exports = function(eccent, q) {
	  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
	  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
	    if (q < 0) {
	      return (-1 * HALF_PI);
	    }
	    else {
	      return HALF_PI;
	    }
	  }
	  //var phi = 0.5* q/(1-eccent*eccent);
	  var phi = Math.asin(0.5 * q);
	  var dphi;
	  var sin_phi;
	  var cos_phi;
	  var con;
	  for (var i = 0; i < 30; i++) {
	    sin_phi = Math.sin(phi);
	    cos_phi = Math.cos(phi);
	    con = eccent * sin_phi;
	    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
	  return NaN;
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var adjust_lat = __webpack_require__(56);
	exports.init = function() {

	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  this.lat0 = this.lat0 || 0;
	  this.long0 = this.long0 || 0;
	  this.lat_ts = this.lat_ts || 0;
	  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

	  this.rc = Math.cos(this.lat_ts);
	};


	// forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  var dlon = adjust_lon(lon - this.long0);
	  var dlat = adjust_lat(lat - this.lat0);
	  p.x = this.x0 + (this.a * dlon * this.rc);
	  p.y = this.y0 + (this.a * dlat);
	  return p;
	};

	// inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	exports.inverse = function(p) {

	  var x = p.x;
	  var y = p.y;

	  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
	  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
	  return p;
	};
	exports.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var e0fn = __webpack_require__(39);
	var e1fn = __webpack_require__(40);
	var e2fn = __webpack_require__(41);
	var e3fn = __webpack_require__(42);
	var adjust_lon = __webpack_require__(21);
	var adjust_lat = __webpack_require__(56);
	var mlfn = __webpack_require__(43);
	var EPSLN = 1.0e-10;
	var gN = __webpack_require__(55);
	var MAX_ITER = 20;
	exports.init = function() {
	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);
	  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
	};


	/* Polyconic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y, el;
	  var dlon = adjust_lon(lon - this.long0);
	  el = dlon * Math.sin(lat);
	  if (this.sphere) {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.a * this.lat0;
	    }
	    else {
	      x = this.a * Math.sin(el) / Math.tan(lat);
	      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
	    }
	  }
	  else {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.ml0;
	    }
	    else {
	      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
	      x = nl * Math.sin(el);
	      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
	    }

	  }
	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	};


	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  var lon, lat, x, y, i;
	  var al, bl;
	  var phi, dphi;
	  x = p.x - this.x0;
	  y = p.y - this.y0;

	  if (this.sphere) {
	    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
	      lon = adjust_lon(x / this.a + this.long0);
	      lat = 0;
	    }
	    else {
	      al = this.lat0 + y / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var tanphi;
	      for (i = MAX_ITER; i; --i) {
	        tanphi = Math.tan(phi);
	        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
	        phi += dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }
	      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
	    }
	  }
	  else {
	    if (Math.abs(y + this.ml0) <= EPSLN) {
	      lat = 0;
	      lon = adjust_lon(this.long0 + x / this.a);
	    }
	    else {

	      al = (this.ml0 + y) / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var cl, mln, mlnp, ma;
	      var con;
	      for (i = MAX_ITER; i; --i) {
	        con = this.e * Math.sin(phi);
	        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
	        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
	        ma = mln / this.a;
	        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
	        phi -= dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }

	      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
	      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
	      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
	    }
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Polyconic", "poly"];

/***/ },
/* 66 */
/***/ function(module, exports) {

	var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	/*
	  reference
	    Department of Land and Survey Technical Circular 1973/32
	      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
	    OSG Technical Report 4.1
	      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
	  */

	/**
	 * iterations: Number of iterations to refine inverse transform.
	 *     0 -> km accuracy
	 *     1 -> m accuracy -- suitable for most mapping applications
	 *     2 -> mm accuracy
	 */
	exports.iterations = 1;

	exports.init = function() {
	  this.A = [];
	  this.A[1] = 0.6399175073;
	  this.A[2] = -0.1358797613;
	  this.A[3] = 0.063294409;
	  this.A[4] = -0.02526853;
	  this.A[5] = 0.0117879;
	  this.A[6] = -0.0055161;
	  this.A[7] = 0.0026906;
	  this.A[8] = -0.001333;
	  this.A[9] = 0.00067;
	  this.A[10] = -0.00034;

	  this.B_re = [];
	  this.B_im = [];
	  this.B_re[1] = 0.7557853228;
	  this.B_im[1] = 0;
	  this.B_re[2] = 0.249204646;
	  this.B_im[2] = 0.003371507;
	  this.B_re[3] = -0.001541739;
	  this.B_im[3] = 0.041058560;
	  this.B_re[4] = -0.10162907;
	  this.B_im[4] = 0.01727609;
	  this.B_re[5] = -0.26623489;
	  this.B_im[5] = -0.36249218;
	  this.B_re[6] = -0.6870983;
	  this.B_im[6] = -1.1651967;

	  this.C_re = [];
	  this.C_im = [];
	  this.C_re[1] = 1.3231270439;
	  this.C_im[1] = 0;
	  this.C_re[2] = -0.577245789;
	  this.C_im[2] = -0.007809598;
	  this.C_re[3] = 0.508307513;
	  this.C_im[3] = -0.112208952;
	  this.C_re[4] = -0.15094762;
	  this.C_im[4] = 0.18200602;
	  this.C_re[5] = 1.01418179;
	  this.C_im[5] = 1.64497696;
	  this.C_re[6] = 1.9660549;
	  this.C_im[6] = 2.5127645;

	  this.D = [];
	  this.D[1] = 1.5627014243;
	  this.D[2] = 0.5185406398;
	  this.D[3] = -0.03333098;
	  this.D[4] = -0.1052906;
	  this.D[5] = -0.0368594;
	  this.D[6] = 0.007317;
	  this.D[7] = 0.01220;
	  this.D[8] = 0.00394;
	  this.D[9] = -0.0013;
	};

	/**
	    New Zealand Map Grid Forward  - long/lat to x/y
	    long/lat in radians
	  */
	exports.forward = function(p) {
	  var n;
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lat = lat - this.lat0;
	  var delta_lon = lon - this.long0;

	  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
	  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
	  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
	  var d_lambda = delta_lon;
	  var d_phi_n = 1; // d_phi^0

	  var d_psi = 0;
	  for (n = 1; n <= 10; n++) {
	    d_phi_n = d_phi_n * d_phi;
	    d_psi = d_psi + this.A[n] * d_phi_n;
	  }

	  // 2. Calculate theta
	  var th_re = d_psi;
	  var th_im = d_lambda;

	  // 3. Calculate z
	  var th_n_re = 1;
	  var th_n_im = 0; // theta^0
	  var th_n_re1;
	  var th_n_im1;

	  var z_re = 0;
	  var z_im = 0;
	  for (n = 1; n <= 6; n++) {
	    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	    th_n_re = th_n_re1;
	    th_n_im = th_n_im1;
	    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
	    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
	  }

	  // 4. Calculate easting and northing
	  p.x = (z_im * this.a) + this.x0;
	  p.y = (z_re * this.a) + this.y0;

	  return p;
	};


	/**
	    New Zealand Map Grid Inverse  -  x/y to long/lat
	  */
	exports.inverse = function(p) {
	  var n;
	  var x = p.x;
	  var y = p.y;

	  var delta_x = x - this.x0;
	  var delta_y = y - this.y0;

	  // 1. Calculate z
	  var z_re = delta_y / this.a;
	  var z_im = delta_x / this.a;

	  // 2a. Calculate theta - first approximation gives km accuracy
	  var z_n_re = 1;
	  var z_n_im = 0; // z^0
	  var z_n_re1;
	  var z_n_im1;

	  var th_re = 0;
	  var th_im = 0;
	  for (n = 1; n <= 6; n++) {
	    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
	    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
	    z_n_re = z_n_re1;
	    z_n_im = z_n_im1;
	    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
	    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
	  }

	  // 2b. Iterate to refine the accuracy of the calculation
	  //        0 iterations gives km accuracy
	  //        1 iteration gives m accuracy -- good enough for most mapping applications
	  //        2 iterations bives mm accuracy
	  for (var i = 0; i < this.iterations; i++) {
	    var th_n_re = th_re;
	    var th_n_im = th_im;
	    var th_n_re1;
	    var th_n_im1;

	    var num_re = z_re;
	    var num_im = z_im;
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    th_n_re = 1;
	    th_n_im = 0;
	    var den_re = this.B_re[1];
	    var den_im = this.B_im[1];
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    // Complex division
	    var den2 = den_re * den_re + den_im * den_im;
	    th_re = (num_re * den_re + num_im * den_im) / den2;
	    th_im = (num_im * den_re - num_re * den_im) / den2;
	  }

	  // 3. Calculate d_phi              ...                                    // and d_lambda
	  var d_psi = th_re;
	  var d_lambda = th_im;
	  var d_psi_n = 1; // d_psi^0

	  var d_phi = 0;
	  for (n = 1; n <= 9; n++) {
	    d_psi_n = d_psi_n * d_psi;
	    d_phi = d_phi + this.D[n] * d_psi_n;
	  }

	  // 4. Calculate latitude and longitude
	  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
	  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
	  var lon = this.long0 + d_lambda;

	  p.x = lon;
	  p.y = lat;

	  return p;
	};
	exports.names = ["New_Zealand_Map_Grid", "nzmg"];

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */


	/* Initialize the Miller Cylindrical projection
	  -------------------------------------------*/
	exports.init = function() {
	  //no-op
	};


	/* Miller Cylindrical forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x = this.x0 + this.a * dlon;
	  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Miller Cylindrical inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;

	  var lon = adjust_lon(this.long0 + p.x / this.a);
	  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Miller_Cylindrical", "mill"];


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var adjust_lat = __webpack_require__(56);
	var pj_enfn = __webpack_require__(69);
	var MAX_ITER = 20;
	var pj_mlfn = __webpack_require__(70);
	var pj_inv_mlfn = __webpack_require__(71);
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var asinz = __webpack_require__(44);
	exports.init = function() {
	  /* Place parameters in static storage for common use
	    -------------------------------------------------*/


	  if (!this.sphere) {
	    this.en = pj_enfn(this.es);
	  }
	  else {
	    this.n = 1;
	    this.m = 0;
	    this.es = 0;
	    this.C_y = Math.sqrt((this.m + 1) / this.n);
	    this.C_x = this.C_y / (this.m + 1);
	  }

	};

	/* Sinusoidal forward equations--mapping lat,long to x,y
	  -----------------------------------------------------*/
	exports.forward = function(p) {
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	    -----------------*/
	  lon = adjust_lon(lon - this.long0);

	  if (this.sphere) {
	    if (!this.m) {
	      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
	    }
	    else {
	      var k = this.n * Math.sin(lat);
	      for (var i = MAX_ITER; i; --i) {
	        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
	        lat -= V;
	        if (Math.abs(V) < EPSLN) {
	          break;
	        }
	      }
	    }
	    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
	    y = this.a * this.C_y * lat;

	  }
	  else {

	    var s = Math.sin(lat);
	    var c = Math.cos(lat);
	    y = this.a * pj_mlfn(lat, s, c, this.en);
	    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	};

	exports.inverse = function(p) {
	  var lat, temp, lon, s;

	  p.x -= this.x0;
	  lon = p.x / this.a;
	  p.y -= this.y0;
	  lat = p.y / this.a;

	  if (this.sphere) {
	    lat /= this.C_y;
	    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
	    if (this.m) {
	      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
	    }
	    else if (this.n !== 1) {
	      lat = asinz(Math.sin(lat) / this.n);
	    }
	    lon = adjust_lon(lon + this.long0);
	    lat = adjust_lat(lat);
	  }
	  else {
	    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
	    s = Math.abs(lat);
	    if (s < HALF_PI) {
	      s = Math.sin(lat);
	      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
	      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
	      lon = adjust_lon(temp);
	    }
	    else if ((s - EPSLN) < HALF_PI) {
	      lon = this.long0;
	    }
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Sinusoidal", "sinu"];

/***/ },
/* 69 */
/***/ function(module, exports) {

	var C00 = 1;
	var C02 = 0.25;
	var C04 = 0.046875;
	var C06 = 0.01953125;
	var C08 = 0.01068115234375;
	var C22 = 0.75;
	var C44 = 0.46875;
	var C46 = 0.01302083333333333333;
	var C48 = 0.00712076822916666666;
	var C66 = 0.36458333333333333333;
	var C68 = 0.00569661458333333333;
	var C88 = 0.3076171875;

	module.exports = function(es) {
	  var en = [];
	  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
	  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
	  var t = es * es;
	  en[2] = t * (C44 - es * (C46 + es * C48));
	  t *= es;
	  en[3] = t * (C66 - es * C68);
	  en[4] = t * es * C88;
	  return en;
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = function(phi, sphi, cphi, en) {
	  cphi *= sphi;
	  sphi *= sphi;
	  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var pj_mlfn = __webpack_require__(70);
	var EPSLN = 1.0e-10;
	var MAX_ITER = 20;
	module.exports = function(arg, es, en) {
	  var k = 1 / (1 - es);
	  var phi = arg;
	  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
	    var s = Math.sin(phi);
	    var t = 1 - es * s * s;
	    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
	    //phi -= t * (t * Math.sqrt(t)) * k;
	    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
	    phi -= t;
	    if (Math.abs(t) < EPSLN) {
	      return phi;
	    }
	  }
	  //..reportError("cass:pj_inv_mlfn: Convergence error");
	  return phi;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var EPSLN = 1.0e-10;
	exports.init = function() {};

	/* Mollweide forward equations--mapping lat,long to x,y
	    ----------------------------------------------------*/
	exports.forward = function(p) {

	  /* Forward equations
	      -----------------*/
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var theta = lat;
	  var con = Math.PI * Math.sin(lat);

	  /* Iterate using the Newton-Raphson method to find theta
	      -----------------------------------------------------*/
	  for (var i = 0; true; i++) {
	    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
	    theta += delta_theta;
	    if (Math.abs(delta_theta) < EPSLN) {
	      break;
	    }
	  }
	  theta /= 2;

	  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
	       this is done here because of precision problems with "cos(theta)"
	       --------------------------------------------------------------------------*/
	  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
	    delta_lon = 0;
	  }
	  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
	  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	};

	exports.inverse = function(p) {
	  var theta;
	  var arg;

	  /* Inverse equations
	      -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  arg = p.y / (1.4142135623731 * this.a);

	  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
	       a number very close to one is used instead.
	       -------------------------------------------------------------------*/
	  if (Math.abs(arg) > 0.999999999999) {
	    arg = 0.999999999999;
	  }
	  theta = Math.asin(arg);
	  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
	  if (lon < (-Math.PI)) {
	    lon = -Math.PI;
	  }
	  if (lon > Math.PI) {
	    lon = Math.PI;
	  }
	  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
	  if (Math.abs(arg) > 1) {
	    arg = 1;
	  }
	  var lat = Math.asin(arg);

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Mollweide", "moll"];


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var e0fn = __webpack_require__(39);
	var e1fn = __webpack_require__(40);
	var e2fn = __webpack_require__(41);
	var e3fn = __webpack_require__(42);
	var msfnz = __webpack_require__(20);
	var mlfn = __webpack_require__(43);
	var adjust_lon = __webpack_require__(21);
	var adjust_lat = __webpack_require__(56);
	var imlfn = __webpack_require__(57);
	var EPSLN = 1.0e-10;
	exports.init = function() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.lat2 = this.lat2 || this.lat1;
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);

	  this.sinphi = Math.sin(this.lat1);
	  this.cosphi = Math.cos(this.lat1);

	  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
	  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

	  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
	    this.ns = this.sinphi;
	  }
	  else {
	    this.sinphi = Math.sin(this.lat2);
	    this.cosphi = Math.cos(this.lat2);
	    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
	    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
	    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
	  }
	  this.g = this.ml1 + this.ms1 / this.ns;
	  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  this.rh = this.a * (this.g - this.ml0);
	};


	/* Equidistant Conic forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var rh1;

	  /* Forward equations
	      -----------------*/
	  if (this.sphere) {
	    rh1 = this.a * (this.g - lat);
	  }
	  else {
	    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
	    rh1 = this.a * (this.g - ml);
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  var x = this.x0 + rh1 * Math.sin(theta);
	  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  var con, rh1, lat, lon;
	  if (this.ns >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    lat = adjust_lat(this.g - rh1 / this.a);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    var ml = this.g - rh1 / this.a;
	    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }

	};
	exports.names = ["Equidistant_Conic", "eqdc"];


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var asinz = __webpack_require__(44);
	/* Initialize the Van Der Grinten projection
	  ----------------------------------------*/
	exports.init = function() {
	  //this.R = 6370997; //Radius of earth
	  this.R = this.a;
	};

	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  /* Forward equations
	    -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x, y;

	  if (Math.abs(lat) <= EPSLN) {
	    x = this.x0 + this.R * dlon;
	    y = this.y0;
	  }
	  var theta = asinz(2 * Math.abs(lat / Math.PI));
	  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
	    x = this.x0;
	    if (lat >= 0) {
	      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
	    }
	    else {
	      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
	    }
	    //  return(OK);
	  }
	  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
	  var asq = al * al;
	  var sinth = Math.sin(theta);
	  var costh = Math.cos(theta);

	  var g = costh / (sinth + costh - 1);
	  var gsq = g * g;
	  var m = g * (2 / sinth - 1);
	  var msq = m * m;
	  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
	  if (dlon < 0) {
	    con = -con;
	  }
	  x = this.x0 + con;
	  //con = Math.abs(con / (Math.PI * this.R));
	  var q = asq + g;
	  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
	  if (lat >= 0) {
	    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 + con;
	  }
	  else {
	    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 - con;
	  }
	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Van Der Grinten inverse equations--mapping x,y to lat/long
	  ---------------------------------------------------------*/
	exports.inverse = function(p) {
	  var lon, lat;
	  var xx, yy, xys, c1, c2, c3;
	  var a1;
	  var m1;
	  var con;
	  var th1;
	  var d;

	  /* inverse equations
	    -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  con = Math.PI * this.R;
	  xx = p.x / con;
	  yy = p.y / con;
	  xys = xx * xx + yy * yy;
	  c1 = -Math.abs(yy) * (1 + xys);
	  c2 = c1 - 2 * yy * yy + xx * xx;
	  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
	  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
	  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
	  m1 = 2 * Math.sqrt(-a1 / 3);
	  con = ((3 * d) / a1) / m1;
	  if (Math.abs(con) > 1) {
	    if (con >= 0) {
	      con = 1;
	    }
	    else {
	      con = -1;
	    }
	  }
	  th1 = Math.acos(con) / 3;
	  if (p.y >= 0) {
	    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }
	  else {
	    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }

	  if (Math.abs(xx) < EPSLN) {
	    lon = this.long0;
	  }
	  else {
	    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var adjust_lon = __webpack_require__(21);
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var mlfn = __webpack_require__(43);
	var e0fn = __webpack_require__(39);
	var e1fn = __webpack_require__(40);
	var e2fn = __webpack_require__(41);
	var e3fn = __webpack_require__(42);
	var gN = __webpack_require__(55);
	var asinz = __webpack_require__(44);
	var imlfn = __webpack_require__(57);
	exports.init = function() {
	  this.sin_p12 = Math.sin(this.lat0);
	  this.cos_p12 = Math.cos(this.lat0);
	};

	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinphi = Math.sin(p.y);
	  var cosphi = Math.cos(p.y);
	  var dlon = adjust_lon(lon - this.long0);
	  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
	  if (this.sphere) {
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
	      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
	      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //default case
	      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
	      c = Math.acos(cos_c);
	      kp = c / Math.sin(c);
	      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
	      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
	      return p;
	    }
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
	      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
	      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //Default case
	      tanphi = sinphi / cosphi;
	      Nl1 = gN(this.a, this.e, this.sin_p12);
	      Nl = gN(this.a, this.e, sinphi);
	      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
	      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
	      if (Az === 0) {
	        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
	        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else {
	        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
	      }
	      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
	      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
	      GH = G * H;
	      Hs = H * H;
	      s2 = s * s;
	      s3 = s2 * s;
	      s4 = s3 * s;
	      s5 = s4 * s;
	      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
	      p.x = this.x0 + c * Math.sin(Az);
	      p.y = this.y0 + c * Math.cos(Az);
	      return p;
	    }
	  }


	};

	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
	  if (this.sphere) {
	    rh = Math.sqrt(p.x * p.x + p.y * p.y);
	    if (rh > (2 * HALF_PI * this.a)) {
	      return;
	    }
	    z = rh / this.a;

	    sinz = Math.sin(z);
	    cosz = Math.cos(z);

	    lon = this.long0;
	    if (Math.abs(rh) <= EPSLN) {
	      lat = this.lat0;
	    }
	    else {
	      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
	      con = Math.abs(this.lat0) - HALF_PI;
	      if (Math.abs(con) <= EPSLN) {
	        if (this.lat0 >= 0) {
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	        }
	        else {
	          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	        }
	      }
	      else {
	        /*con = cosz - this.sin_p12 * Math.sin(lat);
	        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
	          //no-op, just keep the lon value as is
	        } else {
	          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
	          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
	        }*/
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
	      }
	    }

	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = Mlp - rh;
	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = rh - Mlp;

	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else {
	      //default case
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      Az = Math.atan2(p.x, p.y);
	      N1 = gN(this.a, this.e, this.sin_p12);
	      cosAz = Math.cos(Az);
	      tmp = this.e * this.cos_p12 * cosAz;
	      A = -tmp * tmp / (1 - this.es);
	      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
	      D = rh / N1;
	      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
	      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
	      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
	      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
	      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	  }

	};
	exports.names = ["Azimuthal_Equidistant", "aeqd"];


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var widgets = {
	  dom: {}
	};
	var layers = {};
	var layerDefaultFeatures = {};
	var renderers = {};
	var features = {};
	var featureCapabilities = {};
	var fileReaders = {};
	var rendererLayerAdjustments = {};
	var annotations = {};
	var util = {};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a new file reader type
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerFileReader = function (name, func) {
	  fileReaders[name] = func;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new file reader
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.createFileReader = function (name, opts) {
	  if (fileReaders.hasOwnProperty(name)) {
	    return fileReaders[name](opts);
	  }
	  return null;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a new renderer type
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerRenderer = function (name, func) {
	  renderers[name] = func;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of the renderer
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.createRenderer = function (name, layer, canvas, options) {
	  if (renderers.hasOwnProperty(name)) {
	    var ren = renderers[name](
	      {layer: layer, canvas: canvas, options: options}
	    );
	    ren._init();
	    return ren;
	  }
	  return null;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Check if the named renderer is supported.  If not, display a warning and get
	 * the name of a fallback renderer.  Ideally, we would pass a list of desired
	 * features, and, if the renderer is unavailable, this would choose a fallback
	 * that would support those features.
	 *
	 * @params {string|null} name name of the desired renderer
	 * @params {boolean} noFallback if true, don't recommend a fallback
	 * @return {string|null|false} the name of the renderer that should be used
	 *      or false if no valid renderer can be determined.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.checkRenderer = function (name, noFallback) {
	  if (name === null) {
	    return name;
	  }
	  if (renderers.hasOwnProperty(name)) {
	    var ren = renderers[name];
	    if (!ren.supported || ren.supported()) {
	      return name;
	    }
	    if (!ren.fallback || noFallback) {
	      return false;
	    }
	    var fallback = util.checkRenderer(ren.fallback(), true);
	    if (fallback !== false) {
	      console.warn(name + ' renderer is unavailable, using ' + fallback +
	                   ' renderer instead');
	    }
	    return fallback;
	  }
	  return false;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Check if there is a renderer that is supported and supports a list of
	 * features.  If not, display a warning.  This picks the first renderer that
	 * supports all of the listed features.
	 *
	 * @param {array|undefined} featureList A list of features that will be used
	 *      with this renderer.  Features are the basic feature names (e.g.,
	 *      'quad'), or the feature name followed by a required capability (e.g.,
	 *      'quad.image').  If more than one feature or more than one capability of
	 *      a feature is required, include each feature and capability combination
	 *      in the list (e.g., ['quad.image', 'plane']).  If no capability is
	 *      specified for a feature (or that feature was registered without a
	 *      capability object), then the feature will match regardless of
	 *      capabilities.
	 * @return {string|null|false} the name of the renderer that should be used
	 *      or false if no valid renderer can be determined.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.rendererForFeatures = function (featureList) {
	  var preferredRenderers = ['vgl', 'canvas', 'd3', null];

	  var renderer, ridx, feature, fidx, capability, available;
	  for (ridx = 0; ridx < preferredRenderers.length; ridx += 1) {
	    renderer = preferredRenderers[ridx];
	    if (util.checkRenderer(renderer, true) === false) {
	      continue;
	    }
	    if (!featureList) {
	      return renderer;
	    }
	    if (!features[renderer]) {
	      continue;
	    }
	    available = true;
	    for (fidx = 0; fidx < featureList.length; fidx += 1) {
	      feature = featureList[fidx];
	      capability = null;
	      if (feature.indexOf('.') >= 0) {
	        capability = feature;
	        feature = feature.substr(0, feature.indexOf('.'));
	      }
	      if (features[renderer][feature] === undefined) {
	        available = false;
	        break;
	      }
	      if (capability && featureCapabilities[renderer][feature] &&
	          !featureCapabilities[renderer][feature][capability]) {
	        available = false;
	        break;
	      }
	    }
	    if (available) {
	      return renderer;
	    }
	  }
	  console.warn('There is no renderer available for the feature list "' +
	               (featureList || []).join(', ') + '".');
	  return false;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a new feature type
	 *
	 * @param {string} category The feature category -- this is the renderer name.
	 * @param {string} name The feature name
	 * @param {function} func A function to call to create the feature.
	 * @param {object|undefined} capabilities A map of capabilities that this
	 *      feature supports.  If the feature is implemented with different
	 *      capabilities in multiple categories (renderers), then the feature
	 *      should expose a simple dictionary of supported and unsupported
	 *      features.  For instance, the quad feature has color quads, image quads,
	 *      and image quads that support full transformations.  The capabailities
	 *      should be defined in the base feature in a capabilities object so that
	 *      they can be referenced by that rather than an explicit string.
	 * @returns {object} if this feature replaces an existing one, this was the
	 *      feature that was replaced.  In this case, a warning is issued.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerFeature = function (category, name, func, capabilities) {
	  if (!(category in features)) {
	    features[category] = {};
	    featureCapabilities[category] = {};
	  }

	  var old = features[category][name];
	  if (old) {
	    console.warn('The ' + category + '.' + name + ' feature is already registered');
	  }
	  features[category][name] = func;
	  featureCapabilities[category][name] = capabilities;
	  return old;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of a feature
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.createFeature = function (name, layer, renderer, arg) {
	  var category = renderer.api(),
	      options = {'layer': layer, 'renderer': renderer};
	  if (category in features && name in features[category]) {
	    if (arg !== undefined) {
	      $.extend(true, options, arg);
	    }
	    var feature = features[category][name](options);
	    if (layer.gcs === undefined) {
	      layer.gcs = function () {
	        return layer.map().gcs();
	      };
	    }
	    return feature;
	  }
	  return null;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a layer adjustment.
	 *
	 * @returns {object} if this layer adjustment replaces an existing one, this
	 *      was the value that was replaced.  In this case, a warning is issued.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerLayerAdjustment = function (category, name, func) {
	  if (!(category in rendererLayerAdjustments)) {
	    rendererLayerAdjustments[category] = {};
	  }

	  var old = rendererLayerAdjustments[category][name];
	  if (old) {
	    console.warn('The ' + category + '.' + name + ' layer adjustment is already registered');
	  }
	  rendererLayerAdjustments[category][name] = func;
	  return old;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * If a layer needs to be adjusted based on the renderer, call the function
	 * that adjusts it.
	 *
	 * @param {string} name Name of the layer.
	 * @param {object} layer Instantiated layer object.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.adjustLayerForRenderer = function (name, layer) {
	  var rendererName = layer.rendererName();
	  if (rendererName) {
	    if (rendererLayerAdjustments &&
	        rendererLayerAdjustments[rendererName] &&
	        rendererLayerAdjustments[rendererName][name]) {
	      rendererLayerAdjustments[rendererName][name].apply(layer);
	    }
	  }
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a new layer type
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerLayer = function (name, func, defaultFeatures) {
	  layers[name] = func;
	  layerDefaultFeatures[name] = defaultFeatures;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of the layer
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.createLayer = function (name, map, arg) {
	  /// Default renderer is vgl
	  var options = {map: map},
	      layer = null;

	  if (name in layers) {
	    if (!arg.renderer && !arg.features && layerDefaultFeatures) {
	      options.features = layerDefaultFeatures[name];
	    }
	    if (arg !== undefined) {
	      $.extend(true, options, arg);
	    }
	    layer = layers[name](options);
	    layer._init();
	    return layer;
	  } else {
	    return null;
	  }
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a new widget type
	 *
	 * @returns {object} if this widget replaces an existing one, this was the
	 *      value that was replaced.  In this case, a warning is issued.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerWidget = function (category, name, func) {
	  if (!(category in widgets)) {
	    widgets[category] = {};
	  }

	  var old = widgets[category][name];
	  if (old) {
	    console.warn('The ' + category + '.' + name + ' widget is already registered');
	  }
	  widgets[category][name] = func;
	  return old;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of the widget
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.createWidget = function (name, layer, arg) {
	  var options = {
	    layer: layer
	  };

	  if (name in widgets.dom) {
	    if (arg !== undefined) {
	      $.extend(true, options, arg);
	    }

	    return widgets.dom[name](options);
	  }

	  throw new Error('Cannot create unknown widget ' + name);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Register a new annotation type
	 *
	 * @param {string} name The annotation name
	 * @param {function} func A function to call to create the annotation.
	 * @param {object|undefined} features A map of features that are used by this
	 *      annotation.  Each key is a feature that is used.  If the value is true,
	 *      the that feature is always needed.  If a list, then it is the set of
	 *      annotation states for which that feature is required.  These can be
	 *      used to pick an pparopriate renderer when creating an annotation layer.
	 * @returns {object} if this annotation replaces an existing one, this was the
	 *      value that was replaced.  In this case, a warning is issued.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.registerAnnotation = function (name, func, features) {
	  var old = annotations[name];
	  if (old) {
	    console.warn('The ' + name + ' annotation is already registered');
	  }
	  annotations[name] = {func: func, features: features || {}};
	  return old;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Get a list of registered annotation types.
	 *
	 * @return {array} a list of registered annotations.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.listAnnotations = function () {
	  return Object.keys(annotations);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Get a list of required features for a set of annotations.
	 *
	 * @param {array|object|undefined} annotationList A list of annotations that
	 *   will be used.  Instead of a list, if this is an object, the keys are the
	 *   annotation names, and the values are each a list of modes that will be
	 *   used with that annotation.  For example, ['polygon', 'rectangle'] lists
	 *   features required to show those annotations in any mode,  whereas
	 *   {polygon: [annotationState.done], rectangle: [annotationState.done]} only
	 *   lists features thatre are needed to show the completed annotations.
	 * @return {array} a list of features needed for the specified annotations.
	 *   There may be duplicates in the list.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.featuresForAnnotations = function (annotationList) {
	  var features = [];

	  var annList = Array.isArray(annotationList) ? annotationList : Object.keys(annotationList);
	  annList.forEach(function (ann) {
	    if (!annotations[ann]) {
	      return;
	    }
	    Object.keys(annotations[ann].features).forEach(function (feature) {
	      if (Array.isArray(annotationList) || annotationList[ann] === true ||
	          !Array.isArray(annotations[ann].features[feature])) {
	        features.push(feature);
	      } else {
	        annotationList[ann].forEach(function (state) {
	          if ($.inArray(state, annotations[ann].features[feature]) >= 0) {
	            features.push(feature);
	          }
	        });
	      }
	    });
	  });
	  return features;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Check if there is a renderer that is supported and supports a list of
	 * annotations.  If not, display a warning.  This generates a list of required
	 * features, then picks the first renderer that supports all of thse features.
	 *
	 * @param {array|object|undefined} annotationList A list of annotations that
	 *   will be used with this renderer.  Instead of a list, if this is an object,
	 *   the keys are the annotation names, and the values are each a list of modes
	 *   that will be used with that annotation.  See featuresForAnnotations for
	 *   more details.
	 * @return {string|null|false} the name of the renderer that should be used or
	 *   false if no valid renderer can be determined.
	 */
	//////////////////////////////////////////////////////////////////////////////
	util.rendererForAnnotations = function (annotationList) {
	  return util.rendererForFeatures(util.featuresForAnnotations(annotationList));
	};

	module.exports = util;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class lineFeature
	 *
	 * @class geo.lineFeature
	 * @extends geo.feature
	 * @returns {geo.lineFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var lineFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof lineFeature)) {
	    return new lineFeature(arg);
	  }

	  var $ = __webpack_require__(1);

	  arg = arg || {};
	  feature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set line accessor
	   *
	   * @returns {geo.pointFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.line = function (val) {
	    if (val === undefined) {
	      return m_this.style('line');
	    } else {
	      m_this.style('line', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set position accessor
	   *
	   * @returns {geo.pointFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_this.style('position');
	    } else {
	      m_this.style('position', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns an array of datum indices that contain the given point.
	   * This is a slow implementation with runtime order of the number of
	   * vertices.  A point is considered on a line segment if it is close to the
	   * line or either end point.  Closeness is based on the maximum width of the
	   * line segement, and is ceil(maxwidth / 2) + 2 pixels.  This means that
	   * corner extensions due to mitering may be outside of the selection area and
	   * that variable width lines will have a greater selection region than their
	   * visual size at the narrow end.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pointSearch = function (p) {
	    var data, pt, line, width, indices = [], found = [], pos;
	    data = m_this.data();
	    if (!data || !data.length) {
	      return {
	        found: [],
	        index: []
	      };
	    }

	    line = m_this.line();
	    width = m_this.style.get('strokeWidth');
	    pos = m_this.position();
	    pt = m_this.featureGcsToDisplay(p);

	    // minimum l2 distance squared from
	    // q -> line(u, v)
	    function lineDist2(q, u, v) {
	      var t, l2 = dist2(u, v);

	      if (l2 < 1) {
	        // u, v are within 1 pixel
	        return dist2(q, u);
	      }

	      t = ((q.x - u.x) * (v.x - u.x) + (q.y - u.y) * (v.y - u.y)) / l2;
	      if (t < 0) { return dist2(q, u); }
	      if (t > 1) { return dist2(q, v); }
	      return dist2(
	        q,
	        {
	          x: u.x + t * (v.x - u.x),
	          y: u.y + t * (v.y - u.y)
	        }
	      );
	    }

	    // l2 distance squared from u to v
	    function dist2(u, v) {
	      var dx = u.x - v.x,
	          dy = u.y - v.y;
	      return dx * dx + dy * dy;
	    }

	    // for each line
	    data.forEach(function (d, index) {
	      var closed = m_this.style.get('closed')(d, index),
	          last, lastr, first;

	      try {
	        line(d, index).forEach(function (current, j) {

	          // get the screen coordinates of the current point
	          var p = pos(current, j, d, index);
	          var s = m_this.featureGcsToDisplay(p);
	          var r = Math.ceil(width(p, j, d, index) / 2) + 2;

	          if (last) {
	            var r2 = lastr > r ? lastr * lastr : r * r;
	            // test the line segment s -> last
	            if (lineDist2(pt, s, last) <= r2) {
	              // short circuit the loop here
	              throw 'found';
	            }
	          }

	          last = s;
	          lastr = r;
	          if (!first && closed) {
	            first = {s: s, r: r};
	          }
	        });
	        if (closed && lineDist2(pt, last, first.s) <= first.r) {
	          throw 'found';
	        }
	      } catch (err) {
	        if (err !== 'found') {
	          throw err;
	        }
	        found.push(d);
	        indices.push(index);
	      }
	    });

	    return {
	      found: found,
	      index: indices
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns an array of line indices that are contained in the given box.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.boxSearch = function (lowerLeft, upperRight, opts) {
	    var pos = m_this.position(),
	        idx = [],
	        line = m_this.line();

	    opts = opts || {};
	    opts.partial = opts.partial || false;
	    if (opts.partial) {
	      throw new Error('Unimplemented query method.');
	    }

	    m_this.data().forEach(function (d, i) {
	      var inside = true;
	      line(d, i).forEach(function (e, j) {
	        if (!inside) { return; }
	        var p = pos(e, j, d, i);
	        if (!(p.x >= lowerLeft.x &&
	              p.x <= upperRight.x &&
	              p.y >= lowerLeft.y &&
	              p.y <= upperRight.y)
	        ) {
	          inside = false;
	        }
	      });
	      if (inside) {
	        idx.push(i);
	      }
	    });
	    return idx;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    arg = arg || {};
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(
	      {},
	      {
	        strokeWidth: 1.0,
	        // Default to gold color for lines
	        strokeColor: { r: 1.0, g: 0.8431372549, b: 0.0 },
	        strokeStyle: 'solid',
	        strokeOpacity: 1.0,
	        closed: false,
	        line: function (d) { return d; },
	        position: function (d) { return d; }
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    if (arg.line !== undefined) {
	      defaultStyle.line = arg.line;
	    }

	    if (arg.position !== undefined) {
	      defaultStyle.position = arg.position;
	    }

	    m_this.style(defaultStyle);

	    m_this.dataTime().modified();
	  };

	  this._init(arg);
	  return this;
	};

	/**
	 * Create a lineFeature from an object.
	 * @see {@link geo.feature.create}
	 * @param {geo.layer} layer The layer to add the feature to
	 * @param {geo.lineFeature.spec} spec The object specification
	 * @returns {geo.lineFeature|null}
	 */
	lineFeature.create = function (layer, spec) {
	  'use strict';

	  spec = spec || {};
	  spec.type = 'line';
	  return feature.create(layer, spec);
	};

	lineFeature.capabilities = {
	  /* core feature name -- support in any manner */
	  feature: 'line',
	  /* support for solid-colored, constant-width lines */
	  basic: 'line.basic',
	  /* support for lines that vary in width and color */
	  multicolor: 'line.multicolor'
	};

	inherit(lineFeature, feature);
	module.exports = lineFeature;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var inherit = __webpack_require__(4);
	var sceneObject = __webpack_require__(79);
	var timestamp = __webpack_require__(195);
	var geo_event = __webpack_require__(5);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class feature
	 *
	 * @class geo.feature
	 * @extends geo.sceneObject
	 * @returns {geo.feature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var feature = function (arg) {
	  'use strict';
	  if (!(this instanceof feature)) {
	    return new feature(arg);
	  }
	  sceneObject.call(this);

	  var util = __webpack_require__(196);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  arg = arg || {};

	  var m_this = this,
	      s_exit = this._exit,
	      m_selectionAPI = arg.selectionAPI === undefined ? false : arg.selectionAPI,
	      m_style = {},
	      m_layer = arg.layer === undefined ? null : arg.layer,
	      m_gcs = arg.gcs,
	      m_visible = arg.visible === undefined ? true : arg.visible,
	      m_bin = arg.bin === undefined ? 0 : arg.bin,
	      m_renderer = arg.renderer === undefined ? null : arg.renderer,
	      m_dataTime = timestamp(),
	      m_buildTime = timestamp(),
	      m_updateTime = timestamp(),
	      m_selectedFeatures = [];

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private method to bind mouse handlers on the map element.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._bindMouseHandlers = function () {

	    // Don't bind handlers for improved performance on features that don't
	    // require it.
	    if (!m_selectionAPI) {
	      return;
	    }

	    // First unbind to be sure that the handlers aren't bound twice.
	    m_this._unbindMouseHandlers();

	    m_this.geoOn(geo_event.mousemove, m_this._handleMousemove);
	    m_this.geoOn(geo_event.mouseclick, m_this._handleMouseclick);
	    m_this.geoOn(geo_event.brushend, m_this._handleBrushend);
	    m_this.geoOn(geo_event.brush, m_this._handleBrush);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private method to unbind mouse handlers on the map element.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._unbindMouseHandlers = function () {
	    m_this.geoOff(geo_event.mousemove, m_this._handleMousemove);
	    m_this.geoOff(geo_event.mouseclick, m_this._handleMouseclick);
	    m_this.geoOff(geo_event.brushend, m_this._handleBrushend);
	    m_this.geoOff(geo_event.brush, m_this._handleBrush);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * For binding mouse events, use functions with
	   * the following call signatures:
	   *
	   * function handler(arg) {
	   *   // arg.data - the data object of the feature
	   *   // arg.index - the index inside the data array of the featue
	   *   // arg.mouse - mouse information object (see src/core/mapInteractor.js)
	   * }
	   *
	   * i.e.
	   *
	   * feature.geoOn(geo.event.feature.mousemove, function (arg) {
	   *   // do something with the feature marker.
	   * });
	   */
	  ////////////////////////////////////////////////////////////////////////////

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Search for features containing the given point.
	   *
	   * Returns an object: ::
	   *
	   *   {
	   *     data: [...] // an array of data objects for matching features
	   *     index: [...] // an array of indices of the matching features
	   *   }
	   *
	   * @argument {Object} coordinate
	   * @returns {Object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pointSearch = function () {
	    // base class method does nothing
	    return {
	      index: [],
	      found: []
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private mousemove handler
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMousemove = function () {
	    var mouse = m_this.layer().map().interactor().mouse(),
	        data = m_this.data(),
	        over = m_this.pointSearch(mouse.geo),
	        newFeatures = [], oldFeatures = [], lastTop = -1, top = -1;

	    // Get the index of the element that was previously on top
	    if (m_selectedFeatures.length) {
	      lastTop = m_selectedFeatures[m_selectedFeatures.length - 1];
	    }

	    // There are probably faster ways of doing this:
	    newFeatures = over.index.filter(function (i) {
	      return m_selectedFeatures.indexOf(i) < 0;
	    });
	    oldFeatures = m_selectedFeatures.filter(function (i) {
	      return over.index.indexOf(i) < 0;
	    });

	    feature.eventID += 1;
	    // Fire events for mouse in first.
	    newFeatures.forEach(function (i, idx) {
	      m_this.geoTrigger(geo_event.feature.mouseover, {
	        data: data[i],
	        index: i,
	        mouse: mouse,
	        eventID: feature.eventID,
	        top: idx === newFeatures.length - 1
	      }, true);
	    });

	    feature.eventID += 1;
	    // Fire events for mouse out next
	    oldFeatures.forEach(function (i, idx) {
	      m_this.geoTrigger(geo_event.feature.mouseout, {
	        data: data[i],
	        index: i,
	        mouse: mouse,
	        eventID: feature.eventID,
	        top: idx === oldFeatures.length - 1
	      }, true);
	    });

	    feature.eventID += 1;
	    // Fire events for mouse move last
	    over.index.forEach(function (i, idx) {
	      m_this.geoTrigger(geo_event.feature.mousemove, {
	        data: data[i],
	        index: i,
	        mouse: mouse,
	        eventID: feature.eventID,
	        top: idx === over.index.length - 1
	      }, true);
	    });

	    // Replace the selected features array
	    m_selectedFeatures = over.index;

	    // Get the index of the element that is now on top
	    if (m_selectedFeatures.length) {
	      top = m_selectedFeatures[m_selectedFeatures.length - 1];
	    }

	    if (lastTop !== top) {
	      // The element on top changed so we need to fire mouseon/mouseoff
	      if (lastTop !== -1) {
	        m_this.geoTrigger(geo_event.feature.mouseoff, {
	          data: data[lastTop],
	          index: lastTop,
	          mouse: mouse
	        }, true);
	      }

	      if (top !== -1) {
	        m_this.geoTrigger(geo_event.feature.mouseon, {
	          data: data[top],
	          index: top,
	          mouse: mouse
	        }, true);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private mouseclick handler
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseclick = function () {
	    var mouse = m_this.layer().map().interactor().mouse(),
	        data = m_this.data(),
	        over = m_this.pointSearch(mouse.geo);

	    feature.eventID += 1;
	    over.index.forEach(function (i, idx) {
	      m_this.geoTrigger(geo_event.feature.mouseclick, {
	        data: data[i],
	        index: i,
	        mouse: mouse,
	        eventID: feature.eventID,
	        top: idx === over.index.length - 1
	      }, true);
	    });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private brush handler.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleBrush = function (brush) {
	    var idx = m_this.boxSearch(brush.gcs.lowerLeft, brush.gcs.upperRight),
	        data = m_this.data();

	    feature.eventID += 1;
	    idx.forEach(function (i, idx) {
	      m_this.geoTrigger(geo_event.feature.brush, {
	        data: data[i],
	        index: i,
	        mouse: brush.mouse,
	        brush: brush,
	        eventID: feature.eventID,
	        top: idx === idx.length - 1
	      }, true);
	    });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private brushend handler.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleBrushend = function (brush) {
	    var idx = m_this.boxSearch(brush.gcs.lowerLeft, brush.gcs.upperRight),
	        data = m_this.data();

	    feature.eventID += 1;
	    idx.forEach(function (i, idx) {
	      m_this.geoTrigger(geo_event.feature.brushend, {
	        data: data[i],
	        index: i,
	        mouse: brush.mouse,
	        brush: brush,
	        eventID: feature.eventID,
	        top: idx === idx.length - 1
	      }, true);
	    });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set style used by the feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.style = function (arg1, arg2) {
	    if (arg1 === undefined) {
	      return m_style;
	    } else if (typeof arg1 === 'string' && arg2 === undefined) {
	      return m_style[arg1];
	    } else if (arg2 === undefined) {
	      m_style = $.extend({}, m_style, arg1);
	      m_this.modified();
	      return m_this;
	    } else {
	      m_style[arg1] = arg2;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * A uniform getter that always returns a function even for constant styles.
	   * Maybe extend later to support accessor-like objects.  If undefined input,
	   * return all the styles as an object.
	   *
	   * @param {string|undefined} key
	   * @return {function}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.style.get = function (key) {
	    var out;
	    if (key === undefined) {
	      var all = {}, k;
	      for (k in m_style) {
	        if (m_style.hasOwnProperty(k)) {
	          all[k] = m_this.style.get(k);
	        }
	      }
	      return all;
	    }
	    if (key.toLowerCase().match(/color$/)) {
	      if (util.isFunction(m_style[key])) {
	        out = function () {
	          return util.convertColor(
	            m_style[key].apply(this, arguments)
	          );
	        };
	      } else {
	        // if the color is not a function, only convert it once
	        out = util.ensureFunction(util.convertColor(m_style[key]));
	      }
	    } else {
	      out = util.ensureFunction(m_style[key]);
	    }
	    return out;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get layer referenced by the feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.layer = function () {
	    return m_layer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get renderer used by the feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.renderer = function () {
	    return m_renderer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set projection of the feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.gcs = function (val) {
	    if (val === undefined) {
	      if (m_gcs === undefined && m_renderer) {
	        return m_renderer.layer().map().ingcs();
	      }
	      return m_gcs;
	    } else {
	      m_gcs = val;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from the renderer's input gcs coordinates to display coordinates.
	   *
	   * @param {object} c The input coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @return {object} Display space coordinates
	   */
	  this.featureGcsToDisplay = function (c) {
	    var map = m_renderer.layer().map();
	    c = map.gcsToWorld(c, m_this.gcs());
	    c = map.worldToDisplay(c);
	    if (m_renderer.baseToLocal) {
	      c = m_renderer.baseToLocal(c);
	    }
	    return c;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set visibility of the feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.visible = function (val) {
	    if (val === undefined) {
	      return m_visible;
	    } else {
	      m_visible = val;
	      m_this.modified();

	      // bind or unbind mouse handlers on visibility change
	      if (m_visible) {
	        m_this._bindMouseHandlers();
	      } else {
	        m_this._unbindMouseHandlers();
	      }

	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set bin of the feature
	   *
	   * Bin number is typically used for sorting the order of rendering
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bin = function (val) {
	    if (val === undefined) {
	      return m_bin;
	    } else {
	      m_bin = val;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set timestamp of data change
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.dataTime = function (val) {
	    if (val === undefined) {
	      return m_dataTime;
	    } else {
	      m_dataTime = val;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set timestamp of last time build happened
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.buildTime = function (val) {
	    if (val === undefined) {
	      return m_buildTime;
	    } else {
	      m_buildTime = val;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set timestamp of last time update happened
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateTime = function (val) {
	    if (val === undefined) {
	      return m_updateTime;
	    } else {
	      m_updateTime = val;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set the data array for the feature.
	   *
	   * @returns {Array|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.data = function (data) {
	    if (data === undefined) {
	      return m_this.style('data') || [];
	    } else {
	      m_this.style('data', data);
	      m_this.dataTime().modified();
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Query if the selection API is enabled for this feature.
	   * @returns {bool}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.selectionAPI = function () {
	    return m_selectionAPI;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   *
	   * Derived class should implement this
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    if (!m_layer) {
	      throw 'Feature requires a valid layer';
	    }
	    m_style = $.extend({},
	                {'opacity': 1.0}, arg.style === undefined ? {} :
	                arg.style);
	    m_this._bindMouseHandlers();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * Derived class should implement this
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * Derived class should implement this
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   *
	   * Derived class should implement this
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this._unbindMouseHandlers();
	    m_selectedFeatures = [];
	    m_style = {};
	    arg = {};
	    s_exit();
	  };

	  this._init(arg);
	  return this;
	};

	/**
	 * The most recent feature event triggered.
	 * @type {number}
	 */
	feature.eventID = 0;

	/**
	 * General object specification for feature types.
	 * @typedef geo.feature.spec
	 * @type {object}
	 * @property {string} type A supported feature type.
	 * @property {object[]} [data=[]] An array of arbitrary objects used to
	 * construct the feature.  These objects (and their associated
	 * indices in the array) will be passed back to style and attribute
	 * accessors provided by the user.  In general the number of
	 * 'markers' drawn will be equal to the length of this array.
	 */

	/**
	 * Create a feature from an object.  The implementation here is
	 * meant to define the general interface of creating features
	 * from a javascript object.  See documentation from individual
	 * feature types for specific details.  In case of an error in
	 * the arguments this method will return null;
	 * @param {geo.layer} layer The layer to add the feature to
	 * @param {geo.feature.spec} [spec={}] The object specification
	 * @returns {geo.feature|null}
	 */
	feature.create = function (layer, spec) {
	  'use strict';

	  var type = spec.type;

	  // Check arguments
	  if (!(layer instanceof __webpack_require__(201))) {
	    console.warn('Invalid layer');
	    return null;
	  }
	  if (typeof spec !== 'object') {
	    console.warn('Invalid spec');
	    return null;
	  }
	  var feature = layer.createFeature(type);
	  if (!feature) {
	    console.warn('Could not create feature type "' + type + '"');
	    return null;
	  }

	  spec = spec || {};
	  spec.data = spec.data || [];
	  return feature.style(spec);
	};

	inherit(feature, sceneObject);
	module.exports = feature;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var object = __webpack_require__(80);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sceneObject, which extends the object's
	 * event handling with a tree-based event propagation.
	 *
	 * @class geo.sceneObject
	 * @extends geo.object
	 * @returns {geo.sceneObject}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var sceneObject = function (arg) {
	  'use strict';
	  if (!(this instanceof sceneObject)) {
	    return new sceneObject();
	  }
	  object.call(this, arg);

	  var m_this = this,
	      m_parent = null,
	      m_children = [],
	      s_exit = this._exit,
	      s_trigger = this.geoTrigger,
	      s_addPromise = this.addPromise,
	      s_onIdle = this.onIdle;

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Override object.addPromise to propagate up the scene tree.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.addPromise = function (promise) {
	    if (m_parent) {
	      m_parent.addPromise(promise);
	    } else {
	      s_addPromise(promise);
	    }
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Override object.onIdle to propagate up the scene tree.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.onIdle = function (handler) {
	    if (m_parent) {
	      m_parent.onIdle(handler);
	    } else {
	      s_onIdle(handler);
	    }
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Get/set parent of the object
	   *  @param {?geo.sceneObject} parent
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.parent = function (arg) {
	    if (arg === undefined) {
	      return m_parent;
	    }
	    m_parent = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Add a child (or an array of children) to the object
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.addChild = function (child) {
	    if (Array.isArray(child)) {
	      child.forEach(m_this.addChild);
	      return m_this;
	    }
	    child.parent(m_this);
	    m_children.push(child);
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Remove a child (or array of children) from the object
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.removeChild = function (child) {
	    if (Array.isArray(child)) {
	      child.forEach(m_this.removeChild);
	      return m_this;
	    }
	    m_children = m_children.filter(function (c) { return c !== child; });
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Get an array of child objects
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.children = function () {
	    return m_children.slice();
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Force redraw of a scene object, to be implemented by subclasses.
	   *  Base class just calls draw of child objects.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.draw = function (arg) {
	    m_this.children().forEach(function (child) {
	      child.draw(arg);
	    });
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Trigger an event (or events) on this object and call all handlers.
	   *  @param {String} event the event to trigger
	   *  @param {Object} args arbitrary argument to pass to the handler
	   *  @param {Boolean} childrenOnly if true, only propagate down the tree
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.geoTrigger = function (event, args, childrenOnly) {

	    var geoArgs;

	    args = args || {};
	    geoArgs = args.geo || {};
	    args.geo = geoArgs;

	    // stop propagation if requested by the handler
	    if (geoArgs.stopPropagation) {
	      return m_this;
	    }

	    // If the event was not triggered by the parent, just propagate up the tree
	    if (!childrenOnly && m_parent && geoArgs._triggeredBy !== m_parent) {
	      geoArgs._triggeredBy = m_this;
	      m_parent.geoTrigger(event, args);
	      return m_this;
	    }

	    // call the object's own handlers
	    s_trigger.call(m_this, event, args);

	    // stop propagation if requested by the handler
	    if (geoArgs.stopPropagation) {
	      return m_this;
	    }

	    // trigger the event on the children
	    m_children.forEach(function (child) {
	      if (child.geoTrigger) {
	        geoArgs._triggeredBy = m_this;
	        child.geoTrigger(event, args);
	      }
	    });

	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Free all resources and destroy the object.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.children = [];
	    delete m_this.parent;
	    s_exit();
	  };

	  return this;
	};

	inherit(sceneObject, object);
	module.exports = sceneObject;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var vgl = __webpack_require__(81);
	var inherit = __webpack_require__(4);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class object
	 *
	 * @class geo.object
	 * @extends vgl.object
	 * @returns {geo.object}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var object = function () {
	  'use strict';
	  if (!(this instanceof object)) {
	    return new object();
	  }

	  var m_this = this,
	      m_eventHandlers = {},
	      m_idleHandlers = [],
	      m_promiseCount = 0;

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Bind a handler that will be called once when all internal promises are
	   *  resolved.
	   *
	   *  @param {function} handler A function taking no arguments
	   *  @returns {geo.object[]|geo.object} this
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.onIdle = function (handler) {
	    if (m_promiseCount) {
	      m_idleHandlers.push(handler);
	    } else {
	      handler();
	    }
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Add a new promise object preventing idle event handlers from being called
	   *  until it is resolved.
	   *
	   *  @param {Promise} promise A promise object
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.addPromise = function (promise) {
	    // called on any resolution of the promise
	    function onDone() {
	      m_promiseCount -= 1;
	      if (!m_promiseCount) {
	        m_idleHandlers.splice(0, m_idleHandlers.length)
	          .forEach(function (handler) {
	            handler();
	          });
	      }
	    }
	    m_promiseCount += 1;
	    promise.then(onDone, onDone);
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Bind an event handler to this object
	   *
	   *  @param {String} event
	   *    An event from {geo.events}
	   *  @param {function} handler
	   *    A function that will be called when ``event`` is triggered.  The
	   *    function will be given an event object as a first parameter and
	   *    optionally a second argument provided by the triggerer.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.geoOn = function (event, handler) {
	    if (Array.isArray(event)) {
	      event.forEach(function (e) {
	        m_this.geoOn(e, handler);
	      });
	      return m_this;
	    }
	    if (!m_eventHandlers.hasOwnProperty(event)) {
	      m_eventHandlers[event] = [];
	    }
	    m_eventHandlers[event].push(handler);
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Trigger an event (or events) on this object and call all handlers
	   *
	   *  @param {String} event An event from {geo.event}
	   *  @param {Object} args An optional argument to pass to handlers
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.geoTrigger = function (event, args) {

	    // if we have an array of events, recall with single events
	    if (Array.isArray(event)) {
	      event.forEach(function (e) {
	        m_this.geoTrigger(e, args);
	      });
	      return m_this;
	    }

	    // append the event type to the argument object
	    args = args || {};
	    args.event = event;

	    if (m_eventHandlers.hasOwnProperty(event)) {
	      m_eventHandlers[event].forEach(function (handler) {
	        handler.call(m_this, args);
	      });
	    }

	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Remove handlers from an event (or an array of events).  If no event is
	   *  provided all hanlders will be removed.
	   *
	   *  @param {string?} event An event from {geo.events}
	   *  @param {object?} arg A function or array of functions to remove from the events
	   *                      or if falsey remove all handlers from the events
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.geoOff = function (event, arg) {
	    if (event === undefined) {
	      m_eventHandlers = {};
	      m_idleHandlers = [];
	      m_promiseCount = 0;
	    }
	    if (Array.isArray(event)) {
	      event.forEach(function (e) {
	        m_this.geoOff(e, arg);
	      });
	      return m_this;
	    }
	    if (!arg) {
	      m_eventHandlers[event] = [];
	    } else if (Array.isArray(arg)) {
	      arg.forEach(function (handler) {
	        m_this.geoOff(event, handler);
	      });
	      return m_this;
	    }
	    // What do we do if the handler is not already bound?
	    //   ignoring for now...
	    if (m_eventHandlers.hasOwnProperty(event)) {
	      m_eventHandlers[event] = m_eventHandlers[event].filter(function (f) {
	        return f !== arg;
	      }
	      );
	    }
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Free all resources and destroy the object.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.geoOff();
	  };

	  vgl.object.call(this);

	  return this;
	};

	inherit(object, vgl.object);
	module.exports = object;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["vgl"] = __webpack_require__(82);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
	var mat4 = __webpack_require__(83);
	var vec4 = __webpack_require__(107);
	var vec3 = __webpack_require__(133);
	var vec2 = __webpack_require__(166);
	var $ = __webpack_require__(1);

	(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return (root['vgl'] = factory());
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    root['vgl'] = factory();
	  }
	}(this, function () {

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/* exported vgl, inherit */
	//////////////////////////////////////////////////////////////////////////////

	if (typeof ogs === 'undefined') {
	  var ogs = {};
	}

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create namespace for the given name
	 *
	 * @param ns_string
	 * @returns {*|{}}
	 */
	//////////////////////////////////////////////////////////////////////////////
	ogs.namespace = function (ns_string) {
	  'use strict';

	  var parts = ns_string.split('.'), parent = ogs, i;

	  // strip redundant leading global
	  if (parts[0] === 'ogs') {
	    parts = parts.slice(1);
	  }
	  for (i = 0; i < parts.length; i += 1) {
	    // create a property if it doesn't exist
	    if (typeof parent[parts[i]] === 'undefined') {
	      parent[parts[i]] = {};
	    }
	    parent = parent[parts[i]];
	  }
	  return parent;
	};

	/** vgl namespace */
	var vgl = ogs.namespace('gl');
	window.vgl = vgl;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Convenient function to define JS inheritance
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.inherit = function (C, P) {
	  'use strict';

	  var F = inherit.func();
	  F.prototype = P.prototype;
	  C.prototype = new F();
	  C.prototype.constructor = C;
	};
	vgl.inherit.func = function () {
	  'use strict';
	  return function () {};
	};

	window.inherit = vgl.inherit;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Convenient function to get size of an object
	 *
	 * @param obj
	 * @returns {number} *
	 */
	//////////////////////////////////////////////////////////////////////////////
	Object.size = function (obj) {
	  'use strict';

	  var size = 0, key;
	  for (key in obj) {
	    if (obj.hasOwnProperty(key)) {
	      size += 1;
	    }
	  }
	  return size;
	};

	/* Polyfill for Math.log2 */
	if (!Math.log2) {
	  Math.log2 = function (val) {
	    return Math.log(val) / Math.log(2);
	  };
	}

	vgl.version = '0.3.10';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Wrap GL enums. Currently to get values of the enums we need to create
	 * or access the context.
	 *
	 * Using enums from here:
	 * https://github.com/toji/dart-gl-enums/blob/master/lib/gl_enums.dart
	 *
	 * @class
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.GL = {
	  ACTIVE_ATTRIBUTES : 0x8B89,
	  ACTIVE_TEXTURE : 0x84E0,
	  ACTIVE_UNIFORMS : 0x8B86,
	  ALIASED_LINE_WIDTH_RANGE : 0x846E,
	  ALIASED_POINT_SIZE_RANGE : 0x846D,
	  ALPHA : 0x1906,
	  ALPHA_BITS : 0x0D55,
	  ALWAYS : 0x0207,
	  ARRAY_BUFFER : 0x8892,
	  ARRAY_BUFFER_BINDING : 0x8894,
	  ATTACHED_SHADERS : 0x8B85,
	  BACK : 0x0405,
	  BLEND : 0x0BE2,
	  BLEND_COLOR : 0x8005,
	  BLEND_DST_ALPHA : 0x80CA,
	  BLEND_DST_RGB : 0x80C8,
	  BLEND_EQUATION : 0x8009,
	  BLEND_EQUATION_ALPHA : 0x883D,
	  BLEND_EQUATION_RGB : 0x8009,
	  BLEND_SRC_ALPHA : 0x80CB,
	  BLEND_SRC_RGB : 0x80C9,
	  BLUE_BITS : 0x0D54,
	  BOOL : 0x8B56,
	  BOOL_VEC2 : 0x8B57,
	  BOOL_VEC3 : 0x8B58,
	  BOOL_VEC4 : 0x8B59,
	  BROWSER_DEFAULT_WEBGL : 0x9244,
	  BUFFER_SIZE : 0x8764,
	  BUFFER_USAGE : 0x8765,
	  BYTE : 0x1400,
	  CCW : 0x0901,
	  CLAMP_TO_EDGE : 0x812F,
	  COLOR_ATTACHMENT0 : 0x8CE0,
	  COLOR_BUFFER_BIT : 0x00004000,
	  COLOR_CLEAR_VALUE : 0x0C22,
	  COLOR_WRITEMASK : 0x0C23,
	  COMPILE_STATUS : 0x8B81,
	  COMPRESSED_TEXTURE_FORMATS : 0x86A3,
	  CONSTANT_ALPHA : 0x8003,
	  CONSTANT_COLOR : 0x8001,
	  CONTEXT_LOST_WEBGL : 0x9242,
	  CULL_FACE : 0x0B44,
	  CULL_FACE_MODE : 0x0B45,
	  CURRENT_PROGRAM : 0x8B8D,
	  CURRENT_VERTEX_ATTRIB : 0x8626,
	  CW : 0x0900,
	  DECR : 0x1E03,
	  DECR_WRAP : 0x8508,
	  DELETE_STATUS : 0x8B80,
	  DEPTH_ATTACHMENT : 0x8D00,
	  DEPTH_BITS : 0x0D56,
	  DEPTH_BUFFER_BIT : 0x00000100,
	  DEPTH_CLEAR_VALUE : 0x0B73,
	  DEPTH_COMPONENT : 0x1902,
	  DEPTH_COMPONENT16 : 0x81A5,
	  DEPTH_FUNC : 0x0B74,
	  DEPTH_RANGE : 0x0B70,
	  DEPTH_STENCIL : 0x84F9,
	  DEPTH_STENCIL_ATTACHMENT : 0x821A,
	  DEPTH_TEST : 0x0B71,
	  DEPTH_WRITEMASK : 0x0B72,
	  DITHER : 0x0BD0,
	  DONT_CARE : 0x1100,
	  DST_ALPHA : 0x0304,
	  DST_COLOR : 0x0306,
	  DYNAMIC_DRAW : 0x88E8,
	  ELEMENT_ARRAY_BUFFER : 0x8893,
	  ELEMENT_ARRAY_BUFFER_BINDING : 0x8895,
	  EQUAL : 0x0202,
	  FASTEST : 0x1101,
	  FLOAT : 0x1406,
	  FLOAT_MAT2 : 0x8B5A,
	  FLOAT_MAT3 : 0x8B5B,
	  FLOAT_MAT4 : 0x8B5C,
	  FLOAT_VEC2 : 0x8B50,
	  FLOAT_VEC3 : 0x8B51,
	  FLOAT_VEC4 : 0x8B52,
	  FRAGMENT_SHADER : 0x8B30,
	  FRAMEBUFFER : 0x8D40,
	  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME : 0x8CD1,
	  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE : 0x8CD0,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE : 0x8CD3,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL : 0x8CD2,
	  FRAMEBUFFER_BINDING : 0x8CA6,
	  FRAMEBUFFER_COMPLETE : 0x8CD5,
	  FRAMEBUFFER_INCOMPLETE_ATTACHMENT : 0x8CD6,
	  FRAMEBUFFER_INCOMPLETE_DIMENSIONS : 0x8CD9,
	  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT : 0x8CD7,
	  FRAMEBUFFER_UNSUPPORTED : 0x8CDD,
	  FRONT : 0x0404,
	  FRONT_AND_BACK : 0x0408,
	  FRONT_FACE : 0x0B46,
	  FUNC_ADD : 0x8006,
	  FUNC_REVERSE_SUBTRACT : 0x800B,
	  FUNC_SUBTRACT : 0x800A,
	  GENERATE_MIPMAP_HINT : 0x8192,
	  GEQUAL : 0x0206,
	  GREATER : 0x0204,
	  GREEN_BITS : 0x0D53,
	  HIGH_FLOAT : 0x8DF2,
	  HIGH_INT : 0x8DF5,
	  INCR : 0x1E02,
	  INCR_WRAP : 0x8507,
	  INT : 0x1404,
	  INT_VEC2 : 0x8B53,
	  INT_VEC3 : 0x8B54,
	  INT_VEC4 : 0x8B55,
	  INVALID_ENUM : 0x0500,
	  INVALID_FRAMEBUFFER_OPERATION : 0x0506,
	  INVALID_OPERATION : 0x0502,
	  INVALID_VALUE : 0x0501,
	  INVERT : 0x150A,
	  KEEP : 0x1E00,
	  LEQUAL : 0x0203,
	  LESS : 0x0201,
	  LINEAR : 0x2601,
	  LINEAR_MIPMAP_LINEAR : 0x2703,
	  LINEAR_MIPMAP_NEAREST : 0x2701,
	  LINES : 0x0001,
	  LINE_LOOP : 0x0002,
	  LINE_STRIP : 0x0003,
	  LINE_WIDTH : 0x0B21,
	  LINK_STATUS : 0x8B82,
	  LOW_FLOAT : 0x8DF0,
	  LOW_INT : 0x8DF3,
	  LUMINANCE : 0x1909,
	  LUMINANCE_ALPHA : 0x190A,
	  MAX_COMBINED_TEXTURE_IMAGE_UNITS : 0x8B4D,
	  MAX_CUBE_MAP_TEXTURE_SIZE : 0x851C,
	  MAX_FRAGMENT_UNIFORM_VECTORS : 0x8DFD,
	  MAX_RENDERBUFFER_SIZE : 0x84E8,
	  MAX_TEXTURE_IMAGE_UNITS : 0x8872,
	  MAX_TEXTURE_SIZE : 0x0D33,
	  MAX_VARYING_VECTORS : 0x8DFC,
	  MAX_VERTEX_ATTRIBS : 0x8869,
	  MAX_VERTEX_TEXTURE_IMAGE_UNITS : 0x8B4C,
	  MAX_VERTEX_UNIFORM_VECTORS : 0x8DFB,
	  MAX_VIEWPORT_DIMS : 0x0D3A,
	  MEDIUM_FLOAT : 0x8DF1,
	  MEDIUM_INT : 0x8DF4,
	  MIRRORED_REPEAT : 0x8370,
	  NEAREST : 0x2600,
	  NEAREST_MIPMAP_LINEAR : 0x2702,
	  NEAREST_MIPMAP_NEAREST : 0x2700,
	  NEVER : 0x0200,
	  NICEST : 0x1102,
	  NONE : 0,
	  NOTEQUAL : 0x0205,
	  NO_ERROR : 0,
	  ONE : 1,
	  ONE_MINUS_CONSTANT_ALPHA : 0x8004,
	  ONE_MINUS_CONSTANT_COLOR : 0x8002,
	  ONE_MINUS_DST_ALPHA : 0x0305,
	  ONE_MINUS_DST_COLOR : 0x0307,
	  ONE_MINUS_SRC_ALPHA : 0x0303,
	  ONE_MINUS_SRC_COLOR : 0x0301,
	  OUT_OF_MEMORY : 0x0505,
	  PACK_ALIGNMENT : 0x0D05,
	  POINTS : 0x0000,
	  POLYGON_OFFSET_FACTOR : 0x8038,
	  POLYGON_OFFSET_FILL : 0x8037,
	  POLYGON_OFFSET_UNITS : 0x2A00,
	  RED_BITS : 0x0D52,
	  RENDERBUFFER : 0x8D41,
	  RENDERBUFFER_ALPHA_SIZE : 0x8D53,
	  RENDERBUFFER_BINDING : 0x8CA7,
	  RENDERBUFFER_BLUE_SIZE : 0x8D52,
	  RENDERBUFFER_DEPTH_SIZE : 0x8D54,
	  RENDERBUFFER_GREEN_SIZE : 0x8D51,
	  RENDERBUFFER_HEIGHT : 0x8D43,
	  RENDERBUFFER_INTERNAL_FORMAT : 0x8D44,
	  RENDERBUFFER_RED_SIZE : 0x8D50,
	  RENDERBUFFER_STENCIL_SIZE : 0x8D55,
	  RENDERBUFFER_WIDTH : 0x8D42,
	  RENDERER : 0x1F01,
	  REPEAT : 0x2901,
	  REPLACE : 0x1E01,
	  RGB : 0x1907,
	  RGB565 : 0x8D62,
	  RGB5_A1 : 0x8057,
	  RGBA : 0x1908,
	  RGBA4 : 0x8056,
	  SAMPLER_2D : 0x8B5E,
	  SAMPLER_CUBE : 0x8B60,
	  SAMPLES : 0x80A9,
	  SAMPLE_ALPHA_TO_COVERAGE : 0x809E,
	  SAMPLE_BUFFERS : 0x80A8,
	  SAMPLE_COVERAGE : 0x80A0,
	  SAMPLE_COVERAGE_INVERT : 0x80AB,
	  SAMPLE_COVERAGE_VALUE : 0x80AA,
	  SCISSOR_BOX : 0x0C10,
	  SCISSOR_TEST : 0x0C11,
	  SHADER_TYPE : 0x8B4F,
	  SHADING_LANGUAGE_VERSION : 0x8B8C,
	  SHORT : 0x1402,
	  SRC_ALPHA : 0x0302,
	  SRC_ALPHA_SATURATE : 0x0308,
	  SRC_COLOR : 0x0300,
	  STATIC_DRAW : 0x88E4,
	  STENCIL_ATTACHMENT : 0x8D20,
	  STENCIL_BACK_FAIL : 0x8801,
	  STENCIL_BACK_FUNC : 0x8800,
	  STENCIL_BACK_PASS_DEPTH_FAIL : 0x8802,
	  STENCIL_BACK_PASS_DEPTH_PASS : 0x8803,
	  STENCIL_BACK_REF : 0x8CA3,
	  STENCIL_BACK_VALUE_MASK : 0x8CA4,
	  STENCIL_BACK_WRITEMASK : 0x8CA5,
	  STENCIL_BITS : 0x0D57,
	  STENCIL_BUFFER_BIT : 0x00000400,
	  STENCIL_CLEAR_VALUE : 0x0B91,
	  STENCIL_FAIL : 0x0B94,
	  STENCIL_FUNC : 0x0B92,
	  STENCIL_INDEX : 0x1901,
	  STENCIL_INDEX8 : 0x8D48,
	  STENCIL_PASS_DEPTH_FAIL : 0x0B95,
	  STENCIL_PASS_DEPTH_PASS : 0x0B96,
	  STENCIL_REF : 0x0B97,
	  STENCIL_TEST : 0x0B90,
	  STENCIL_VALUE_MASK : 0x0B93,
	  STENCIL_WRITEMASK : 0x0B98,
	  STREAM_DRAW : 0x88E0,
	  SUBPIXEL_BITS : 0x0D50,
	  TEXTURE : 0x1702,
	  TEXTURE0 : 0x84C0,
	  TEXTURE1 : 0x84C1,
	  TEXTURE10 : 0x84CA,
	  TEXTURE11 : 0x84CB,
	  TEXTURE12 : 0x84CC,
	  TEXTURE13 : 0x84CD,
	  TEXTURE14 : 0x84CE,
	  TEXTURE15 : 0x84CF,
	  TEXTURE16 : 0x84D0,
	  TEXTURE17 : 0x84D1,
	  TEXTURE18 : 0x84D2,
	  TEXTURE19 : 0x84D3,
	  TEXTURE2 : 0x84C2,
	  TEXTURE20 : 0x84D4,
	  TEXTURE21 : 0x84D5,
	  TEXTURE22 : 0x84D6,
	  TEXTURE23 : 0x84D7,
	  TEXTURE24 : 0x84D8,
	  TEXTURE25 : 0x84D9,
	  TEXTURE26 : 0x84DA,
	  TEXTURE27 : 0x84DB,
	  TEXTURE28 : 0x84DC,
	  TEXTURE29 : 0x84DD,
	  TEXTURE3 : 0x84C3,
	  TEXTURE30 : 0x84DE,
	  TEXTURE31 : 0x84DF,
	  TEXTURE4 : 0x84C4,
	  TEXTURE5 : 0x84C5,
	  TEXTURE6 : 0x84C6,
	  TEXTURE7 : 0x84C7,
	  TEXTURE8 : 0x84C8,
	  TEXTURE9 : 0x84C9,
	  TEXTURE_2D : 0x0DE1,
	  TEXTURE_BINDING_2D : 0x8069,
	  TEXTURE_BINDING_CUBE_MAP : 0x8514,
	  TEXTURE_CUBE_MAP : 0x8513,
	  TEXTURE_CUBE_MAP_NEGATIVE_X : 0x8516,
	  TEXTURE_CUBE_MAP_NEGATIVE_Y : 0x8518,
	  TEXTURE_CUBE_MAP_NEGATIVE_Z : 0x851A,
	  TEXTURE_CUBE_MAP_POSITIVE_X : 0x8515,
	  TEXTURE_CUBE_MAP_POSITIVE_Y : 0x8517,
	  TEXTURE_CUBE_MAP_POSITIVE_Z : 0x8519,
	  TEXTURE_MAG_FILTER : 0x2800,
	  TEXTURE_MIN_FILTER : 0x2801,
	  TEXTURE_WRAP_S : 0x2802,
	  TEXTURE_WRAP_T : 0x2803,
	  TRIANGLES : 0x0004,
	  TRIANGLE_FAN : 0x0006,
	  TRIANGLE_STRIP : 0x0005,
	  UNPACK_ALIGNMENT : 0x0CF5,
	  UNPACK_COLORSPACE_CONVERSION_WEBGL : 0x9243,
	  UNPACK_FLIP_Y_WEBGL : 0x9240,
	  UNPACK_PREMULTIPLY_ALPHA_WEBGL : 0x9241,
	  UNSIGNED_BYTE : 0x1401,
	  UNSIGNED_INT : 0x1405,
	  UNSIGNED_SHORT : 0x1403,
	  UNSIGNED_SHORT_4_4_4_4 : 0x8033,
	  UNSIGNED_SHORT_5_5_5_1 : 0x8034,
	  UNSIGNED_SHORT_5_6_5 : 0x8363,
	  VALIDATE_STATUS : 0x8B83,
	  VENDOR : 0x1F00,
	  VERSION : 0x1F02,
	  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING : 0x889F,
	  VERTEX_ATTRIB_ARRAY_ENABLED : 0x8622,
	  VERTEX_ATTRIB_ARRAY_NORMALIZED : 0x886A,
	  VERTEX_ATTRIB_ARRAY_POINTER : 0x8645,
	  VERTEX_ATTRIB_ARRAY_SIZE : 0x8623,
	  VERTEX_ATTRIB_ARRAY_STRIDE : 0x8624,
	  VERTEX_ATTRIB_ARRAY_TYPE : 0x8625,
	  VERTEX_SHADER : 0x8B31,
	  VIEWPORT : 0x0BA2,
	  ZERO : 0
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class timestamp
	 *
	 * @class
	 * @returns {vgl.timestamp}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var m_globalModifiedTime = 0;

	vgl.timestamp = function () {
	  'use strict';

	  if (!(this instanceof vgl.timestamp)) {
	    return new vgl.timestamp();
	  }

	  var m_modifiedTime = 0;

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update modified time
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.modified = function () {
	    m_globalModifiedTime += 1;
	    m_modifiedTime = m_globalModifiedTime;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get modified time
	   *
	   * @returns {number}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.getMTime = function () {
	    return m_modifiedTime;
	  };
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class object
	 *
	 * @class
	 * @returns {vgl.object}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.object = function () {
	  'use strict';

	  if (!(this instanceof vgl.object)) {
	    return new vgl.object();
	  }

	  /** @private */
	  var m_modifiedTime = vgl.timestamp();
	  m_modifiedTime.modified();

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Mark the object modified
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.modified = function () {
	    m_modifiedTime.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return modified time of the object
	   *
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getMTime = function () {
	    return m_modifiedTime.getMTime();
	  };

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class event
	 *
	 * @class event
	 * @returns {vgl.event}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.event = function () {
	  'use strict';

	  if (!(this instanceof vgl.event)) {
	    return new vgl.event();
	  }
	  vgl.object.call(this);

	  return this;
	};

	inherit(vgl.event, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 *  types
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.event.keyPress = 'vgl.event.keyPress';
	vgl.event.mousePress = 'vgl.event.mousePress';
	vgl.event.mouseRelease = 'vgl.event.mouseRelease';
	vgl.event.contextMenu = 'vgl.event.contextMenu';
	vgl.event.configure = 'vgl.event.configure';
	vgl.event.enable = 'vgl.event.enable';
	vgl.event.mouseWheel = 'vgl.event.mouseWheel';
	vgl.event.keyRelease = 'vgl.event.keyRelease';
	vgl.event.middleButtonPress = 'vgl.event.middleButtonPress';
	vgl.event.startInteraction = 'vgl.event.startInteraction';
	vgl.event.enter = 'vgl.event.enter';
	vgl.event.rightButtonPress = 'vgl.event.rightButtonPress';
	vgl.event.middleButtonRelease = 'vgl.event.middleButtonRelease';
	vgl.event.char = 'vgl.event.char';
	vgl.event.disable = 'vgl.event.disable';
	vgl.event.endInteraction = 'vgl.event.endInteraction';
	vgl.event.mouseMove = 'vgl.event.mouseMove';
	vgl.event.mouseOut = 'vgl.event.mouseOut';
	vgl.event.expose = 'vgl.event.expose';
	vgl.event.timer = 'vgl.event.timer';
	vgl.event.leftButtonPress = 'vgl.event.leftButtonPress';
	vgl.event.leave = 'vgl.event.leave';
	vgl.event.rightButtonRelease = 'vgl.event.rightButtonRelease';
	vgl.event.leftButtonRelease = 'vgl.event.leftButtonRelease';
	vgl.event.click = 'vgl.event.click';
	vgl.event.dblClick = 'vgl.event.dblClick';

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class boundingObject
	 *
	 * @class
	 * @return {vgl.boundingObject}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.boundingObject = function () {
	  'use strict';

	  if (!(this instanceof vgl.boundingObject)) {
	    return new vgl.boundingObject();
	  }
	  vgl.object.call(this);

	  /** @private */
	  var m_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
	      m_computeBoundsTimestamp = vgl.timestamp(),
	      m_boundsDirtyTimestamp = vgl.timestamp();

	  m_computeBoundsTimestamp.modified();
	  m_boundsDirtyTimestamp.modified();

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get current bounds of the object
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bounds = function () {
	    return m_bounds;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if bounds are valid
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.hasValidBounds = function (bounds) {
	    if (bounds[0] === Number.MAX_VALUE ||
	        bounds[1] === -Number.MAX_VALUE ||
	        bounds[2] === Number.MAX_VALUE ||
	        bounds[3] === -Number.MAX_VALUE ||
	        bounds[4] === Number.MAX_VALUE ||
	        bounds[5] === -Number.MAX_VALUE) {
	      return false;
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set current bounds of the object
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setBounds = function (minX, maxX, minY, maxY, minZ, maxZ) {
	    if (!this.hasValidBounds([minX, maxX, minY, maxY, minZ, maxZ])) {
	      return;
	    }

	    m_bounds[0] = minX;
	    m_bounds[1] = maxX;
	    m_bounds[2] = minY;
	    m_bounds[3] = maxY;
	    m_bounds[4] = minZ;
	    m_bounds[5] = maxZ;

	    this.modified();
	    m_computeBoundsTimestamp.modified();

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Reset bounds to default values
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resetBounds = function () {
	    m_bounds[0] = Number.MAX_VALUE;
	    m_bounds[1] = -Number.MAX_VALUE;
	    m_bounds[2] = Number.MAX_VALUE;
	    m_bounds[3] = -Number.MAX_VALUE;
	    m_bounds[4] = Number.MAX_VALUE;
	    m_bounds[5] = -Number.MAX_VALUE;

	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute bounds of the object
	   *
	   * Should be implemented by the concrete class
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBounds = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return bounds computation modification time
	   *
	   * @returns {vgl.timestamp}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBoundsTimestamp = function () {
	    return m_computeBoundsTimestamp;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return bounds dirty timestamp
	   *
	   * @returns {vgl.timestamp}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.boundsDirtyTimestamp = function () {
	    return m_boundsDirtyTimestamp;
	  };

	  this.resetBounds();

	  return this;
	};

	vgl.boundingObject.ReferenceFrame = {
	  'Relative' : 0,
	  'Absolute' : 1
	};

	inherit(vgl.boundingObject, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class node
	 *
	 * @class
	 * @returns {vgl.node}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.node = function () {
	  'use strict';

	  if (!(this instanceof vgl.node)) {
	    return new vgl.node();
	  }
	  vgl.boundingObject.call(this);

	  /** @private */
	  var m_parent = null,
	      m_material = null,
	      m_visible = true,
	      m_overlay = false;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Accept visitor for scene traversal
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.accept = function (visitor) {
	    visitor.visit(this);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return active material used by the node
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.material = function () {
	    return m_material;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set material to be used the node
	   *
	   * @param material
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setMaterial = function (material) {
	    if (material !== m_material) {
	      m_material = material;
	      this.modified();
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if the node is visible or node
	   *
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.visible = function () {
	    return m_visible;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Turn ON/OFF visibility of the node
	   *
	   * @param flag
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setVisible = function (flag) {
	    if (flag !== m_visible) {
	      m_visible = flag;
	      this.modified();
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return current parent of the node
	   *
	   * @returns {null}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parent = function () {
	    return m_parent;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set parent of the node
	   *
	   * @param parent
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setParent = function (parent) {
	    if (parent !== m_parent) {
	      if (m_parent !== null) {
	        m_parent.removeChild(this);
	      }
	      m_parent = parent;
	      this.modified();
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if the node is an overlay node
	   *
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.overlay = function () {
	    return m_overlay;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set if the node is an overlay node or not
	   *
	   * @param flag
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setOverlay = function (flag) {
	    if (m_overlay !== flag) {
	      m_overlay = flag;
	      this.modified();
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /*
	   * Traverse parent and their parent and so on
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.ascend = function (visitor) {
	    visitor = visitor; /* unused parameter */
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Traverse children
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.traverse = function (visitor) {
	    visitor = visitor; /* unused parameter */
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Mark that the bounds are modified
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.boundsModified = function () {
	    // @todo Implement this
	    this.boundsDirtyTimestamp().modified();

	    if (m_parent !== null) {
	      m_parent.boundsModified();
	    }
	  };

	  return this;
	};

	inherit(vgl.node, vgl.boundingObject);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class groupNode
	 *
	 * @class
	 * @returns {vgl.groupNode}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.groupNode = function () {
	  'use strict';

	  if (!(this instanceof vgl.groupNode)) {
	    return new vgl.groupNode();
	  }
	  vgl.node.call(this);

	  var m_children = [];

	  // Reference to base class methods
	  this.b_setVisible = this.setVisible;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Turn on / off visibility
	   *
	   * @param flag
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setVisible = function (flag) {
	    var i;

	    if (this.b_setVisible(flag) !== true) {
	      return false;
	    }

	    for (i = 0; i < m_children.length; i += 1) {
	      m_children[i].setVisible(flag);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Make the incoming node as child of the group node
	   *
	   * @param childNode
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addChild = function (childNode) {
	    if (childNode instanceof vgl.node) {
	      if (m_children.indexOf(childNode) === -1) {
	        childNode.setParent(this);
	        m_children.push(childNode);
	        this.boundsDirtyTimestamp().modified();
	        return true;
	      }
	      return false;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove parent-child relationship between the group and incoming node
	   *
	   * @param childNode
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeChild = function (childNode) {
	    if (childNode.parent() === this) {
	      var index = m_children.indexOf(childNode);
	      if (index >= 0) {
	        m_children.splice(index, 1);
	        childNode.setParent(null);
	        this.boundsDirtyTimestamp().modified();
	        return true;
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove parent-child relationship between child nodes and the group node
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeChildren = function () {
	    while (m_children.length) {
	      this.removeChild(m_children[0]);
	    }

	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return children of this group node
	   *
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.children = function () {
	    return m_children;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return true if this group node has node as a child, false otherwise.
	   *
	   * @param node
	   * @returns {bool}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.hasChild = function (node) {
	    var i = 0, child = false;

	    for (i = 0; i < m_children.length; i += 1) {
	      if (m_children[i] === node) {
	        child = true;
	        break;
	      }
	    }

	    return child;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Accept a visitor and traverse the scene tree
	   *
	   * @param visitor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.accept = function (visitor) {
	    visitor.visit(this);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Traverse the scene
	   *
	   * @param visitor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.traverse = function (visitor) {
	    switch (visitor.type()) {
	      case visitor.UpdateVisitor:
	        this.traverseChildrenAndUpdateBounds(visitor);
	        break;
	      case visitor.CullVisitor:
	        this.traverseChildren(visitor);
	        break;
	      default:
	        break;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Traverse all of the children and update the bounds for each
	   *
	   * @param visitor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.traverseChildrenAndUpdateBounds = function (visitor) {
	    var i;

	    if (this.parent() && this.boundsDirtyTimestamp().getMTime() >
	      this.computeBoundsTimestamp().getMTime()) {
	      // Flag parents bounds dirty.
	      this.parent().boundsDirtyTimestamp().modified();
	    }

	    this.computeBounds();

	    if (visitor.mode() === visitor.TraverseAllChildren) {
	      for (i = 0; i < m_children.length; i += 1) {
	        m_children[i].accept(visitor);
	        this.updateBounds(m_children[i]);
	      }
	    }

	    this.computeBoundsTimestamp().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Traverse children of the group node
	   *
	   * @param visitor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.traverseChildren = function (visitor) {
	    var i;

	    if (visitor.mode() === visitor.TraverseAllChildren) {
	      for (i = 0; i < m_children.length; i += 1) {
	        m_children[i].accept(visitor);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute bounds for the group node
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBounds = function () {
	    var i = 0;

	    if (this.computeBoundsTimestamp().getMTime() >
	        this.boundsDirtyTimestamp().getMTime()) {
	      return;
	    }

	    for (i = 0; i < m_children.length; i += 1) {
	      this.updateBounds(m_children[i]);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update bounds for the group node
	   *
	   * This method is used internally to update bounds of the group node by
	   * traversing each of its child.
	   *
	   * @param child
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateBounds = function (child) {
	    // FIXME: This check should not be required and possibly is incorrect
	    if (child.overlay()) {
	      return;
	    }

	    // Make sure that child bounds are up to date
	    child.computeBounds();

	    var bounds = this.bounds(),
	        childBounds = child.bounds(),
	        istep = 0,
	        jstep = 0,
	        i;

	    for (i = 0; i < 3; i += 1) {
	      istep = i * 2;
	      jstep = i * 2 + 1;
	      if (childBounds[istep] < bounds[istep]) {
	        bounds[istep] = childBounds[istep];
	      }
	      if (childBounds[jstep] > bounds[jstep]) {
	        bounds[jstep] = childBounds[jstep];
	      }
	    }

	    this.setBounds(bounds[0], bounds[1], bounds[2], bounds[3],
	                   bounds[4], bounds[5]);
	  };

	  return this;
	};

	inherit(vgl.groupNode, vgl.node);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec3, mat4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class actor
	 *
	 * @class
	 * @returns {vgl.actor}
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.actor = function () {
	  'use strict';

	  if (!(this instanceof vgl.actor)) {
	    return new vgl.actor();
	  }
	  vgl.node.call(this);

	  /** @private */
	  var m_this = this,
	      m_transformMatrix = mat4.create(),
	      m_referenceFrame = vgl.boundingObject.ReferenceFrame.Relative,
	      m_mapper = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get transformation matrix used by the actor
	   *
	   * @returns {mat4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.matrix = function () {
	    return m_transformMatrix;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set transformation matrix for the actor
	   *
	   * @param {mat4} 4X4 transformation matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setMatrix = function (tmatrix) {
	    if (tmatrix !== m_transformMatrix) {
	      m_transformMatrix = tmatrix;
	      m_this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get reference frame for the transformations
	   *
	   * @returns {String} Possible values are Absolute or Relative
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.referenceFrame = function () {
	    return m_referenceFrame;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set reference frame for the transformations
	   *
	   * @param {vgl.boundingObject.ReferenceFrame}
	   * referenceFrame Possible values are (Absolute | Relative)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setReferenceFrame = function (referenceFrame) {
	    if (referenceFrame !== m_referenceFrame) {
	      m_referenceFrame = referenceFrame;
	      m_this.modified();
	      return true;
	    }
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return mapper where actor gets it behavior and data
	   *
	   * @returns {vgl.mapper}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.mapper = function () {
	    return m_mapper;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Connect an actor to its data source
	   *
	   * @param {vgl.mapper}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setMapper = function (mapper) {
	    if (mapper !== m_mapper) {
	      m_mapper = mapper;
	      m_this.boundsModified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @todo
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.accept = function (visitor) {
	    visitor = visitor; /* ignore this parameter */
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @todo
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.ascend = function (visitor) {
	    visitor = visitor; /* ignore this parameter */
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute object space to world space matrix
	   * @todo
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeLocalToWorldMatrix = function (matrix, visitor) {
	    matrix = matrix; /* ignore this parameter */
	    visitor = visitor; /* ignore this parameter */
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute world space to object space matrix
	   * @todo
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeWorldToLocalMatrix = function (matrix, visitor) {
	    matrix = matrix; /* ignore this parameter */
	    visitor = visitor; /* ignore this parameter */
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute actor bounds
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBounds = function () {
	    if (m_mapper === null || m_mapper === undefined) {
	      m_this.resetBounds();
	      return;
	    }

	    var computeBoundsTimestamp = m_this.computeBoundsTimestamp(),
	        mapperBounds, minPt, maxPt, newBounds;

	    if (m_this.boundsDirtyTimestamp().getMTime() > computeBoundsTimestamp.getMTime() ||
	      m_mapper.boundsDirtyTimestamp().getMTime() > computeBoundsTimestamp.getMTime()) {

	      m_mapper.computeBounds();
	      mapperBounds = m_mapper.bounds();

	      minPt = [mapperBounds[0], mapperBounds[2], mapperBounds[4]];
	      maxPt = [mapperBounds[1], mapperBounds[3], mapperBounds[5]];

	      vec3.transformMat4(minPt, minPt, m_transformMatrix);
	      vec3.transformMat4(maxPt, maxPt, m_transformMatrix);

	      newBounds = [
	        minPt[0] > maxPt[0] ? maxPt[0] : minPt[0],
	        minPt[0] > maxPt[0] ? minPt[0] : maxPt[0],
	        minPt[1] > maxPt[1] ? maxPt[1] : minPt[1],
	        minPt[1] > maxPt[1] ? minPt[1] : maxPt[1],
	        minPt[2] > maxPt[2] ? maxPt[2] : minPt[2],
	        minPt[2] > maxPt[2] ? minPt[2] : maxPt[2]
	      ];

	      m_this.setBounds(newBounds[0], newBounds[1],
	                     newBounds[2], newBounds[3],
	                     newBounds[4], newBounds[5]);

	      computeBoundsTimestamp.modified();
	    }
	  };

	  return m_this;
	};

	inherit(vgl.actor, vgl.node);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Freeze javascript object
	 *
	 * @param obj
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.freezeObject = function (obj) {
	  'use strict';

	  /**
	   * Freezes an object, using Object.freeze if available, otherwise returns
	   * the object unchanged.  This function should be used in setup code to prevent
	   * errors from completely halting JavaScript execution in legacy browsers.
	   *
	   * @exports freezeObject
	   */
	  var freezedObject = Object.freeze ? Object.freeze(obj) : undefined;
	  if (typeof freezedObject === 'undefined') {
	    return obj;
	  }

	  return freezedObject;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns the first parameter if not undefined,
	 * otherwise the second parameter.
	 *
	 * @class
	 * @returns {vgl.defaultValue}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.defaultValue = function (a, b) {
	  'use strict';

	  if (typeof a !== 'undefined') {
	    return a;
	  }
	  return b;
	};

	vgl.defaultValue.EMPTY_OBJECT = vgl.freezeObject({});

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class graphicsObject
	 *
	 * @class
	 * @param type
	 * @returns {vgl.graphicsObject}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.graphicsObject = function (type) {
	  'use strict';

	  type = type; /* unused parameter */
	  if (!(this instanceof vgl.graphicsObject)) {
	    return new vgl.graphicsObject();
	  }
	  vgl.object.call(this);

	  var m_this = this;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Setup (initialize) the object
	   *
	   * @param renderState
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._setup = function (renderState) {
	    renderState = renderState; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove any resources acquired before deletion
	   *
	   * @param renderState
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._cleanup = function (renderState) {
	    renderState = renderState; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind and activate
	   *
	   * @param renderState
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bind = function (renderState) {
	    renderState = renderState; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo bind and deactivate
	   *
	   * @param renderState
	   * @returns {boolean}
	   *
	   * TODO: Change it to unbind (simple)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.undoBind = function (renderState) {
	    renderState = renderState; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the object
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function (renderState) {
	    renderState = renderState; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove the object and release its graphics resources
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.remove = function (renderState) {
	    m_this._cleanup(renderState);
	  };

	  return m_this;
	};

	inherit(vgl.graphicsObject, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, Uint16Array*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of geojson reader
	 *
	 * This contains code that reads a geoJSON file and produces rendering
	 * primitives from it.
	 *
	 * @class
	 * @returns {vgl.geojsonReader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.geojsonReader = function () {
	  'use strict';

	  if (!(this instanceof vgl.geojsonReader)) {
	    return new vgl.geojsonReader();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read scalars
	   *
	   * @param coordinates
	   * @param geom
	   * @param size_estimate
	   * @param idx
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readScalars = function (coordinates, geom, size_estimate, idx) {
	    var array = null,
	        s = null,
	        r = null,
	        g = null,
	        b = null;

	    if (this.m_scalarFormat === 'values' && coordinates.length === 4) {
	      s = coordinates[3];
	      array = geom.sourceData(vgl.vertexAttributeKeys.Scalar);

	      if (!array) {
	        array = new vgl.sourceDataSf();
	        if (this.m_scalarRange) {
	          array.setScalarRange(this.m_scalarRange[0], this.m_scalarRange[1]);
	        }
	        if (size_estimate !== undefined) {
	          //array.length = size_estimate; //no, slow on Safari
	          array.data().length = size_estimate;
	        }
	        geom.addSource(array);
	      }
	      if (size_estimate === undefined) {
	        array.pushBack(s);
	      } else {
	        array.insertAt(idx, s);
	      }
	    } else if (this.m_scalarFormat === 'rgb' && coordinates.length === 6) {
	      array = geom.sourceData(vgl.vertexAttributeKeys.Color);
	      if (!array) {
	        array = new vgl.sourceDataC3fv();
	        if (size_estimate !== undefined) {
	          array.length = size_estimate * 3;
	        }
	        geom.addSource(array);
	      }
	      r = coordinates[3];
	      g = coordinates[4];
	      b = coordinates[5];
	      if (size_estimate === undefined) {
	        array.pushBack([r, g, b]);
	      } else {
	        array.insertAt(idx, [r, g, b]);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read point data
	   *
	   * @param coordinates
	   * @returns {vgl.geometryData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readPoint = function (coordinates) {
	    var geom = new vgl.geometryData(),
	        vglpoints = new vgl.points(),
	        vglcoords = new vgl.sourceDataP3fv(),
	        indices = new Uint16Array(1),
	        x = null,
	        y = null,
	        z = null,
	        i = null;

	    geom.addSource(vglcoords);
	    for (i = 0; i < 1; i += 1) {
	      indices[i] = i;

	      x = coordinates[0];
	      y = coordinates[1];
	      z = 0.0;
	      if (coordinates.length > 2) {
	        z = coordinates[2];
	      }

	      //console.log('read ' + x + ',' + y + ',' + z);
	      vglcoords.pushBack([x, y, z]);

	      //attributes
	      this.readScalars(coordinates, geom);
	    }

	    vglpoints.setIndices(indices);
	    geom.addPrimitive(vglpoints);
	    geom.setName('aPoint');
	    return geom;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read multipoint data
	   *
	   * @param coordinates
	   * @returns {vgl.geometryData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readMultiPoint = function (coordinates) {
	    var geom = new vgl.geometryData(),
	        vglpoints = new vgl.points(),
	        vglcoords = new vgl.sourceDataP3fv(),
	        indices = new Uint16Array(coordinates.length),
	        pntcnt = 0,
	        estpntcnt = coordinates.length,
	        x = null,
	        y = null,
	        z = null,
	        i;

	    //preallocate with size estimate
	    vglcoords.data().length = estpntcnt * 3; //x,y,z

	    for (i = 0; i < coordinates.length; i += 1) {
	      indices[i] = i;
	      x = coordinates[i][0];
	      y = coordinates[i][1];
	      z = 0.0;
	      if (coordinates[i].length > 2) {
	        z = coordinates[i][2];
	      }

	      //console.log('read ' + x + ',' + y + ',' + z);
	      vglcoords.insertAt(pntcnt, [x, y, z]);

	      //attributes
	      this.readScalars(coordinates[i], geom, estpntcnt, pntcnt);

	      pntcnt += 1;
	    }

	    vglpoints.setIndices(indices);
	    geom.addPrimitive(vglpoints);
	    geom.addSource(vglcoords);
	    geom.setName('manyPoints');
	    return geom;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read line string data
	   *
	   * @param coordinates
	   * @returns {vgl.geometryData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readLineString = function (coordinates) {
	    var geom = new vgl.geometryData(),
	        vglline = new vgl.lineStrip(),
	        vglcoords = new vgl.sourceDataP3fv(),
	        indices = [],
	        i = null,
	        x = null,
	        y = null,
	        z = null;

	    vglline.setIndicesPerPrimitive(coordinates.length);

	    for (i = 0; i < coordinates.length; i += 1) {
	      indices.push(i);
	      x = coordinates[i][0];
	      y = coordinates[i][1];
	      z = 0.0;
	      if (coordinates[i].length > 2) {
	        z = coordinates[i][2];
	      }

	      //console.log('read ' + x + ',' + y + ',' + z);
	      vglcoords.pushBack([x, y, z]);

	      //attributes
	      this.readScalars(coordinates[i], geom);
	    }

	    vglline.setIndices(indices);
	    geom.addPrimitive(vglline);
	    geom.addSource(vglcoords);
	    geom.setName('aLineString');
	    return geom;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read multi line string
	   *
	   * @param coordinates
	   * @returns {vgl.geometryData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readMultiLineString = function (coordinates) {
	    var geom = new vgl.geometryData(),
	        vglcoords = new vgl.sourceDataP3fv(),
	        pntcnt = 0,
	        //lines should be at least 2 verts long, underest OK
	        estpntcnt = coordinates.length * 2,
	        i = null,
	        j = null,
	        x = null,
	        y = null,
	        z = null,
	        indices = null,
	        vglline = null,
	        thisLineLength = null;

	    // Preallocate with size estimate
	    vglcoords.data().length = estpntcnt * 3; //x,y,z

	    for (j = 0; j < coordinates.length; j += 1) {
	      indices = [];
	      //console.log('getting line ' + j);
	      vglline = new vgl.lineStrip();
	      thisLineLength = coordinates[j].length;
	      vglline.setIndicesPerPrimitive(thisLineLength);
	      for (i = 0; i < thisLineLength; i += 1) {
	        indices.push(pntcnt);
	        x = coordinates[j][i][0];
	        y = coordinates[j][i][1];
	        z = 0.0;
	        if (coordinates[j][i].length > 2) {
	          z = coordinates[j][i][2];
	        }

	        //console.log('read ' + x + ',' + y + ',' + z);
	        vglcoords.insertAt(pntcnt, [x, y, z]);

	        //attributes
	        this.readScalars(coordinates[j][i], geom, estpntcnt * 2, pntcnt);

	        pntcnt += 1;
	      }

	      vglline.setIndices(indices);
	      geom.addPrimitive(vglline);
	    }

	    geom.setName('aMultiLineString');
	    geom.addSource(vglcoords);
	    return geom;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read polygon data
	   *
	   * @param coordinates
	   * @returns {vgl.geometryData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readPolygon = function (coordinates) {
	    //TODO: ignoring holes given in coordinates[1...]
	    //TODO: ignoring convex
	    //TODO: implement ear clipping in VGL instead of this to handle both
	    var geom = new vgl.geometryData(),
	        vglcoords = new vgl.sourceDataP3fv(),
	        x = null,
	        y = null,
	        z = null,
	        thisPolyLength = coordinates[0].length,
	        vl = 1,
	        i = null,
	        indices = null,
	        vgltriangle = null;

	    for (i = 0; i < thisPolyLength; i += 1) {
	      x = coordinates[0][i][0];
	      y = coordinates[0][i][1];
	      z = 0.0;
	      if (coordinates[0][i].length > 2) {
	        z = coordinates[0][i][2];
	      }

	      //console.log('read ' + x + ',' + y + ',' + z);
	      vglcoords.pushBack([x, y, z]);

	      //attributes
	      this.readScalars(coordinates[0][i], geom);

	      if (i > 1) {
	        //console.log('Cutting new triangle 0,'+ vl+ ','+ i);
	        indices = new Uint16Array([0, vl, i]);
	        vgltriangle = new vgl.triangles();
	        vgltriangle.setIndices(indices);
	        geom.addPrimitive(vgltriangle);
	        vl = i;
	      }
	    }

	    geom.setName('POLY');
	    geom.addSource(vglcoords);
	    return geom;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read multi polygon data
	   *
	   * @param coordinates
	   * @returns {vgl.geometryData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readMultiPolygon = function (coordinates) {
	    var geom = new vgl.geometryData(),
	        vglcoords = new vgl.sourceDataP3fv(),
	        ccount = 0,
	        numPolys = coordinates.length,
	        pntcnt = 0,
	        estpntcnt = numPolys * 3, // assume triangles, underest is fine
	        vgltriangle = new vgl.triangles(),
	        indexes = [],
	        i = null,
	        j = null,
	        x = null,
	        y = null,
	        z = null,
	        thisPolyLength = null,
	        vf = null,
	        vl = null,
	        flip = null,
	        flipped = false,
	        tcount = 0;

	    //var time1 = new Date().getTime()
	    //var a = 0;
	    //var b = 0;
	    //var c = 0;
	    //var d = 0;

	    //preallocate with size estimate
	    vglcoords.data().length = numPolys * 3; //x,y,z
	    for (j = 0; j < numPolys; j += 1) {
	      //console.log('getting poly ' + j);

	      thisPolyLength = coordinates[j][0].length;
	      vf = ccount;
	      vl = ccount + 1;
	      flip = [false, false, false];
	      for (i = 0; i < thisPolyLength; i += 1) {
	        //var timea = new Date().getTime()

	        x = coordinates[j][0][i][0];
	        y = coordinates[j][0][i][1];
	        z = 0.0;
	        if (coordinates[j][0][i].length > 2) {
	          z = coordinates[j][0][i][2];
	        }
	        flipped = false;
	        if (x > 180) {
	          flipped = true;
	          x = x - 360;
	        }
	        if (i === 0) {
	          flip[0] = flipped;
	        } else {
	          flip[1 + (i - 1) % 2] = flipped;
	        }
	        //var timeb = new Date().getTime();
	        //console.log('read ' + x + ',' + y + ',' + z);

	        vglcoords.insertAt(pntcnt, [x, y, z]);
	        //var timec = new Date().getTime();

	        //attributes
	        this.readScalars(coordinates[j][0][i], geom, estpntcnt, pntcnt);
	        pntcnt += 1;
	        //var timed = new Date().getTime()

	        if (i > 1) {
	          //if (vl < 50) {
	          //console.log('Cutting new triangle ' + tcount + ':' + vf + ',' +
	          //            vl + ',' + ccount);
	          //console.log(indexes);
	          //}
	          if (flip[0] === flip[1] && flip[1] === flip[2]) {
	            //indexes = indexes.concat([vf,vl,ccount]); //no, very slow in Safari
	            indexes[tcount * 3 + 0] = vf;
	            indexes[tcount * 3 + 1] = vl;
	            indexes[tcount * 3 + 2] = ccount;
	            tcount += 1;
	          }
	          //else {
	          //  //TODO: duplicate triangles that straddle boundary on either side
	          //}

	          vl = ccount;
	        }
	        ccount += 1;
	        //var timee = new Date().getTime()
	        //a = a + (timeb-timea)
	        //b = b + (timec-timeb)
	        //c = c + (timed-timec)
	        //d = d + (timee-timed)
	      }
	    }
	    vgltriangle.setIndices(indexes);
	    geom.addPrimitive(vgltriangle);

	    //console.log('NUMPOLYS ' + pntcnt);
	    //console.log('RMP: ', a, ',', b, ',', c, ',', d)
	    //var time2 = new Date().getTime()

	    geom.setName('aMultiPoly');
	    geom.addSource(vglcoords);
	    //var time3 = new Date().getTime()
	    //console.log('RMP: ', time2-time1, ',', time3-time2)

	    return geom;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @param object
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readGJObjectInt = function (object) {
	    if (!object.hasOwnProperty('type')) {
	      //console.log('uh oh, not a geojson object');
	      return null;
	    }

	    //look for properties type annotation
	    if (object.properties &&
	        object.properties.ScalarFormat &&
	        object.properties.ScalarFormat === 'values') {
	      this.m_scalarFormat = 'values';
	      if (object.properties.ScalarRange) {
	        this.m_scalarRange = object.properties.ScalarRange;
	      }
	    }
	    if (object.properties &&
	        object.properties.ScalarFormat &&
	        object.properties.ScalarFormat === 'rgb') {
	      this.m_scalarFormat = 'rgb';
	    }

	    //TODO: ignoring 'crs' and 'bbox' and misc meta data on all of these,
	    //best to handle as references into original probably
	    var ret,
	        type = object.type,
	        next = null,
	        nextset = null,
	        i = null;

	    switch (type) {
	      case 'Point':
	        //console.log('parsed Point');
	        ret = this.readPoint(object.coordinates);
	        break;
	      case 'MultiPoint':
	        //console.log('parsed MultiPoint');
	        ret = this.readMultiPoint(object.coordinates);
	        break;
	      case 'LineString':
	        //console.log('parsed LineString');
	        ret = this.readLineString(object.coordinates);
	        break;
	      case 'MultiLineString':
	        //console.log('parsed MultiLineString');
	        ret = this.readMultiLineString(object.coordinates);
	        break;
	      case 'Polygon':
	        //console.log('parsed Polygon');
	        ret = this.readPolygon(object.coordinates);
	        break;
	      case 'MultiPolygon':
	        //console.log('parsed MultiPolygon');
	        ret = this.readMultiPolygon(object.coordinates);
	        break;
	      case 'GeometryCollection':
	        //console.log('parsed GeometryCollection');
	        nextset = [];
	        for (i = 0; i < object.geometries.length; i += 1) {
	          next = this.readGJObject(object.geometries[i]);
	          nextset.push(next);
	        }
	        ret = nextset;
	        break;
	      case 'Feature':
	        //console.log('parsed Feature');
	        next = this.readGJObject(object.geometry);
	        ret = next;
	        break;
	      case 'FeatureCollection':
	        //console.log('parsed FeatureCollection');
	        nextset = [];
	        for (i = 0; i < object.features.length; i += 1) {
	          next = this.readGJObject(object.features[i]);
	          nextset.push(next);
	        }
	        ret = nextset;
	        break;
	      default:
	        console.log('Don\'t understand type ' + type);
	        ret = null;
	        break;
	    }
	    return ret;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @param object
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readGJObject = function (object) {
	    //var time1, time2;
	    var ret;
	    //time1 = new Date().getTime()
	    ret = this.readGJObjectInt(object);
	    //time2 = new Date().getTime()
	    //console.log('ELAPSED: ', time2-time1)
	    return ret;
	  };

	  /**
	   * Linearize geometries
	   *
	   * @param geoms
	   * @param geom
	   */
	  this.linearizeGeoms = function (geoms, geom) {
	    var i = null;

	    if (Object.prototype.toString.call(geom) === '[object Array]') {
	      for (i = 0; i < geom.length; i += 1) {
	        this.linearizeGeoms(geoms, geom[i]);
	      }
	    } else {
	      geoms.push(geom);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Read geometries from geojson object
	   *
	   * @param object
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readGeomObject = function (object) {
	    var geom,
	        geoms = [];

	    geom = this.readGJObject(object);
	    this.linearizeGeoms(geoms, geom);
	    return geoms;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Given a buffer get rendering primitives
	   *
	   * @param buffer
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getPrimitives = function (buffer) {
	    //console.log('Parsing geoJSON');
	    if (!buffer) {
	      return [];
	    }

	    var obj = JSON.parse(buffer),
	        geom = this.readGJObject(obj),
	        geoms = [];

	    this.m_scalarFormat = 'none';
	    this.m_scalarRange = null;

	    this.linearizeGeoms(geoms, geom);

	    return { 'geoms': geoms,
	             'scalarFormat': this.m_scalarFormat,
	             'scalarRange': this.m_scalarRange };
	  };

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	vgl.data = function () {
	  'use strict';

	  if (!(this instanceof vgl.data)) {
	    return new vgl.data();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return data type. Should be implemented by the derived class
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.type = function () {
	  };
	};

	vgl.data.raster = 0;
	vgl.data.point = 1;
	vgl.data.lineString = 2;
	vgl.data.polygon = 3;
	vgl.data.geometry = 10;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, Uint16Array, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class primitive
	 *
	 * @class
	 * @return {vgl.primitive}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.primitive = function () {
	  'use strict';

	  if (!(this instanceof vgl.primitive)) {
	    return new vgl.primitive();
	  }

	  /** @private */
	  var m_indicesPerPrimitive = 0,
	      m_primitiveType = 0,
	      m_indicesValueType = 0,
	      m_indices = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get indices of the primitive
	   *
	   * @returns {null}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.indices = function () {
	    return m_indices;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create indices array for the primitive
	   * @param type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createIndices = function (type) {
	    void type;
	    // TODO Check for the type
	    m_indices = new Uint16Array();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the number of indices
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.numberOfIndices = function () {
	    return m_indices.length;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return size of indices in bytes
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.sizeInBytes = function () {
	    return m_indices.length * Uint16Array.BYTES_PER_ELEMENT;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /*
	   * Return primitive type g
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.primitiveType = function () {
	    return m_primitiveType;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set primitive type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setPrimitiveType = function (type) {
	    m_primitiveType = type;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return count of indices that form a primitives
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.indicesPerPrimitive = function () {
	    return m_indicesPerPrimitive;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set count of indices that form a primitive
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setIndicesPerPrimitive = function (count) {
	    m_indicesPerPrimitive = count;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return indices value type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.indicesValueType = function () {
	    return m_indicesValueType;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set indices value type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setIndicesValueType = function (type) {
	    m_indicesValueType = type;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set indices from a array
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setIndices = function (indicesArray) {
	    // TODO Check for the type
	    m_indices = new Uint16Array(indicesArray);
	  };

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class triangleStrip
	 *
	 * @returns {vgl.triangleStrip}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.triangleStrip = function () {
	  'use strict';

	  if (!(this instanceof vgl.triangleStrip)) {
	    return new vgl.triangleStrip();
	  }

	  vgl.primitive.call(this);

	  this.setPrimitiveType(vgl.GL.TRIANGLE_STRIP);
	  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
	  this.setIndicesPerPrimitive(3);

	  return this;
	};

	inherit(vgl.triangleStrip, vgl.primitive);

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class triangles
	 *
	 * @returns {vgl.triangles}
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.triangles = function () {
	  'use strict';

	  if (!(this instanceof vgl.triangles)) {
	    return new vgl.triangles();
	  }
	  vgl.primitive.call(this);

	  this.setPrimitiveType(vgl.GL.TRIANGLES);
	  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
	  this.setIndicesPerPrimitive(3);

	  return this;
	};

	inherit(vgl.triangles, vgl.primitive);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * create a instance of lines primitive type
	 *
	 * @returns {vgl.lines}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.lines = function () {
	  'use strict';

	  if (!(this instanceof vgl.lines)) {
	    return new vgl.lines();
	  }
	  vgl.primitive.call(this);

	  this.setPrimitiveType(vgl.GL.LINES);
	  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
	  this.setIndicesPerPrimitive(2);

	  return this;
	};
	inherit(vgl.lines, vgl.primitive);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * create a instance of line strip primitive type
	 *
	 * @returns {vgl.lineStrip}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.lineStrip = function () {
	  'use strict';

	  if (!(this instanceof vgl.lineStrip)) {
	    return new vgl.lineStrip();
	  }
	  vgl.primitive.call(this);

	  this.setPrimitiveType(vgl.GL.LINE_STRIP);
	  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
	  this.setIndicesPerPrimitive(2);

	  return this;
	};
	inherit(vgl.lineStrip, vgl.primitive);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class points
	 *
	 * @returns {vgl.points}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.points = function () {
	  'use strict';

	  if (!(this instanceof vgl.points)) {
	    return new vgl.points();
	  }
	  vgl.primitive.call(this);

	  this.setPrimitiveType(vgl.GL.POINTS);
	  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
	  this.setIndicesPerPrimitive(1);

	  return this;
	};

	inherit(vgl.points, vgl.primitive);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class vertexDataP3f
	 *
	 * @returns {vgl.vertexDataP3f}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.vertexDataP3f = function () {
	  'use strict';

	  if (!(this instanceof vgl.vertexDataP3f)) {
	    return new vgl.vertexDataP3f();
	  }

	  /** @private */
	  this.m_position = [];

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class vertexDataP3N3f
	 *
	 * @class
	 * @returns {vgl.vertexDataP3N3f}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.vertexDataP3N3f = function () {
	  'use strict';

	  if (!(this instanceof vgl.vertexDataP3N3f)) {
	    return new vgl.vertexDataP3N3f();
	  }

	  this.m_position = [];
	  this.m_normal = [];

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class vertexDataP3T3f
	 *
	 * @class
	 * @returns {vgl.vertexDataP3T3f}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.vertexDataP3T3f = function () {
	  'use strict';

	  if (!(this instanceof vgl.vertexDataP3T3f)) {
	    return new vgl.vertexDataP3T3f();
	  }

	  this.m_position = [];
	  this.m_texCoordinate = [];

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceData
	 * @class
	 * @returns {vgl.sourceData}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceData = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceData)) {
	    return new vgl.sourceData(arg);
	  }

	  arg = arg || {};
	  var m_attributesMap = {},
	      m_data = [],
	      m_name = arg.name || 'Source ' + new Date().toISOString(),

	      ////////////////////////////////////////////////////////////////////////
	      /**
	       * Attribute data for the source
	       */
	      ////////////////////////////////////////////////////////////////////////
	      vglAttributeData = function () {
	        // Number of components per group
	        // Type of data type (GL_FLOAT etc)
	        this.m_numberOfComponents = 0;
	        // Size of data type
	        this.m_dataType = 0;
	        this.m_dataTypeSize = 0;
	        // Specifies whether fixed-point data values should be normalized
	        // (true) or converted directly as fixed-point values (false)
	        // when they are accessed.
	        this.m_normalized = false;
	        // Strides for each attribute.
	        this.m_stride = 0;
	        // Offset
	        this.m_offset = 0;
	      };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return raw data for this source
	   *
	   * @returns {Array or Float32Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.data = function () {
	    return m_data;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return raw data for this source
	   *
	   * @returns {Array or Float32Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getData = function () {
	    return this.data();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * If the raw data is not a Float32Array, convert it to one.  Then, return
	   * raw data for this source
	   *
	   * @returns {Float32Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.dataToFloat32Array = function () {
	    if (!(m_data instanceof Float32Array)) {
	      m_data = new Float32Array(m_data);
	    }
	    return m_data;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set data for this source
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setData = function (data) {
	    if (!(data instanceof Array) && !(data instanceof Float32Array)) {
	      console.log('[error] Requires array');
	      return;
	    }
	    if (data instanceof Float32Array) {
	      m_data = data;
	    } else {
	      m_data = data.slice(0);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add new attribute data to the source
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addAttribute = function (key, dataType, sizeOfDataType, offset, stride,
	                               noOfComponents, normalized) {

	    if (!m_attributesMap.hasOwnProperty(key)) {
	      /* jshint newcap: false */
	      //jscs:disable requireCapitalizedConstructors
	      var newAttr = new vglAttributeData();
	      //jscs:enable requireCapitalizedConstructors
	      /* jshint newcap: true */
	      newAttr.m_dataType = dataType;
	      newAttr.m_dataTypeSize = sizeOfDataType;
	      newAttr.m_offset = offset;
	      newAttr.m_stride = stride;
	      newAttr.m_numberOfComponents = noOfComponents;
	      newAttr.m_normalized = normalized;
	      m_attributesMap[key] = newAttr;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return size of the source data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.sizeOfArray = function () {
	    return Object.size(m_data);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return length of array
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.lengthOfArray = function () {
	    return m_data.length;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return size of the source data in bytes
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  /*
	    * TODO: code below is probably wrong.
	    *   Example:
	    *            format P3N3f
	    *            m_data = [ 1, 2, 3, 4, 5, 6 ]; // contains one vertex,
	    *                                    // one normal, m_data.length == 6
	    *
	    *       The inner loop computes:
	    *             sizeInBytes += 3 * 4; // for position
	    *             sizeInBytes += 3 * 4; // for normal
	    *
	    *        Then sizeInBytes *= 6; // m_data.length == 6
	    *        which gives sizeInBytes == 144 bytes when it should have been 4*6 = 24
	    */
	  this.sizeInBytes = function () {
	    var sizeInBytes = 0,
	        keys = this.keys(), i;

	    for (i = 0; i < keys.length; i += 1) {
	      sizeInBytes += this.attributeNumberOfComponents(keys[i]) *
	                     this.sizeOfAttributeDataType(keys[i]);
	    }

	    sizeInBytes *= this.sizeOfArray();

	    return sizeInBytes;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if there is attribute exists of a given key type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.hasKey = function (key) {
	    return m_attributesMap.hasOwnProperty(key);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return keys of all attributes
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.keys = function () {
	    return Object.keys(m_attributesMap);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return number of attributes of source data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.numberOfAttributes = function () {
	    return Object.size(m_attributesMap);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return number of components of the attribute data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.attributeNumberOfComponents = function (key) {
	    if (m_attributesMap.hasOwnProperty(key)) {
	      return m_attributesMap[key].m_numberOfComponents;
	    }

	    return 0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return if the attribute data is normalized
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.normalized = function (key) {
	    if (m_attributesMap.hasOwnProperty(key)) {
	      return m_attributesMap[key].m_normalized;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return size of the attribute data type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.sizeOfAttributeDataType = function (key) {
	    if (m_attributesMap.hasOwnProperty(key)) {
	      return m_attributesMap[key].m_dataTypeSize;
	    }

	    return 0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return attribute data type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.attributeDataType = function (key) {
	    if (m_attributesMap.hasOwnProperty(key)) {
	      return m_attributesMap[key].m_dataType;
	    }

	    return undefined;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return attribute offset
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.attributeOffset = function (key) {
	    if (m_attributesMap.hasOwnProperty(key)) {
	      return m_attributesMap[key].m_offset;
	    }

	    return 0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return attribute stride
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.attributeStride = function (key) {
	    if (m_attributesMap.hasOwnProperty(key)) {
	      return m_attributesMap[key].m_stride;
	    }

	    return 0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Virtual function to insert new vertex data at the end
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pushBack = function (vertexData) {
	    void vertexData;
	    // Should be implemented by the base class
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Insert new data block to the raw data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.insert = function (data) {
	    var i;

	    //m_data = m_data.concat(data); //no, slow on Safari
	    /* If we will are given a Float32Array and don't have any other data, use
	     * it directly. */
	    if (!m_data.length && data.length && data instanceof Float32Array) {
	      m_data = data;
	      return;
	    }
	    /* If our internal array is immutable and we will need to change it, create
	     * a regular mutable array from it. */
	    if (!m_data.slice && (m_data.length || !data.slice)) {
	      m_data = Array.prototype.slice.call(m_data);
	    }
	    if (!data.length) {
	      /* data is a singular value, so append it to our array */
	      m_data[m_data.length] = data;
	    } else {
	      /* We don't have any data currently, so it is faster to copy the data
	       * using slice. */
	      if (!m_data.length && data.slice) {
	        m_data = data.slice(0);
	      } else {
	        for (i = 0; i < data.length; i += 1) {
	          m_data[m_data.length] = data[i];
	        }
	      }
	    }
	  };

	  this.insertAt = function (index, data) {
	    var i;

	    if (!data.length) {
	      m_data[index] = data;
	    } else {
	      for (i = 0; i < data.length; i += 1) {
	        m_data[index * data.length + i] = data[i];
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return name of the source data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.name = function () {
	    return m_name;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set name of the source data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setName = function (name) {
	    m_name = name;
	  };

	  return this;
	};

	vgl.sourceDataAnyfv = function (size, key, arg) {
	  'use strict';
	  if (!(this instanceof vgl.sourceDataAnyfv)) {
	    return new vgl.sourceDataAnyfv(size, key, arg);
	  }

	  vgl.sourceData.call(this, arg);
	  this.addAttribute(key, vgl.GL.FLOAT,
	                    4, 0, size * 4, size, false);

	  this.pushBack = function (value) {
	    this.insert(value);
	  };

	  return this;
	};
	inherit(vgl.sourceDataAnyfv, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataP3T3f
	 *
	 * @returns {vgl.sourceDataP3T3f}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataP3T3f = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataP3T3f)) {
	    return new vgl.sourceDataP3T3f(arg);
	  }
	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.Position, vgl.GL.FLOAT, 4, 0, 6 * 4, 3,
	                    false);
	  this.addAttribute(vgl.vertexAttributeKeys.TextureCoordinate, vgl.GL.FLOAT, 4, 12,
	                    6 * 4, 3, false);

	  this.pushBack = function (value) {
	    this.insert(value.m_position);
	    this.insert(value.m_texCoordinate);
	  };

	  return this;
	};

	inherit(vgl.sourceDataP3T3f, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataP3N3f
	 *
	 * @returns {vgl.sourceDataP3N3f}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataP3N3f = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataP3N3f)) {
	    return new vgl.sourceDataP3N3f(arg);
	  }

	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.Position, vgl.GL.FLOAT, 4, 0, 6 * 4, 3,
	                    false);
	  this.addAttribute(vgl.vertexAttributeKeys.Normal, vgl.GL.FLOAT, 4, 12, 6 * 4, 3,
	                    false);

	  this.pushBack = function (value) {
	    this.insert(value.m_position);
	    this.insert(value.m_normal);
	  };

	  return this;
	};

	inherit(vgl.sourceDataP3N3f, vgl.sourceData);

	/////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataP3fv
	 *
	 * @returns {vgl.sourceDataP3fv}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataP3fv = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataP3fv)) {
	    return new vgl.sourceDataP3fv(arg);
	  }

	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.Position, vgl.GL.FLOAT, 4, 0, 3 * 4, 3,
	                    false);

	  this.pushBack = function (value) {
	    this.insert(value);
	  };

	  return this;
	};

	inherit(vgl.sourceDataP3fv, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataT2fv
	 *
	 * @returns {vgl.sourceDataT2fv}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataT2fv = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataT2fv)) {
	    return new vgl.sourceDataT2fv(arg);
	  }

	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.TextureCoordinate, vgl.GL.FLOAT, 4, 0,
	                    2 * 4, 2, false);

	  this.pushBack = function (value) {
	    this.insert(value);
	  };

	  return this;
	};

	inherit(vgl.sourceDataT2fv, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataC3fv
	 *
	 * @returns {vgl.sourceDataC3fv}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataC3fv = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataC3fv)) {
	    return new vgl.sourceDataC3fv(arg);
	  }

	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.Color, vgl.GL.FLOAT, 4, 0, 3 * 4, 3, false);

	  this.pushBack = function (value) {
	    this.insert(value);
	  };

	  return this;
	};

	inherit(vgl.sourceDataC3fv, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataSf meant to hold scalar float values
	 *
	 * @class
	 * @returns {vgl.sourceDataSf}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataSf = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataSf)) {
	    return new vgl.sourceDataSf(arg);
	  }

	  var m_min = null,
	      m_max = null,
	      m_fixedmin = null,
	      m_fixedmax = null;

	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.Scalar, vgl.GL.FLOAT, 4, 0, 4, 1, false);

	  this.pushBack = function (value) {
	    if (m_max === null || value > m_max) {
	      m_max = value;
	    }
	    if (m_min === null || value < m_min) {
	      m_min = value;
	    }
	    //this.insert(value); //no, slow on Safari
	    this.data()[this.data().length] = value;
	  };

	  this.insertAt = function (index, value) {
	    if (m_max === null || value > m_max) {
	      m_max = value;
	    }
	    if (m_min === null || value < m_min) {
	      m_min = value;
	    }
	    //call superclass ??
	    //vgl.sourceData.insertAt.call(this, index, value);
	    this.data()[index] = value;
	  };

	  this.scalarRange = function () {
	    if (m_fixedmin === null || m_fixedmax === null) {
	      return [m_min, m_max];
	    }

	    return [m_fixedmin, m_fixedmax];
	  };

	  this.setScalarRange = function (min, max) {
	    m_fixedmin = min;
	    m_fixedmax = max;
	  };

	  return this;
	};

	inherit(vgl.sourceDataSf, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sourceDataDf meant to hold data float values
	 *
	 * This source array is the best way to pass a array of floats to the shader
	 * that has one entry for each of the vertices.
	 *
	 * @class
	 * @returns {vgl.sourceDataDf}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.sourceDataDf = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.sourceDataDf)) {
	    return new vgl.sourceDataDf(arg);
	  }

	  vgl.sourceData.call(this, arg);

	  this.addAttribute(vgl.vertexAttributeKeys.Scalar, vgl.GL.FLOAT,
	                    4, 0, 4, 1, false);

	  this.pushBack = function (value) {
	    this.data()[this.data().length] = value;
	  };

	  this.insertAt = function (index, value) {
	    this.data()[index] = value;
	  };

	  return this;
	};

	inherit(vgl.sourceDataDf, vgl.sourceData);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class geometryData
	 *
	 * @class
	 * @returns {vgl.geometryData}
	 */
	/////////////////////////////////////////////////////////////////////////////
	vgl.geometryData = function () {
	  'use strict';

	  if (!(this instanceof vgl.geometryData)) {
	    return new vgl.geometryData();
	  }
	  vgl.data.call(this);

	  /** @private */
	  var m_name = '',
	      m_primitives = [],
	      m_sources = [],
	      m_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
	      m_computeBoundsTimestamp = vgl.timestamp(),
	      m_boundsDirtyTimestamp = vgl.timestamp();

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return type
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.type = function () {
	    return vgl.data.geometry;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return ID of the geometry data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.name = function () {
	    return m_name;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set name of the geometry data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setName = function (name) {
	    m_name = name;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add new source
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addSource = function (source, sourceName) {
	    // @todo Check if the incoming source has duplicate keys

	    if (sourceName !== undefined) {
	      source.setName(sourceName);
	    }
	    // NOTE This might not work on IE8 or lower
	    if (m_sources.indexOf(source) === -1) {
	      m_sources.push(source);

	      if (source.hasKey(vgl.vertexAttributeKeys.Position)) {
	        m_boundsDirtyTimestamp.modified();
	      }
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return source for a given index. Returns 0 if not found.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.source = function (index) {
	    if (index < m_sources.length) {
	      return m_sources[index];
	    }

	    return 0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return source with a specified name.  Returns 0 if not found.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.sourceByName = function (sourceName) {
	    for (var i = 0; i < m_sources.length; i += 1) {
	      if (m_sources[i].name() === sourceName) {
	        return m_sources[i];
	      }
	    }
	    return 0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return number of sources
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.numberOfSources = function () {
	    return m_sources.length;
	  };

	  /**
	   * Return source data given a key
	   */
	  this.sourceData = function (key) {
	    var i;

	    for (i = 0; i < m_sources.length; i += 1) {
	      if (m_sources[i].hasKey(key)) {
	        return m_sources[i];
	      }
	    }

	    return null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add new primitive
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addPrimitive = function (primitive) {
	    m_primitives.push(primitive);
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return primitive for a given index. Returns null if not found.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.primitive = function (index) {
	    if (index < m_primitives.length) {
	      return m_primitives[index];
	    }

	    return null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return number of primitives
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.numberOfPrimitives = function () {
	    return m_primitives.length;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return bounds [minX, maxX, minY, maxY, minZ, maxZ]
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bounds = function () {
	    if (m_boundsDirtyTimestamp.getMTime() > m_computeBoundsTimestamp.getMTime()) {
	      this.computeBounds();
	    }
	    return m_bounds;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if bounds are dirty or mark them as such.
	   *
	   * @param dirty: true to set bounds as dirty.
	   * Return true if bounds are dirty.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.boundsDirty = function (dirty) {
	    if (dirty) {
	      m_boundsDirtyTimestamp.modified();
	    }
	    return m_boundsDirtyTimestamp.getMTime() > m_computeBoundsTimestamp.getMTime();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Reset bounds
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resetBounds = function () {
	    m_bounds[0] = 0.0;
	    m_bounds[1] = 0.0;
	    m_bounds[2] = 0.0;
	    m_bounds[3] = 0.0;
	    m_bounds[4] = 0.0;
	    m_bounds[5] = 0.0;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set bounds
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setBounds = function (minX, maxX, minY, maxY, minZ, maxZ) {
	    m_bounds[0] = minX;
	    m_bounds[1] = maxX;
	    m_bounds[2] = minY;
	    m_bounds[3] = maxY;
	    m_bounds[4] = minZ;
	    m_bounds[5] = maxZ;

	    m_computeBoundsTimestamp.modified();

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute bounds
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBounds = function () {
	    if (m_boundsDirtyTimestamp.getMTime() > m_computeBoundsTimestamp.getMTime()) {
	      var attr = vgl.vertexAttributeKeys.Position,
	          sourceData = this.sourceData(attr),
	          data = sourceData.data(),
	          numberOfComponents = sourceData.attributeNumberOfComponents(attr),
	          stride = sourceData.attributeStride(attr),
	          offset = sourceData.attributeOffset(attr),
	          sizeOfDataType = sourceData.sizeOfAttributeDataType(attr),
	          count = data.length,
	          j, ib, jb, maxv, minv,
	          value = null,
	          vertexIndex;

	      // We advance by index, not by byte
	      stride /= sizeOfDataType;
	      offset /= sizeOfDataType;

	      this.resetBounds();

	      for (j = 0; j < numberOfComponents; j += 1) {
	        ib = j * 2;
	        jb = j * 2 + 1;
	        if (count) {
	          maxv = minv = m_bounds[jb] = data[offset + j];
	        } else {
	          maxv = minv = 0;
	        }
	        for (vertexIndex = offset + stride + j; vertexIndex < count;
	             vertexIndex += stride) {
	          value = data[vertexIndex];
	          if (value > maxv) {
	            maxv = value;
	          }
	          if (value < minv) {
	            minv = value;
	          }
	        }
	        m_bounds[ib] = minv; m_bounds[jb] = maxv;
	      }

	      m_computeBoundsTimestamp.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns the vertex closest to a given position
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.findClosestVertex = function (point) {
	    var attr = vgl.vertexAttributeKeys.Position,
	        sourceData = this.sourceData(attr),
	        sizeOfDataType = sourceData.sizeOfAttributeDataType(attr),
	        numberOfComponents = sourceData.attributeNumberOfComponents(attr),
	        data = sourceData.data(),
	        stride = sourceData.attributeStride(attr) / sizeOfDataType,
	        offset = sourceData.attributeOffset(attr) / sizeOfDataType,
	        minDist = Number.MAX_VALUE,
	        minIndex = null,
	        vi, vPos, dx, dy, dz, dist, i;

	    // assume positions are always triplets
	    if (numberOfComponents !== 3) {
	      console.log('[warning] Find closest vertex assumes three' +
	        'component vertex ');
	    }

	    if (!point.z) {
	      point = {x: point.x, y: point.y, z: 0};
	    }

	    for (vi = offset, i = 0; vi < data.length; vi += stride, i += 1) {
	      vPos = [data[vi],
	              data[vi + 1],
	              data[vi + 2]];

	      dx = vPos[0] - point.x;
	      dy = vPos[1] - point.y;
	      dz = vPos[2] - point.z;
	      dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
	      if (dist < minDist) {
	        minDist = dist;
	        minIndex = i;
	      }
	    }
	    return minIndex;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns the requested vertex position
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getPosition = function (index) {
	    var attr = vgl.vertexAttributeKeys.Position,
	        sourceData = this.sourceData(attr),
	        sizeOfDataType = sourceData.sizeOfAttributeDataType(attr),
	        numberOfComponents = sourceData.attributeNumberOfComponents(attr),
	        data = sourceData.data(),
	        stride = sourceData.attributeStride(attr) / sizeOfDataType,
	        offset = sourceData.attributeOffset(attr) / sizeOfDataType;

	    // assume positions are always triplets
	    if (numberOfComponents !== 3) {
	      console.log('[warning] getPosition assumes three component data');
	    }

	    return [data[offset + index * stride],
	            data[offset + index * stride + 1],
	            data[offset + index * stride + 2]];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns the scalar corresponding to a given vertex index
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getScalar = function (index) {
	    var attr = vgl.vertexAttributeKeys.Scalar,
	        sourceData = this.sourceData(attr),
	        sizeOfDataType, data, stride, offset;

	    if (!sourceData) {
	      return null;
	    }

	    sizeOfDataType = sourceData.sizeOfAttributeDataType(attr);
	    data = sourceData.data();
	    stride = sourceData.attributeStride(attr) / sizeOfDataType;
	    offset = sourceData.attributeOffset(attr) / sizeOfDataType;

	    if (index * stride + offset >= data.length) {
	      console.log('access out of bounds in getScalar');
	    }

	    return data[index * stride + offset];
	  };

	  return this;
	};

	inherit(vgl.geometryData, vgl.data);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, Float32Array, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class mapper
	 *
	 * @class
	 * @returns {vgl.mapper}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.mapper = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.mapper)) {
	    return new vgl.mapper(arg);
	  }
	  vgl.boundingObject.call(this);

	  /** @private */
	  arg = arg || {};

	  var m_color = [0.0, 1.0, 1.0],
	      m_geomData = null,
	      m_buffers = [],
	      m_bufferVertexAttributeMap = {},
	      m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
	      m_glCompileTimestamp = vgl.timestamp(),
	      m_context = null,
	      m_this = this;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete cached VBO if any
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.deleteVertexBufferObjects = function (renderState) {
	    var i;
	    var context = m_context;
	    if (renderState) {
	      context = renderState.m_context;
	    }
	    if (context) {
	      for (i = 0; i < m_buffers.length; i += 1) {
	        context.deleteBuffer(m_buffers[i]);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create new VBO for all its geometryData sources and primitives
	   *
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function createVertexBufferObjects(renderState) {
	    if (m_geomData) {
	      if (renderState) {
	        m_context = renderState.m_context;
	      }
	      var numberOfSources = m_geomData.numberOfSources(),
	          i, j, k, bufferId = null, keys, ks, numberOfPrimitives, data;

	      for (i = 0; i < numberOfSources; i += 1) {
	        bufferId = m_context.createBuffer();
	        m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, bufferId);
	        data = m_geomData.source(i).data();
	        if (!(data instanceof Float32Array)) {
	          data = new Float32Array(data);
	        }
	        m_context.bufferData(vgl.GL.ARRAY_BUFFER, data,
	                      m_dynamicDraw ? vgl.GL.DYNAMIC_DRAW :
	                      vgl.GL.STATIC_DRAW);

	        keys = m_geomData.source(i).keys();
	        ks = [];

	        for (j = 0; j < keys.length; j += 1) {
	          ks.push(keys[j]);
	        }

	        m_bufferVertexAttributeMap[i] = ks;
	        m_buffers[i] = bufferId;
	      }

	      numberOfPrimitives = m_geomData.numberOfPrimitives();
	      for (k = 0; k < numberOfPrimitives; k += 1) {
	        bufferId = m_context.createBuffer();
	        m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, bufferId);
	        m_context.bufferData(vgl.GL.ARRAY_BUFFER,
	          m_geomData.primitive(k).indices(), vgl.GL.STATIC_DRAW);
	        m_buffers[i] = bufferId;
	        i += 1;
	      }

	      m_glCompileTimestamp.modified();
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Clear cache related to buffers
	   *
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function cleanUpDrawObjects(renderState) {
	    void renderState;
	    m_bufferVertexAttributeMap = {};
	    m_buffers = [];
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Setup draw objects; Delete old ones and create new ones
	   *
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function setupDrawObjects(renderState) {
	    // Delete buffer objects from past if any.
	    m_this.deleteVertexBufferObjects(renderState);

	    // Clear any cache related to buffers
	    cleanUpDrawObjects(renderState);

	    // Now construct the new ones.
	    createVertexBufferObjects(renderState);
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute bounds of the data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBounds = function () {
	    if (m_geomData === null || typeof m_geomData === 'undefined') {
	      this.resetBounds();
	      return;
	    }

	    var computeBoundsTimestamp = this.computeBoundsTimestamp(),
	        boundsDirtyTimestamp = this.boundsDirtyTimestamp(),
	        geomBounds = null;

	    if (boundsDirtyTimestamp.getMTime() > computeBoundsTimestamp.getMTime()) {
	      geomBounds = m_geomData.bounds();

	      this.setBounds(geomBounds[0], geomBounds[1], geomBounds[2],
	        geomBounds[3], geomBounds[4], geomBounds[5]);

	      computeBoundsTimestamp.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get solid color of the geometry
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.color = function () {
	    return m_color;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set solid color of the geometry. Default is teal [1.0, 1.0, 1.0]
	   *
	   * @param r Red component of the color [0.0 - 1.0]
	   * @param g Green component of the color [0.0 - 1.0]
	   * @param b Blue component of the color [0.0 - 1.0]
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setColor = function (r, g, b) {
	    m_color[0] = r;
	    m_color[1] = g;
	    m_color[2] = b;

	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return stored geometry data if any
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.geometryData = function () {
	    return m_geomData;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Connect mapper to its geometry data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setGeometryData = function (geom) {
	    if (m_geomData !== geom) {
	      m_geomData = geom;

	      this.modified();
	      this.boundsDirtyTimestamp().modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the buffer used for a named source.
	   *
	   * @param {String} sourceName The name of the source to update.
	   * @param {Object[] or Float32Array} values The values to use for the source.
	   *    If not specified, use the source's own buffer.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateSourceBuffer = function (sourceName, values, renderState) {
	    if (renderState) {
	      m_context = renderState.m_context;
	    }
	    if (!m_context) {
	      return false;
	    }
	    var bufferIndex = -1;
	    for (var i = 0; i < m_geomData.numberOfSources(); i += 1) {
	      if (m_geomData.source(i).name() === sourceName) {
	        bufferIndex = i;
	        break;
	      }
	    }
	    if (bufferIndex < 0 || bufferIndex >= m_buffers.length) {
	      return false;
	    }
	    if (!values) {
	      values = m_geomData.source(i).dataToFloat32Array();
	    }
	    m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_buffers[bufferIndex]);
	    if (values instanceof Float32Array) {
	      m_context.bufferSubData(vgl.GL.ARRAY_BUFFER, 0, values);
	    } else {
	      m_context.bufferSubData(vgl.GL.ARRAY_BUFFER, 0,
	                              new Float32Array(values));
	    }
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the buffer used for a named source.  If the current buffer isn't a
	   * Float32Array, it is converted to one.  This array can then be modified
	   * directly, after which updateSourceBuffer can be called to update the
	   * GL array.
	   *
	   * @param {String} sourceName The name of the source to update.
	   * @returns {Float32Array} An array used for this source.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getSourceBuffer = function (sourceName) {
	    var source = m_geomData.sourceByName(sourceName);
	    if (!source) {
	      return new Float32Array();
	    }
	    return source.dataToFloat32Array();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the mapper
	   *
	   * @param {object} renderState: the current renderering state object.
	   * @param {boolean} noUndoBindVertexData: if true, do not unbind vertex data.
	   *    This may be desirable if the render function is subclassed.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function (renderState, noUndoBindVertexData) {
	    if (this.getMTime() > m_glCompileTimestamp.getMTime() ||
	        renderState.m_contextChanged) {
	      setupDrawObjects(renderState);
	    }
	    m_context = renderState.m_context;

	    // Fixed vertex color
	    m_context.vertexAttrib3fv(vgl.vertexAttributeKeys.Color, this.color());

	    // TODO Use renderState
	    var bufferIndex = 0,
	        j = 0, i, noOfPrimitives = null, primitive = null;

	    for (i in m_bufferVertexAttributeMap) {
	      if (m_bufferVertexAttributeMap.hasOwnProperty(i)) {
	        m_context.bindBuffer(vgl.GL.ARRAY_BUFFER,
	                             m_buffers[bufferIndex]);
	        for (j = 0; j < m_bufferVertexAttributeMap[i].length; j += 1) {
	          renderState.m_material
	              .bindVertexData(renderState, m_bufferVertexAttributeMap[i][j]);
	        }
	        bufferIndex += 1;
	      }
	    }

	    noOfPrimitives = m_geomData.numberOfPrimitives();
	    for (j = 0; j < noOfPrimitives; j += 1, bufferIndex += 1) {
	      primitive = m_geomData.primitive(j);
	      if (!primitive.numberOfIndices()) {
	        continue;
	      }
	      m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_buffers[bufferIndex]);
	      switch (primitive.primitiveType()) {
	        case vgl.GL.POINTS:
	          m_context.drawArrays(vgl.GL.POINTS, 0, primitive.numberOfIndices());
	          break;
	        case vgl.GL.LINES:
	          m_context.drawArrays(vgl.GL.LINES, 0, primitive.numberOfIndices());
	          break;
	        case vgl.GL.LINE_STRIP:
	          m_context.drawArrays(vgl.GL.LINE_STRIP, 0, primitive.numberOfIndices());
	          break;
	        case vgl.GL.TRIANGLES:
	          m_context.drawArrays(vgl.GL.TRIANGLES, 0, primitive.numberOfIndices());
	          break;
	        case vgl.GL.TRIANGLE_STRIP:
	          m_context.drawArrays(vgl.GL.TRIANGLE_STRIP, 0, primitive.numberOfIndices());
	          break;
	      }
	      m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, null);
	    }

	    /* If we are rendering multiple features in the same context, we must
	     * unbind the vertex data to make sure the next feature has a known state.
	     * This is optional.
	     */
	    if (!noUndoBindVertexData) {
	      this.undoBindVertexData(renderState);
	    }
	  };

	  /**
	   * Unbind the vertex data,
	   */
	  this.undoBindVertexData = function (renderState) {
	    var i, j;

	    for (i in m_bufferVertexAttributeMap) {
	      if (m_bufferVertexAttributeMap.hasOwnProperty(i)) {
	        for (j = 0; j < m_bufferVertexAttributeMap[i].length; j += 1) {
	          renderState.m_material
	              .undoBindVertexData(renderState, m_bufferVertexAttributeMap[i][j]);
	        }
	      }
	    }
	  };

	  return this;
	};

	inherit(vgl.mapper, vgl.boundingObject);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	vgl.groupMapper = function () {
	  'use strict';

	  if (!(this instanceof vgl.groupMapper)) {
	    return new vgl.groupMapper();
	  }
	  vgl.mapper.call(this);

	  /** @private */
	  var m_createMappersTimestamp = vgl.timestamp(),
	      m_mappers = [],
	      m_geomDataArray = [];

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return stored geometry data if any
	   *
	   * @param index optional
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.geometryData = function (index) {
	    if (index !== undefined && index < m_geomDataArray.length) {
	      return m_geomDataArray[index];
	    }

	    if (m_geomDataArray.length > 0) {
	      return m_geomDataArray[0];
	    }

	    return null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Connect mapper to its geometry data
	   *
	   * @param geom {vgl.geomData}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setGeometryData = function (geom) {
	    if (m_geomDataArray.length === 1) {
	      if (m_geomDataArray[0] === geom) {
	        return;
	      }
	    }
	    m_geomDataArray = [];
	    m_geomDataArray.push(geom);
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return stored geometry data array if any
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.geometryDataArray = function () {
	    return m_geomDataArray;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Connect mapper to its geometry data
	   *
	   * @param geoms {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setGeometryDataArray = function (geoms) {
	    if (geoms instanceof Array) {
	      if (m_geomDataArray !== geoms) {
	        m_geomDataArray = [];
	        m_geomDataArray = geoms;
	        this.modified();
	        return true;
	      }
	    } else {
	      console.log('[error] Requies array of geometry data');
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute bounds of the data
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeBounds = function () {
	    if (m_geomDataArray === null ||
	        m_geomDataArray === undefined) {
	      this.resetBounds();
	      return;
	    }

	    var computeBoundsTimestamp = this.computeBoundsTimestamp(),
	        boundsDirtyTimestamp = this.boundsDirtyTimestamp(),
	        m_bounds = this.bounds(),
	        geomBounds = null,
	        i = null;

	    if (boundsDirtyTimestamp.getMTime() >
	        computeBoundsTimestamp.getMTime()) {

	      for (i = 0; i < m_geomDataArray.length; i += 1) {
	        geomBounds = m_geomDataArray[i].bounds();

	        if (m_bounds[0] > geomBounds[0]) {
	          m_bounds[0] = geomBounds[0];
	        }
	        if (m_bounds[1] < geomBounds[1]) {
	          m_bounds[1] = geomBounds[1];
	        }
	        if (m_bounds[2] > geomBounds[2]) {
	          m_bounds[2] = geomBounds[2];
	        }
	        if (m_bounds[3] < geomBounds[3]) {
	          m_bounds[3] = geomBounds[3];
	        }
	        if (m_bounds[4] > geomBounds[4]) {
	          m_bounds[4] = geomBounds[4];
	        }
	        if (m_bounds[5] < geomBounds[5]) {
	          m_bounds[5] = geomBounds[5];
	        }
	      }

	      this.modified();
	      computeBoundsTimestamp.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the mapper
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function (renderState) {
	    var i = null;

	    if (this.getMTime() > m_createMappersTimestamp.getMTime()) {
	      // NOTE Hoping that it will release the graphics resources
	      for (i = 0; i < m_geomDataArray.length; i += 1) {
	        m_mappers.push(vgl.mapper());
	        m_mappers[i].setGeometryData(m_geomDataArray[i]);
	      }
	      m_createMappersTimestamp.modified();
	    }

	    for (i = 0; i < m_mappers.length; i += 1) {
	      m_mappers[i].render(renderState);
	    }
	  };

	  return this;
	};

	inherit(vgl.groupMapper, vgl.mapper);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	vgl.materialAttributeType = {
	  'Undefined' : 0x0,
	  'ShaderProgram' : 0x1,
	  'Texture' : 0x2,
	  'Blend' : 0x3,
	  'Depth' : 0x4
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class materialAttribute
	 *
	 * @class
	 * @param type
	 * @returns {vgl.materialAttribute}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.materialAttribute = function (type) {
	  'use strict';

	  if (!(this instanceof vgl.materialAttribute)) {
	    return new vgl.materialAttribute(type);
	  }
	  vgl.graphicsObject.call(this);

	  /** @private */
	  var m_this = this,
	      m_type = type,
	      m_enabled = true;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return tyep of the material attribute
	   *
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.type = function () {
	    return m_type;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return if material attribute is enabled or not
	   *
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.enabled = function () {
	    return m_enabled;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind and activate vertex specific data
	   *
	   * @param renderState
	   * @param key
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bindVertexData = function (renderState, key) {
	    renderState = renderState; /* unused parameter */
	    key = key; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo bind and deactivate vertex specific data
	   *
	   * @param renderState
	   * @param key
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.undoBindVertexData = function (renderState, key) {
	    renderState = renderState; /* unused parameter */
	    key = key; /* unused parameter */
	    return false;
	  };

	  return m_this;
	};

	inherit(vgl.materialAttribute, vgl.graphicsObject);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of clas blendFunction
	 *
	 * @class
	 * @param source
	 * @param destination
	 * @returns {vgl.blendFunction}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.blendFunction = function (source, destination) {
	  'use strict';

	  if (!(this instanceof vgl.blendFunction)) {
	    return new vgl.blendFunction(source, destination);
	  }

	  /** @private */
	  var m_source = source,
	      m_destination = destination;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Apply blend function to the current state
	   *
	   * @param {vgl.renderState}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.apply = function (renderState) {
	    renderState.m_context.blendFuncSeparate(m_source, m_destination,
	                         vgl.GL.ONE, vgl.GL.ONE_MINUS_SRC_ALPHA);
	  };

	  return this;
	};

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class blend
	 *
	 * @returns {vgl.blend}
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.blend = function () {
	  'use strict';

	  if (!(this instanceof vgl.blend)) {
	    return new vgl.blend();
	  }
	  vgl.materialAttribute.call(
	    this, vgl.materialAttributeType.Blend);

	  /** @private */
	  var m_wasEnabled = false,
	      m_blendFunction = vgl.blendFunction(vgl.GL.SRC_ALPHA,
	                                          vgl.GL.ONE_MINUS_SRC_ALPHA);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind blend attribute
	   *
	   * @param {vgl.renderState}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bind = function (renderState) {
	    m_wasEnabled = renderState.m_context.isEnabled(vgl.GL.BLEND);

	    if (this.enabled()) {
	      renderState.m_context.enable(vgl.GL.BLEND);
	      m_blendFunction.apply(renderState);
	    } else {
	      renderState.m_context.disable(vgl.GL.BLEND);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo bind blend attribute
	   *
	   * @param {vgl.renderState}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.undoBind = function (renderState) {
	    if (m_wasEnabled) {
	      renderState.m_context.enable(vgl.GL.BLEND);
	    } else {
	      renderState.m_context.disable(vgl.GL.BLEND);
	    }

	    return true;
	  };

	  return this;
	};

	inherit(vgl.blend, vgl.materialAttribute);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class material
	 *
	 * @class
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.material = function () {
	  'use strict';

	  if (!(this instanceof vgl.material)) {
	    return new vgl.material();
	  }
	  vgl.graphicsObject.call(this);

	  // / Private member variables
	  var m_this = this,
	      m_shaderProgram = new vgl.shaderProgram(),
	      m_binNumber = 100,
	      m_textureAttributes = {},
	      m_attributes = {};

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return bin number for the material
	   *
	   * @default 100
	   * @returns {number}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.binNumber = function () {
	    return m_binNumber;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set bin number for the material
	   *
	   * @param binNo
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setBinNumber = function (binNo) {
	    m_binNumber = binNo;
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if incoming attribute already exists in the material
	   *
	   * @param attr
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.exists = function (attr) {
	    if (attr.type() === vgl.materialAttributeType.Texture) {
	      return m_textureAttributes.hasOwnProperty(attr.textureUnit());
	    }
	    return m_attributes.hasOwnProperty(attr.type());
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get uniform given a name

	   * @param name Uniform name
	   * @returns {vgl.uniform}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.uniform = function (name) {
	    return m_shaderProgram ? m_shaderProgram.uniform(name) : null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get material attribute

	   * @param {number} type attribute type
	   * @param {number} textureUnit attribute texture unit if type is Texture.
	   * @returns {vgl.materialAttribute}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.attribute = function (type, textureUnit) {
	    if (m_attributes.hasOwnProperty(type)) {
	      return m_attributes[type];
	    }

	    if (type === vgl.materialAttributeType.Texture && m_textureAttributes.hasOwnProperty(textureUnit)) {
	      return m_textureAttributes[textureUnit];
	    }

	    return null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set a new attribute for the material
	   *
	   * This method replace any existing attribute except for textures as
	   * materials can have multiple textures.
	   *
	   * @param attr
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setAttribute = function (attr) {
	    if (attr.type() === vgl.materialAttributeType.Texture) {
	      if (m_textureAttributes[attr.textureUnit()] === attr) {
	        return false;
	      }
	      m_textureAttributes[attr.textureUnit()] = attr;
	      m_this.modified();
	      return true;
	    }

	    if (m_attributes[attr.type()] === attr) {
	      return false;
	    }

	    // Shader is a very special attribute
	    if (attr.type() === vgl.materialAttributeType.ShaderProgram) {
	      m_shaderProgram = attr;
	    }

	    m_attributes[attr.type()] = attr;
	    m_this.modified();
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add a new attribute to the material.
	   *
	   * @param attr
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addAttribute = function (attr) {
	    if (m_this.exists(attr)) {
	      return false;
	    }

	    if (attr.type() === vgl.materialAttributeType.Texture) {
	      // TODO Currently we don't check if we are replacing or not.
	      // It would be nice to have a flag for it.
	      m_textureAttributes[attr.textureUnit()] = attr;
	      m_this.modified();
	      return true;
	    }

	    // Shader is a very special attribute
	    if (attr.type() === vgl.materialAttributeType.ShaderProgram) {
	      m_shaderProgram = attr;
	    }

	    m_attributes[attr.type()] = attr;
	    m_this.modified();
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return shader program used by the material
	   *
	   * @returns {vgl.shaderProgram}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.shaderProgram = function () {
	    return m_shaderProgram;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Setup (initialize) the material attribute
	   *
	   * @param renderState
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._setup = function (renderState) {
	    void renderState; /* unused parameter */
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove any resources acquired before deletion
	   *
	   * @param renderState
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._cleanup = function (renderState) {
	    for (var key in m_attributes) {
	      if (m_attributes.hasOwnProperty(key)) {
	        m_attributes[key]._cleanup(renderState);
	      }
	    }

	    for (key in m_textureAttributes) {
	      if (m_textureAttributes.hasOwnProperty(key)) {
	        m_textureAttributes[key]._cleanup(renderState);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind and activate material states
	   *
	   * @param renderState
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bind = function (renderState) {
	    var key = null;

	    m_shaderProgram.bind(renderState);

	    for (key in m_attributes) {
	      if (m_attributes.hasOwnProperty(key)) {
	        if (m_attributes[key] !== m_shaderProgram) {
	          m_attributes[key].bind(renderState);
	        }
	      }
	    }

	    for (key in m_textureAttributes) {
	      if (m_textureAttributes.hasOwnProperty(key)) {
	        m_textureAttributes[key].bind(renderState);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo-bind and de-activate material states
	   *
	   * @param renderState
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.undoBind = function (renderState) {
	    var key = null;
	    for (key in m_attributes) {
	      if (m_attributes.hasOwnProperty(key)) {
	        m_attributes[key].undoBind(renderState);
	      }
	    }

	    for (key in m_textureAttributes) {
	      if (m_textureAttributes.hasOwnProperty(key)) {
	        m_textureAttributes[key].undoBind(renderState);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind vertex data
	   *
	   * @param renderState
	   * @param key
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bindVertexData = function (renderState, key) {
	    var i = null;

	    for (i in m_attributes) {
	      if (m_attributes.hasOwnProperty(i)) {
	        m_attributes[i].bindVertexData(renderState, key);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo bind vertex data
	   *
	   * @param renderState
	   * @param key
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.undoBindVertexData = function (renderState, key) {
	    var i = null;

	    for (i in m_attributes) {
	      if (m_attributes.hasOwnProperty(i)) {
	        m_attributes[i].undoBindVertexData(renderState, key);
	      }
	    }
	  };

	  return m_this;
	};

	vgl.material.RenderBin = {
	  'Base' : 0,
	  'Default' : 100,
	  'Opaque' : 100,
	  'Transparent' : 1000,
	  'Overlay' : 10000
	};

	inherit(vgl.material, vgl.graphicsObject);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec2, vec3, vec4, mat4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class renderState
	 *
	 * @returns {vgl.renderState}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.renderState = function () {
	  'use strict';

	  this.m_context = null;
	  this.m_modelViewMatrix = mat4.create();
	  this.m_normalMatrix = mat4.create();
	  this.m_projectionMatrix = null;
	  this.m_material = null;
	  this.m_mapper = null;
	};

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class renderer *
	 *
	 * @returns {vgl.renderer}
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.renderer = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.renderer)) {
	    return new vgl.renderer(arg);
	  }
	  vgl.graphicsObject.call(this);
	  arg = arg || {};

	  /** @private */
	  var m_this = this;
	  m_this.m_renderWindow = null;
	  m_this.m_contextChanged = false;
	  m_this.m_sceneRoot = new vgl.groupNode();
	  m_this.m_camera = new vgl.camera(arg);
	  m_this.m_nearClippingPlaneTolerance = null;
	  m_this.m_x = 0;
	  m_this.m_y = 0;
	  m_this.m_width = 0;
	  m_this.m_height = 0;
	  m_this.m_resizable = true;
	  m_this.m_resetScene = true;
	  m_this.m_layer = 0;
	  m_this.m_renderPasses = null;
	  m_this.m_resetClippingRange = true;
	  m_this.m_depthBits = null;

	  m_this.m_camera.addChild(m_this.m_sceneRoot);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get width of the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.width = function () {
	    return m_this.m_width;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get height of the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.height = function () {
	    return m_this.m_height;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get layer this renderer is associated with
	   *
	   * @return {Number}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.layer = function () {
	    return m_this.m_layer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set the layer this renderer is associated with.
	   *
	   * @param layerNo
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setLayer = function (layerNo) {
	    m_this.m_layer = layerNo;
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.isResizable = function () {
	    return m_this.m_resizable;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setResizable = function (r) {
	    m_this.m_resizable = r;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return render window (owner) of the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.renderWindow = function () {
	    return m_this.m_renderWindow;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set render window for the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setRenderWindow = function (renWin) {
	    if (m_this.m_renderWindow !== renWin) {
	      if (m_this.m_renderWindow) {
	        m_this.m_renderWindow.removeRenderer(this);
	      }
	      m_this.m_renderWindow = renWin;
	      m_this.m_contextChanged = true;
	      m_this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get background color
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.backgroundColor = function () {
	    return m_this.m_camera.clearColor();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set background color of the renderer
	   *
	   * @param r
	   * @param g
	   * @param b
	   * @param a
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setBackgroundColor = function (r, g, b, a) {
	    m_this.m_camera.setClearColor(r, g, b, a);
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get scene root
	   *
	   * @returns {vgl.groupNode}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.sceneRoot = function () {
	    return m_this.m_sceneRoot;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get main camera of the renderer
	   *
	   * @returns {vgl.camera}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.camera = function () {
	    return m_this.m_camera;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the scene
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function () {
	    var i, renSt, children, actor = null, sortedActors = [],
	        mvMatrixInv = mat4.create(), clearColor = null;

	    renSt = new vgl.renderState();
	    renSt.m_renderer = m_this;
	    renSt.m_context = m_this.renderWindow().context();
	    if (!m_this.m_depthBits || m_this.m_contextChanged) {
	      m_this.m_depthBits = renSt.m_context.getParameter(vgl.GL.DEPTH_BITS);
	    }
	    renSt.m_contextChanged = m_this.m_contextChanged;

	    if (m_this.m_renderPasses) {
	      for (i = 0; i < m_this.m_renderPasses.length; i += 1) {
	        if (m_this.m_renderPasses[i].render(renSt)) {
	          // Stop the rendering if render pass returns false
	          console.log('returning');
	          m_this.m_renderPasses[i].remove(renSt);
	          return;
	        }
	        m_this.m_renderPasses[i].remove(renSt);
	      }
	    }

	    renSt.m_context.enable(vgl.GL.DEPTH_TEST);
	    renSt.m_context.depthFunc(vgl.GL.LEQUAL);

	    /*jshint bitwise: false */
	    if (m_this.m_camera.clearMask() & vgl.GL.COLOR_BUFFER_BIT) {
	      clearColor = m_this.m_camera.clearColor();
	      renSt.m_context.clearColor(clearColor[0], clearColor[1],
	                                 clearColor[2], clearColor[3]);
	    }

	    if (m_this.m_camera.clearMask() & vgl.GL.DEPTH_BUFFER_BIT) {
	      renSt.m_context.clearDepth(m_this.m_camera.clearDepth());
	    }
	    /*jshint bitwise: true */

	    renSt.m_context.clear(m_this.m_camera.clearMask());

	    // Set the viewport for this renderer
	    renSt.m_context.viewport(m_this.m_x, m_this.m_y,
	                             m_this.m_width, m_this.m_height);

	    children = m_this.m_sceneRoot.children();

	    if (children.length > 0 && m_this.m_resetScene) {
	      m_this.resetCamera();
	      m_this.m_resetScene = false;
	    }

	    for (i = 0; i < children.length; i += 1) {
	      actor = children[i];

	      // Compute the bounds even if the actor is not visible
	      actor.computeBounds();

	      // If bin number is < 0, then don't even bother
	      // rendering the data
	      if (actor.visible() && actor.material().binNumber() >= 0) {
	        sortedActors.push([actor.material().binNumber(), actor]);
	      }
	    }

	    // Now perform sorting
	    sortedActors.sort(function (a, b) { return a[0] - b[0]; });

	    for (i = 0; i < sortedActors.length; i += 1) {
	      actor = sortedActors[i][1];
	      if (actor.referenceFrame() ===
	          vgl.boundingObject.ReferenceFrame.Relative) {
	        var view = m_this.m_camera.viewMatrix();
	        /* If the view matrix is a plain array, keep it as such.  This is
	         * intended to preserve precision, and will only be the case if the
	         * view matrix was created by delibrately setting it as an array. */
	        if (view instanceof Array) {
	          renSt.m_modelViewMatrix = new Array(16);
	        }
	        mat4.multiply(renSt.m_modelViewMatrix, view, actor.matrix());
	        renSt.m_projectionMatrix = m_this.m_camera.projectionMatrix();
	        renSt.m_modelViewAlignment = m_this.m_camera.viewAlignment();
	      } else {
	        renSt.m_modelViewMatrix = actor.matrix();
	        renSt.m_modelViewAlignment = null;
	        renSt.m_projectionMatrix = mat4.create();
	        mat4.ortho(renSt.m_projectionMatrix,
	                   0, m_this.m_width, 0, m_this.m_height, -1, 1);
	      }

	      mat4.invert(mvMatrixInv, renSt.m_modelViewMatrix);
	      mat4.transpose(renSt.m_normalMatrix, mvMatrixInv);
	      renSt.m_material = actor.material();
	      renSt.m_mapper = actor.mapper();

	      // TODO Fix this shortcut
	      renSt.m_material.bind(renSt);
	      renSt.m_mapper.render(renSt);
	      renSt.m_material.undoBind(renSt);
	    }

	    renSt.m_context.finish();
	    m_this.m_contextChanged = false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Automatically set up the camera based on visible actors
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resetCamera = function () {
	    m_this.m_camera.computeBounds();

	    var vn = m_this.m_camera.directionOfProjection(),
	        visibleBounds = m_this.m_camera.bounds(),
	        center = [
	          (visibleBounds[0] + visibleBounds[1]) / 2.0,
	          (visibleBounds[2] + visibleBounds[3]) / 2.0,
	          (visibleBounds[4] + visibleBounds[5]) / 2.0
	        ],
	        diagonals = [
	          visibleBounds[1] - visibleBounds[0],
	          visibleBounds[3] - visibleBounds[2],
	          visibleBounds[5] - visibleBounds[4]
	        ],
	        radius = 0.0,
	        aspect = m_this.m_camera.viewAspect(),
	        angle = m_this.m_camera.viewAngle(),
	        distance = null,
	        vup = null;

	    if (diagonals[0] > diagonals[1]) {
	      if (diagonals[0] > diagonals[2]) {
	        radius = diagonals[0] / 2.0;
	      } else {
	        radius = diagonals[2] / 2.0;
	      }
	    } else {
	      if (diagonals[1] > diagonals[2]) {
	        radius = diagonals[1] / 2.0;
	      } else {
	        radius = diagonals[2] / 2.0;
	      }
	    }

	    // @todo Need to figure out what's happening here
	    if (aspect >= 1.0) {
	      angle = 2.0 * Math.atan(Math.tan(angle * 0.5) / aspect);
	    } else {
	      angle = 2.0 * Math.atan(Math.tan(angle * 0.5) * aspect);
	    }

	    distance = radius / Math.sin(angle * 0.5);
	    vup = m_this.m_camera.viewUpDirection();

	    if (Math.abs(vec3.dot(vup, vn)) > 0.999) {
	      m_this.m_camera.setViewUpDirection(-vup[2], vup[0], vup[1]);
	    }

	    m_this.m_camera.setFocalPoint(center[0], center[1], center[2]);
	    m_this.m_camera.setPosition(center[0] + distance * -vn[0],
	      center[1] + distance * -vn[1], center[2] + distance * -vn[2]);

	    m_this.resetCameraClippingRange(visibleBounds);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  * Check whether or not whether or not the bounds are valid
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.hasValidBounds = function (bounds) {
	    if (bounds[0] === Number.MAX_VALUE ||
	        bounds[1] === -Number.MAX_VALUE ||
	        bounds[2] === Number.MAX_VALUE ||
	        bounds[3] === -Number.MAX_VALUE ||
	        bounds[4] === Number.MAX_VALUE ||
	        bounds[5] === -Number.MAX_VALUE) {
	      return false;
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Recalculate camera's clipping range
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resetCameraClippingRange = function (bounds) {
	    if (typeof bounds === 'undefined') {
	      m_this.m_camera.computeBounds();
	      bounds = m_this.m_camera.bounds();
	    }

	    if (!m_this.hasValidBounds(bounds)) {
	      return;
	    }

	    var vn = m_this.m_camera.viewPlaneNormal(),
	        position = m_this.m_camera.position(),
	        a = -vn[0],
	        b = -vn[1],
	        c = -vn[2],
	        d = -(a * position[0] + b * position[1] + c * position[2]),
	        range = vec2.create(),
	        dist = null,
	        i = null,
	        j = null,
	        k = null;

	    if (!m_this.m_resetClippingRange) {
	      return;
	    }

	    // Set the max near clipping plane and the min far clipping plane
	    range[0] = a * bounds[0] + b * bounds[2] + c * bounds[4] + d;
	    range[1] = 1e-18;

	    // Find the closest / farthest bounding box vertex
	    for (k = 0; k < 2; k += 1) {
	      for (j = 0; j < 2; j += 1) {
	        for (i = 0; i < 2; i += 1) {
	          dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
	          range[0] = (dist < range[0]) ? (dist) : (range[0]);
	          range[1] = (dist > range[1]) ? (dist) : (range[1]);
	        }
	      }
	    }

	    // Do not let the range behind the camera throw off the calculation.
	    if (range[0] < 0.0) {
	      range[0] = 0.0;
	    }

	    // Give ourselves a little breathing room
	    range[0] = 0.99 * range[0] - (range[1] - range[0]) * 0.5;
	    range[1] = 1.01 * range[1] + (range[1] - range[0]) * 0.5;

	    // Make sure near is not bigger than far
	    range[0] = (range[0] >= range[1]) ? (0.01 * range[1]) : (range[0]);

	    // Make sure near is at least some fraction of far - this prevents near
	    // from being behind the camera or too close in front. How close is too
	    // close depends on the resolution of the depth buffer.
	    if (!m_this.m_nearClippingPlaneTolerance) {
	      m_this.m_nearClippingPlaneTolerance = 0.01;

	      if (m_this.m_depthBits && m_this.m_depthBits > 16) {
	        m_this.m_nearClippingPlaneTolerance = 0.001;
	      }
	    }

	    // make sure the front clipping range is not too far from the far clippnig
	    // range, this is to make sure that the zbuffer resolution is effectively
	    // used.
	    if (range[0] < m_this.m_nearClippingPlaneTolerance * range[1]) {
	      range[0] = m_this.m_nearClippingPlaneTolerance * range[1];
	    }

	    m_this.m_camera.setClippingRange(range[0], range[1]);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Resize viewport given a width and height
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resize = function (width, height) {
	    if (!width || !height) {
	      return;
	    }
	    // @note: where do m_this.m_x and m_this.m_y come from?
	    m_this.positionAndResize(m_this.m_x, m_this.m_y, width, height);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Resize viewport given a position, width and height
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.positionAndResize = function (x, y, width, height) {
	    var i;

	    // TODO move this code to camera
	    if (x < 0 || y < 0 || width <= 0 || height <= 0) {
	      console.log('[error] Invalid position and resize values',
	        x, y, width, height);
	      return;
	    }

	    //If we're allowing this renderer to resize ...
	    if (m_this.m_resizable) {
	      m_this.m_width = width;
	      m_this.m_height = height;

	      m_this.m_camera.setViewAspect(width / height);
	      m_this.m_camera.setParallelExtents({width: width, height: height});
	      m_this.modified();
	    }

	    if (m_this.m_renderPasses) {
	      for (i = 0; i < m_this.m_renderPasses.length; i += 1) {
	        m_this.m_renderPasses[i].resize(width, height);
	        m_this.m_renderPasses[i].renderer().positionAndResize(x, y, width, height);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add new actor to the collection
	   *
	   * @param actor
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addActor = function (actor) {
	    if (actor instanceof vgl.actor) {
	      m_this.m_sceneRoot.addChild(actor);
	      m_this.modified();
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return true if this renderer has this actor attached, false otherwise.
	   *
	   * @param actor
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.hasActor = function (actor) {
	    return m_this.m_sceneRoot.hasChild(actor);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add an array of actors to the collection
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addActors = function (actors) {
	    var i = null;
	    if (actors instanceof Array) {
	      for (i = 0; i < actors.length; i += 1) {
	        m_this.m_sceneRoot.addChild(actors[i]);
	      }
	      m_this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove the actor from the collection
	   *
	   * @param actor
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeActor = function (actor) {
	    if (m_this.m_sceneRoot.children().indexOf(actor) !== -1) {
	      /* When we remove an actor, free the VBOs of the mapper and mark the
	       * mapper as modified; it will reallocate VBOs as necessary. */
	      if (actor.mapper()) {
	        actor.mapper().deleteVertexBufferObjects();
	        actor.mapper().modified();
	      }
	      m_this.m_sceneRoot.removeChild(actor);
	      m_this.modified();
	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove actors from the collection
	   *
	   * @param actors
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeActors = function (actors) {
	    if (!(actors instanceof Array)) {
	      return false;
	    }

	    var i;
	    for (i = 0; i < actors.length; i += 1) {
	      m_this.m_sceneRoot.removeChild(actors[i]);
	    }
	    m_this.modified();
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove all actors for a renderer
	   *
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeAllActors = function () {
	    return m_this.m_sceneRoot.removeChildren();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Transform a point in the world space to display space
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.worldToDisplay = function (worldPt, viewMatrix, projectionMatrix, width,
	                                 height) {
	    var viewProjectionMatrix = mat4.create(),
	        winX = null,
	        winY = null,
	        winZ = null,
	        winW = null,
	        clipPt = null;

	    mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

	    // Transform world to clipping coordinates
	    clipPt = vec4.create();
	    vec4.transformMat4(clipPt, worldPt, viewProjectionMatrix);

	    if (clipPt[3] !== 0.0) {
	      clipPt[0] = clipPt[0] / clipPt[3];
	      clipPt[1] = clipPt[1] / clipPt[3];
	      clipPt[2] = clipPt[2] / clipPt[3];
	      clipPt[3] = 1.0;
	    }

	    winX = (((clipPt[0]) + 1) / 2.0) * width;
	    // We calculate -point3D.getY() because the screen Y axis is
	    // oriented top->down
	    winY = ((1 - clipPt[1]) / 2.0) * height;
	    winZ = clipPt[2];
	    winW = clipPt[3];

	    return vec4.fromValues(winX, winY, winZ, winW);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Transform a point in display space to world space
	   * @param displayPt
	   * @param viewMatrix
	   * @param projectionMatrix
	   * @param width
	   * @param height
	   * @returns {vec4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.displayToWorld = function (displayPt, viewMatrix, projectionMatrix,
	                                 width, height) {
	    var x = (2.0 * displayPt[0] / width) - 1,
	        y = -(2.0 * displayPt[1] / height) + 1,
	        z = displayPt[2],
	        viewProjectionInverse = mat4.create(),
	        worldPt = null;

	    mat4.multiply(viewProjectionInverse, projectionMatrix, viewMatrix);
	    mat4.invert(viewProjectionInverse, viewProjectionInverse);

	    worldPt = vec4.fromValues(x, y, z, 1);
	    vec4.transformMat4(worldPt, worldPt, viewProjectionInverse);
	    if (worldPt[3] !== 0.0) {
	      worldPt[0] = worldPt[0] / worldPt[3];
	      worldPt[1] = worldPt[1] / worldPt[3];
	      worldPt[2] = worldPt[2] / worldPt[3];
	      worldPt[3] = 1.0;
	    }

	    return worldPt;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the focusDisplayPoint
	   * @returns {vec4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.focusDisplayPoint = function () {
	    var focalPoint = m_this.m_camera.focalPoint(),
	        focusWorldPt = vec4.fromValues(
	        focalPoint[0], focalPoint[1], focalPoint[2], 1);

	    return m_this.worldToDisplay(
	      focusWorldPt, m_this.m_camera.viewMatrix(),
	      m_this.m_camera.projectionMatrix(), m_this.m_width, m_this.m_height);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Will the scene be reset.
	   * @returns {bool}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resetScene = function () {
	    return m_this.m_resetScene;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * If true the scene will be reset, otherwise the scene will not be
	   * automatically reset.
	   *
	   * @param reset
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setResetScene = function (reset) {
	    if (m_this.m_resetScene !== reset) {
	      m_this.m_resetScene = reset;
	      m_this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Will the clipping range be reset
	   * @returns {bool}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resetClippingRange = function () {
	    return m_this.m_resetClippingRange;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * If true the camera clipping range will be reset, otherwise the scene will
	   * not be automatically reset.
	   *
	   * @param reset
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setResetClippingRange = function (reset) {
	    if (m_this.m_resetClippingRange !== reset) {
	      m_this.m_resetClippingRange = reset;
	      m_this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addRenderPass = function (renPass) {
	    var i;

	    if (m_this.m_renderPasses) {
	      for (i = 0; i < m_this.m_renderPasses.length; i += 1) {
	        if (renPass === m_this.m_renderPasses[i]) {
	          return;
	        }
	      }
	    }

	    m_this.m_renderPasses = [];
	    m_this.m_renderPasses.push(renPass);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeRenderPass = function (renPass) {
	    renPass = renPass; // TODO Implement this
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._cleanup = function (renderState) {
	    var children = m_this.m_sceneRoot.children();
	    for (var i = 0; i < children.length; i += 1) {
	      var actor = children[i];
	      actor.material()._cleanup(renderState);
	      actor.mapper()._cleanup(renderState);
	    }

	    m_this.m_sceneRoot.removeChildren();
	  };

	  return m_this;
	};

	inherit(vgl.renderer, vgl.graphicsObject);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class renderWindow
	 *
	 * @class
	 * @returns {vgl.renderWindow}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.renderWindow = function (canvas) {
	  'use strict';

	  if (!(this instanceof vgl.renderWindow)) {
	    return new vgl.renderWindow(canvas);
	  }
	  vgl.graphicsObject.call(this);

	  /** @private */
	  var m_this = this,
	      m_x = 0,
	      m_y = 0,
	      m_width = 400,
	      m_height = 400,
	      m_canvas = canvas,
	      m_activeRender = null,
	      m_renderers = [],
	      m_context = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get size of the render window
	   *
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.windowSize = function () {
	    return [m_width, m_height];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set size of the render window
	   *
	   * @param width
	   * @param height
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setWindowSize = function (width, height) {

	    if (m_width !== width || m_height !== height) {
	      m_width = width;
	      m_height = height;

	      m_this.modified();

	      return true;
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get window position (top left coordinates)
	   *
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.windowPosition = function () {
	    return [m_x, m_y];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set window position (top left coordinates)
	   *
	   * @param x
	   * @param y
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setWindowPosition = function (x, y) {
	    if ((m_x !== x) || (m_y !== y)) {
	      m_x = x;
	      m_y = y;
	      m_this.modified();
	      return true;
	    }
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return all renderers contained in the render window
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.renderers = function () {
	    return m_renderers;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get active renderer of the the render window
	   *
	   * @returns vgl.renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.activeRenderer = function () {
	    return m_activeRender;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add renderer to the render window
	   *
	   * @param ren
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.addRenderer = function (ren) {
	    if (m_this.hasRenderer(ren) === false) {
	      m_renderers.push(ren);
	      ren.setRenderWindow(m_this);
	      if (m_activeRender === null) {
	        m_activeRender = ren;
	      }
	      if (ren.layer() !== 0) {
	        ren.camera().setClearMask(vgl.GL.DepthBufferBit);
	      }
	      m_this.modified();
	      return true;
	    }
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove renderer from the render window
	   *
	   * @param ren
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.removeRenderer = function (ren) {
	    var index = m_renderers.indexOf(ren);
	    if (index !== -1) {
	      if (m_activeRender === ren) {
	        m_activeRender = null;
	      }
	      m_renderers.splice(index, 1);
	      m_this.modified();
	      return true;
	    }
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return a renderer at a given index
	   *
	   * @param index
	   * @returns {vgl.renderer}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getRenderer = function (index) {
	    if (index < m_renderers.length) {
	      return m_renderers[index];
	    }

	    console.log('[WARNING] Out of index array');
	    return null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if the renderer exists
	   *
	   * @param ren
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.hasRenderer = function (ren) {
	    var i;
	    for (i = 0; i < m_renderers.length; i += 1) {
	      if (ren === m_renderers[i]) {
	        return true;
	      }
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Resize window
	   *
	   * @param width
	   * @param height
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resize = function (width, height) {
	    m_this.positionAndResize(m_x, m_y, width, height);
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Resize and reposition the window
	   *
	   * @param x
	   * @param y
	   * @param width
	   * @param height
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.positionAndResize = function (x, y, width, height) {
	    m_x = x;
	    m_y = y;
	    m_width = width;
	    m_height = height;
	    var i;
	    for (i = 0; i < m_renderers.length; i += 1) {
	      m_renderers[i].positionAndResize(m_x, m_y, m_width, m_height);
	    }
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create the window
	   *
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._setup = function (renderState) {
	    renderState = renderState; /* unused parameter */
	    m_context = null;

	    try {
	      // Try to grab the standard context. If it fails, fallback to
	      // experimental.
	      m_context = m_canvas.getContext('webgl') ||
	            m_canvas.getContext('experimental-webgl');

	      // Set width and height of renderers if not set already
	      var i;
	      for (i = 0; i < m_renderers.length; i += 1) {
	        if ((m_renderers[i].width() > m_width) ||
	            m_renderers[i].width() === 0 ||
	            (m_renderers[i].height() > m_height) ||
	            m_renderers[i].height() === 0) {
	          m_renderers[i].resize(m_x, m_y, m_width, m_height);
	        }
	      }

	      return true;
	    } catch (e) {
	    }

	    // If we don't have a GL context, give up now
	    if (!m_context) {
	      console('[ERROR] Unable to initialize WebGL. Your browser may not support it.');
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return current GL context
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.context = function () {
	    return m_context;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete this window and release any graphics resources
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._cleanup = function (renderState) {
	    var i;
	    for (i = 0; i < m_renderers.length; i += 1) {
	      m_renderers[i]._cleanup(renderState);
	    }
	    vgl.clearCachedShaders(renderState ? renderState.m_context : null);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the scene
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function () {
	    var i;
	    m_renderers.sort(function (a, b) { return a.layer() - b.layer(); });
	    for (i = 0; i < m_renderers.length; i += 1) {
	      m_renderers[i].render();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the focusDisplayPoint from the activeRenderer
	   * @returns {vec4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.focusDisplayPoint = function () {
	    return m_activeRender.focusDisplayPoint();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Transform a point in display space to world space
	   * @param {Number} x
	   * @param {Number} y
	   * @param {vec4} focusDisplayPoint
	   * @returns {vec4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.displayToWorld = function (x, y, focusDisplayPoint, ren) {
	    ren = ren === undefined ? ren = m_activeRender : ren;

	    var camera = ren.camera();
	    if (!focusDisplayPoint) {
	      focusDisplayPoint = ren.focusDisplayPoint();
	    }

	    return ren.displayToWorld(
	      vec4.fromValues(x, y, focusDisplayPoint[2], 1.0), camera.viewMatrix(),
	      camera.projectionMatrix(), m_width, m_height);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Transform a point in display space to world space
	   * @param {Number} x
	   * @param {Number} y
	   * @param {vec4} focusDisplayPoint
	   * @returns {vec4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.worldToDisplay = function (x, y, z, ren) {
	    ren = ren === undefined ? ren = m_activeRender : ren;
	    var camera = ren.camera();
	    return ren.worldToDisplay(
	      vec4.fromValues(x, y, z, 1.0), camera.viewMatrix(),
	      camera.projectionMatrix(), m_width, m_height);
	  };

	  return m_this;
	};

	inherit(vgl.renderWindow, vgl.graphicsObject);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec3, vec4, mat4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class camera
	 *
	 * @class
	 * @returns {vgl.camera}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.camera = function (arg) {
	  'use strict';

	  if (!(this instanceof vgl.camera)) {
	    return new vgl.camera(arg);
	  }
	  vgl.groupNode.call(this);
	  arg = arg || {};

	  /** @private */
	  var m_viewAngle = (Math.PI * 30) / 180.0,
	      m_position = vec4.fromValues(0.0, 0.0, 1.0, 1.0),
	      m_focalPoint = vec4.fromValues(0.0, 0.0, 0.0, 1.0),
	      m_centerOfRotation = vec3.fromValues(0.0, 0.0, 0.0),
	      m_viewUp = vec4.fromValues(0.0, 1.0, 0.0, 0.0),
	      m_rightDir = vec4.fromValues(1.0, 0.0, 0.0, 0.0),
	      m_near = 0.01,
	      m_far = 10000.0,
	      m_viewAspect = 1.0,
	      m_directionOfProjection = vec4.fromValues(0.0, 0.0, -1.0, 0.0),
	      m_viewPlaneNormal = vec4.fromValues(0.0, 0.0, 1.0, 0.0),
	      m_viewMatrix = mat4.create(),
	      m_projectionMatrix = mat4.create(),
	      m_computeModelViewMatrixTime = vgl.timestamp(),
	      m_computeProjectMatrixTime = vgl.timestamp(),
	      m_left = -1.0,
	      m_right = 1.0,
	      m_top = +1.0,
	      m_bottom = -1.0,
	      m_parallelExtents = {zoom: 1, tilesize: 256},
	      m_enableTranslation = true,
	      m_enableRotation = true,
	      m_enableScale = true,
	      m_enableParallelProjection = false,
	      m_clearColor = [0.0, 0.0, 0.0, 0.0],
	      m_clearDepth = 1.0,
	      /*jshint bitwise: false */
	      m_clearMask = vgl.GL.COLOR_BUFFER_BIT |
	                    vgl.GL.DEPTH_BUFFER_BIT;
	  /*jshint bitwise: true */

	  if (arg.parallelProjection !== undefined) {
	    m_enableParallelProjection = arg.parallelProjection ? true : false;
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get view angle of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewAngle = function () {
	    return m_viewAngle;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set view angle of the camera in degrees, which is converted to radians.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setViewAngleDegrees = function (a) {
	    this.setViewAngle(Math.PI * a / 180.0);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set view angle of the camera in degrees, which is converted to radians.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setViewAngle = function (a) {
	    if (m_enableScale) {
	      m_viewAngle = a;
	      this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get position of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function () {
	    return m_position;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set position of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setPosition = function (x, y, z) {
	    if (m_enableTranslation) {
	      m_position = vec4.fromValues(x, y, z, 1.0);
	      this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get focal point of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.focalPoint = function () {
	    return m_focalPoint;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set focal point of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setFocalPoint = function (x, y, z) {
	    if (m_enableRotation && m_enableTranslation) {
	      m_focalPoint = vec4.fromValues(x, y, z, 1.0);
	      this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get view-up direction of camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewUpDirection = function () {
	    return m_viewUp;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set view-up direction of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setViewUpDirection = function (x, y, z) {
	    m_viewUp = vec4.fromValues(x, y, z, 0);
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get center of rotation for camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.centerOfRotation = function () {
	    return m_centerOfRotation;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set center of rotation for camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setCenterOfRotation = function (centerOfRotation) {
	    m_centerOfRotation = centerOfRotation;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get clipping range of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clippingRange = function () {
	    return [m_near, m_far];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set clipping range of the camera
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setClippingRange = function (near, far) {
	    m_near = near;
	    m_far = far;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get view aspect
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewAspect = function () {
	    return m_viewAspect;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set view aspect
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setViewAspect = function (aspect) {
	    m_viewAspect = aspect;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return active mode for scaling (enabled / disabled)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.enableScale = function () {
	    return m_enableScale;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Enable/disable scaling
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setEnableScale = function (flag) {
	    if (flag !== m_enableScale) {
	      m_enableScale = flag;
	      this.modified();
	      return true;
	    }

	    return m_enableScale;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return active mode for rotation (enabled / disabled)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.enableRotation = function () {
	    return m_enableRotation;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Enable / disable rotation
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setEnableRotation = function (flag) {
	    if (flag !== m_enableRotation) {
	      m_enableRotation = flag;
	      this.modified();
	      return true;
	    }

	    return m_enableRotation;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return active mode for translation (enabled/disabled)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.enableTranslation = function () {
	    return m_enableTranslation;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Enable / disable translation
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setEnableTranslation = function (flag) {
	    if (flag !== m_enableTranslation) {
	      m_enableTranslation = flag;
	      this.modified();
	      return true;
	    }

	    return m_enableTranslation;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return if parallel projection is enabled
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.isEnabledParallelProjection = function () {
	    return m_enableParallelProjection;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Enable / disable parallel projection
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.enableParallelProjection = function (flag) {
	    if (flag !== m_enableParallelProjection) {
	      m_enableParallelProjection = flag;
	      this.modified();
	      return true;
	    }

	    return m_enableParallelProjection;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Enable / disable parallel projection
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setEnableParallelProjection = function (flag) {
	    return this.enableParallelProjection(flag);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get parallel projection parameters
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parallelProjection = function () {
	    return {left: m_left, right: m_right, top: m_top, bottom: m_bottom};
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set parallel projection parameters
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setParallelProjection = function (left, right, top, bottom) {
	    m_left = left;
	    m_right = right;
	    m_top = top;
	    m_bottom = bottom;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get parallel projection extents parameters
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parallelExtents = function () {
	    return m_parallelExtents;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set parallel projection extents parameters
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setParallelExtents = function (extents) {
	    var prop = ['width', 'height', 'zoom', 'tilesize'], mod = false, i, key;
	    for (i = 0; i < prop.length; i += 1) {
	      key = prop[i];
	      if (extents[key] !== undefined &&
	          extents[key] !== m_parallelExtents[key]) {
	        m_parallelExtents[key] = extents[key];
	        mod = true;
	      }
	    }
	    if (mod && m_parallelExtents.width && m_parallelExtents.height &&
	        m_parallelExtents.zoom !== undefined && m_parallelExtents.tilesize) {
	      var unitsPerPixel = this.unitsPerPixel(m_parallelExtents.zoom,
	                                             m_parallelExtents.tilesize);
	      m_right = unitsPerPixel * m_parallelExtents.width / 2;
	      m_left = -m_right;
	      m_top = unitsPerPixel * m_parallelExtents.height / 2;
	      m_bottom = -m_top;
	      this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute the units per pixel.
	   *
	   * @param zoom: tile zoom level.
	   * @param tilesize: number of pixels per tile (defaults to 256).
	   * @returns: unitsPerPixel.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.unitsPerPixel = function (zoom, tilesize) {
	    tilesize = tilesize || 256;
	    return 360.0 * Math.pow(2, -zoom) / tilesize;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return direction of projection
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.directionOfProjection = function () {
	    this.computeDirectionOfProjection();
	    return m_directionOfProjection;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return view plane normal direction
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewPlaneNormal = function () {
	    this.computeViewPlaneNormal();
	    return m_viewPlaneNormal;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return view-matrix for the camera This method does not compute the
	   * view-matrix for the camera. It is assumed that a call to computeViewMatrix
	   * has been made earlier.
	   *
	   * @returns {mat4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewMatrix = function () {
	    return this.computeViewMatrix();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set the view-matrix for the camera and mark that it is up to date so that
	   * it won't be recomputed unless something else changes.
	   *
	   * @param {mat4} view: new view matrix.
	   * @param {boolean} preserveType: if true, clone the input using slice.  This
	   *    can be used to ensure the array is a specific precision.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setViewMatrix = function (view, preserveType) {
	    if (!preserveType) {
	      mat4.copy(m_viewMatrix, view);
	    } else {
	      m_viewMatrix = view.slice();
	    }
	    m_computeModelViewMatrixTime.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return camera projection matrix This method does not compute the
	   * projection-matrix for the camera. It is assumed that a call to
	   * computeProjectionMatrix has been made earlier.
	   *
	   * @returns {mat4}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.projectionMatrix = function () {
	    return this.computeProjectionMatrix();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set the projection-matrix for the camera and mark that it is up to date so
	   * that it won't be recomputed unless something else changes.
	   *
	   * @param {mat4} proj: new projection matrix.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setProjectionMatrix = function (proj) {
	    mat4.copy(m_projectionMatrix, proj);
	    m_computeProjectMatrixTime.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return clear mask used by this camera
	   *
	   * @returns {number}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clearMask = function () {
	    return m_clearMask;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set clear mask for camera
	   *
	   * @param mask
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setClearMask = function (mask) {
	    m_clearMask = mask;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get clear color (background color) of the camera
	   *
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clearColor = function () {
	    return m_clearColor;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set clear color (background color) for the camera
	   *
	   * @param color RGBA
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setClearColor = function (r, g, b, a) {
	    m_clearColor[0] = r;
	    m_clearColor[1] = g;
	    m_clearColor[2] = b;
	    m_clearColor[3] = a;

	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   * @returns {{1.0: null}}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clearDepth = function () {
	    return m_clearDepth;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *
	   * @param depth
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setClearDepth = function (depth) {
	    m_clearDepth = depth;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute direction of projection
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeDirectionOfProjection = function () {
	    vec3.subtract(m_directionOfProjection, m_focalPoint, m_position);
	    vec3.normalize(m_directionOfProjection, m_directionOfProjection);
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute view plane normal
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeViewPlaneNormal = function () {
	    m_viewPlaneNormal[0] = -m_directionOfProjection[0];
	    m_viewPlaneNormal[1] = -m_directionOfProjection[1];
	    m_viewPlaneNormal[2] = -m_directionOfProjection[2];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Move camera closer or further away from the scene
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.zoom = function (d, dir) {
	    if (d === 0) {
	      return;
	    }

	    if (!m_enableTranslation) {
	      return;
	    }

	    d = d * vec3.distance(m_focalPoint, m_position);
	    if (!dir) {
	      dir = m_directionOfProjection;
	      m_position[0] = m_focalPoint[0] - d * dir[0];
	      m_position[1] = m_focalPoint[1] - d * dir[1];
	      m_position[2] = m_focalPoint[2] - d * dir[2];
	    } else {
	      m_position[0] = m_position[0] + d * dir[0];
	      m_position[1] = m_position[1] + d * dir[1];
	      m_position[2] = m_position[2] + d * dir[2];
	    }

	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Move camera sideways
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pan = function (dx, dy, dz) {
	    if (!m_enableTranslation) {
	      return;
	    }

	    m_position[0] += dx;
	    m_position[1] += dy;
	    m_position[2] += dz;

	    m_focalPoint[0] += dx;
	    m_focalPoint[1] += dy;
	    m_focalPoint[2] += dz;

	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute camera coordinate axes
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeOrthogonalAxes = function () {
	    this.computeDirectionOfProjection();
	    vec3.cross(m_rightDir, m_directionOfProjection, m_viewUp);
	    vec3.normalize(m_rightDir, m_rightDir);
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Rotate camera around center of rotation
	   * @param dx Rotation around vertical axis in degrees
	   * @param dy Rotation around horizontal axis in degrees
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.rotate = function (dx, dy) {
	    if (!m_enableRotation) {
	      return;
	    }

	    // Convert degrees into radians
	    dx = 0.5 * dx * (Math.PI / 180.0);
	    dy = 0.5 * dy * (Math.PI / 180.0);

	    var mat = mat4.create(),
	        inverseCenterOfRotation = new vec3.create();

	    mat4.identity(mat);

	    inverseCenterOfRotation[0] = -m_centerOfRotation[0];
	    inverseCenterOfRotation[1] = -m_centerOfRotation[1];
	    inverseCenterOfRotation[2] = -m_centerOfRotation[2];

	    mat4.translate(mat, mat, m_centerOfRotation);
	    mat4.rotate(mat, mat, dx, m_viewUp);
	    mat4.rotate(mat, mat, dy, m_rightDir);
	    mat4.translate(mat, mat, inverseCenterOfRotation);

	    vec4.transformMat4(m_position, m_position, mat);
	    vec4.transformMat4(m_focalPoint, m_focalPoint, mat);

	    // Update viewup vector
	    vec4.transformMat4(m_viewUp, m_viewUp, mat);
	    vec4.normalize(m_viewUp, m_viewUp);

	    // Update direction of projection
	    this.computeOrthogonalAxes();

	    // Mark modified
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute camera view matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeViewMatrix = function () {
	    if (m_computeModelViewMatrixTime.getMTime() < this.getMTime()) {
	      mat4.lookAt(m_viewMatrix, m_position, m_focalPoint, m_viewUp);
	      m_computeModelViewMatrixTime.modified();
	    }
	    return m_viewMatrix;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if the texture should be aligned to the screen.  Alignment only
	   * occurs if the parallel extents contain width, height, and a
	   * close-to-integer zoom level, and if the units-per-pixel value has been
	   * computed.  The camera must either be in parallel projection mode OR must
	   * have a perspective camera which is oriented along the z-axis without any
	   * rotation.
	   *
	   * @returns: either null if no alignment should occur, or an alignment object
	   *           with the rounding value and offsets.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewAlignment = function () {
	    if (!m_enableParallelProjection) {
	      /* If we aren't in parallel projection mode, ensure that the projection
	       * matrix meets strict specifications */
	      var proj = this.projectionMatrix();
	      if (proj[1] || proj[2] || proj[3] || proj[4] || proj[6] || proj[7] ||
	          proj[8] || proj[9] || proj[12] || proj[13] || proj[15]) {
	        return null;
	      }
	    }
	    var unitsPerPixel = this.unitsPerPixel(m_parallelExtents.zoom,
	                                           m_parallelExtents.tilesize);
	    /* If we don't have screen dimensions, we can't know how to align pixels */
	    if (!m_parallelExtents.width || !m_parallelExtents.height ||
	        !unitsPerPixel) {
	      return null;
	    }
	    /* If we aren't at an integer zoom level, we shouldn't align pixels.  If
	     * we are really close to an integer zoom level, that is good enough. */
	    if (parseFloat(m_parallelExtents.zoom.toFixed(6)) !==
	        parseFloat(m_parallelExtents.zoom.toFixed(0))) {
	      return null;
	    }
	    var align = {roundx: unitsPerPixel, roundy: unitsPerPixel, dx: 0, dy: 0};
	    /* If the screen is an odd number of pixels, shift the view center to the
	     * center of a pixel so that the pixels fit discretely across the screen.
	     * If an even number of pixels, align the view center between pixels for
	     * the same reason. */
	    if (m_parallelExtents.width % 2) {
	      align.dx = unitsPerPixel * 0.5;
	    }
	    if (m_parallelExtents.height % 2) {
	      align.dy = unitsPerPixel * 0.5;
	    }
	    return align;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute camera projection matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeProjectionMatrix = function () {
	    if (m_computeProjectMatrixTime.getMTime() < this.getMTime()) {
	      if (!m_enableParallelProjection) {
	        mat4.perspective(m_projectionMatrix, m_viewAngle, m_viewAspect, m_near, m_far);
	      } else {
	        mat4.ortho(m_projectionMatrix,
	          m_left, m_right, m_bottom, m_top, m_near, m_far);
	      }

	      m_computeProjectMatrixTime.modified();
	    }

	    return m_projectionMatrix;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert a zoom level and window size to a camera height.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.zoomToHeight = function (zoom, width, height) {
	    return vgl.zoomToHeight(zoom, width, height, m_viewAngle);
	  };

	  this.computeDirectionOfProjection();

	  return this;
	};

	inherit(vgl.camera, vgl.groupNode);

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Convert a zoom level and window size to a camera height.
	 *
	 * @param zoom: Zoom level, as used in OSM maps.
	 * @param width: width of the window.
	 * @param height: height of the window.
	 * @returns: perspective camera height.
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.zoomToHeight = function (zoom, width, height, viewAngle) {
	  'use strict';
	  viewAngle = viewAngle || (30 * Math.PI / 180.0);
	  var newZ = 360 * Math.pow(2, -zoom);
	  newZ /= Math.tan(viewAngle / 2) * 2 * 256 / height;
	  return newZ;
	};

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Convert a camera height and window size to a zoom level.
	 *
	 * @param z: perspective camera height.
	 * @param width: width of the window.
	 * @param height: height of the window.
	 * @returns: zoom level.
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.heightToZoom = function (z, width, height, viewAngle) {
	  'use strict';
	  viewAngle = viewAngle || (30 * Math.PI / 180.0);
	  z *= Math.tan(viewAngle / 2) * 2 * 256 / height;
	  var zoom = -Math.log2(z / 360);
	  return zoom;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit, $*/
	//////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class interactorStyle
	 *
	 * @class vgl.interactorStyle
	 * interactorStyle is a base class for all interactor styles
	 * @returns {vgl.interactorStyle}
	 */
	////////////////////////////////////////////////////////////////////////////
	vgl.interactorStyle = function () {
	  'use strict';

	  if (!(this instanceof vgl.interactorStyle)) {
	    return new vgl.interactorStyle();
	  }
	  vgl.object.call(this);

	  // Private member variables
	  var m_that = this,
	      m_viewer = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return viewer referenced by the interactor style
	   *
	   * @returns {null}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.viewer = function () {
	    return m_viewer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set viewer for the interactor style
	   *
	   * @param viewer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setViewer = function (viewer) {
	    if (viewer !== m_viewer) {
	      m_viewer = viewer;
	      $(m_viewer).on(vgl.event.mousePress, m_that.handleMouseDown);
	      $(m_viewer).on(vgl.event.mouseRelease, m_that.handleMouseUp);
	      $(m_viewer).on(vgl.event.mouseMove, m_that.handleMouseMove);
	      $(m_viewer).on(vgl.event.mouseOut, m_that.handleMouseOut);
	      $(m_viewer).on(vgl.event.mouseWheel, m_that.handleMouseWheel);
	      $(m_viewer).on(vgl.event.keyPress, m_that.handleKeyPress);
	      $(m_viewer).on(vgl.event.mouseContextMenu, m_that.handleContextMenu);
	      $(m_viewer).on(vgl.event.click, m_that.handleClick);
	      $(m_viewer).on(vgl.event.dblClick, m_that.handleDoubleClick);
	      this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse down event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseDown = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse up event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseUp = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseMove = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseOut = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse wheel event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseWheel = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle click event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleClick = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle double click event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleDoubleClick = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle key press event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleKeyPress = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle context menu event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleContextMenu = function (event) {
	    event = event; /* unused parameter */
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Reset to default
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.reset = function () {
	    return true;
	  };

	  return this;
	};

	inherit(vgl.interactorStyle, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of trackballInteractorStyle
	 *
	 * @class vgl.trackballInteractorStyle
	 * @returns {vgl.trackballInteractorStyle}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.trackballInteractorStyle = function () {
	  'use strict';

	  if (!(this instanceof vgl.trackballInteractorStyle)) {
	    return new vgl.trackballInteractorStyle();
	  }
	  vgl.interactorStyle.call(this);
	  var m_that = this,
	      m_leftMouseBtnDown = false,
	      m_rightMouseBtnDown = false,
	      m_midMouseBtnDown = false,
	      m_outsideCanvas,
	      m_currPos = {x: 0, y: 0},
	      m_lastPos = {x: 0, y: 0};

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.handleMouseMove = function (event) {
	    var width = m_that.viewer().renderWindow().windowSize()[0],
	        height = m_that.viewer().renderWindow().windowSize()[1],
	        ren = m_that.viewer().renderWindow().activeRenderer(),
	        cam = ren.camera(), coords = m_that.viewer().relMouseCoords(event),
	        fp, fdp, fwp, dp1, dp2, wp1, wp2, dx, dy, dz, m_zTrans;

	    m_outsideCanvas = false;
	    m_currPos = {x: 0, y: 0};

	    if ((coords.x < 0) || (coords.x > width)) {
	      m_currPos.x = 0;
	      m_outsideCanvas = true;
	    } else {
	      m_currPos.x = coords.x;
	    }
	    if ((coords.y < 0) || (coords.y > height)) {
	      m_currPos.y = 0;
	      m_outsideCanvas = true;
	    } else {
	      m_currPos.y = coords.y;
	    }
	    if (m_outsideCanvas === true) {
	      return;
	    }

	    fp = cam.focalPoint();
	    fwp = vec4.fromValues(fp[0], fp[1], fp[2], 1);
	    fdp = ren.worldToDisplay(fwp, cam.viewMatrix(),
	                              cam.projectionMatrix(), width, height);

	    dp1 = vec4.fromValues(m_currPos.x, m_currPos.y, fdp[2], 1.0);
	    dp2 = vec4.fromValues(m_lastPos.x, m_lastPos.y, fdp[2], 1.0);

	    wp1 = ren.displayToWorld(dp1, cam.viewMatrix(), cam.projectionMatrix(),
	                             width, height);
	    wp2 = ren.displayToWorld(dp2, cam.viewMatrix(), cam.projectionMatrix(),
	                             width, height);

	    dx = wp1[0] - wp2[0];
	    dy = wp1[1] - wp2[1];
	    dz = wp1[2] - wp2[2];

	    if (m_midMouseBtnDown) {
	      cam.pan(-dx, -dy, -dz);
	      m_that.viewer().render();
	    }
	    if (m_leftMouseBtnDown) {
	      cam.rotate((m_lastPos.x - m_currPos.x),
	      (m_lastPos.y - m_currPos.y));
	      ren.resetCameraClippingRange();
	      m_that.viewer().render();
	    }
	    if (m_rightMouseBtnDown) {
	      /// 2.0 is the speed up factor
	      m_zTrans = 2.0 * (m_currPos.y - m_lastPos.y) / height;

	      // Calculate zoom scale here
	      if (m_zTrans > 0) {
	        cam.zoom(1 - Math.abs(m_zTrans));
	      } else {
	        cam.zoom(1 + Math.abs(m_zTrans));
	      }
	      ren.resetCameraClippingRange();
	      m_that.viewer().render();
	    }
	    m_lastPos.x = m_currPos.x;
	    m_lastPos.y = m_currPos.y;
	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse down event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.handleMouseDown = function (event) {
	    var coords;

	    if (event.button === 0) {
	      m_leftMouseBtnDown = true;
	    }
	    if (event.button === 1) {
	      m_midMouseBtnDown = true;
	    }
	    if (event.button === 2) {
	      m_rightMouseBtnDown = true;
	    }
	    coords = m_that.viewer().relMouseCoords(event);
	    if (coords.x < 0) {
	      m_lastPos.x = 0;
	    } else {
	      m_lastPos.x = coords.x;
	    }
	    if (coords.y < 0) {
	      m_lastPos.y = 0;
	    } else {
	      m_lastPos.y = coords.y;
	    }
	    return false;
	  };

	  // @note We never get mouse up from scroll bar: See the bug report here
	  // http://bugs.jquery.com/ticket/8184
	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse up event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.handleMouseUp = function (event) {
	    if (event.button === 0) {
	      m_leftMouseBtnDown = false;
	    }
	    if (event.button === 1) {
	      m_midMouseBtnDown = false;
	    }
	    if (event.button === 2) {
	      m_rightMouseBtnDown = false;
	    }
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse wheel event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseWheel = function (event) {
	    var ren = m_that.viewer().renderWindow().activeRenderer(),
	        cam = ren.camera();

	    // TODO Compute zoom factor intelligently
	    if (event.originalEvent.wheelDelta < 0) {
	      cam.zoom(0.9);
	    } else {
	      cam.zoom(1.1);
	    }
	    ren.resetCameraClippingRange();
	    m_that.viewer().render();
	    return true;
	  };

	  return this;
	};
	inherit(vgl.trackballInteractorStyle, vgl.interactorStyle);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of pvwInteractorStyle (for ParaViewWeb)
	 *
	 * @class vgl.pvwInteractorStyle
	 * @returns {vgl.pvwInteractorStyle}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.pvwInteractorStyle = function () {
	  'use strict';

	  if (!(this instanceof vgl.pvwInteractorStyle)) {
	    return new vgl.pvwInteractorStyle();
	  }
	  vgl.trackballInteractorStyle.call(this);
	  var m_that = this,
	      m_leftMouseButtonDown = false,
	      m_rightMouseButtonDown = false,
	      m_middleMouseButtonDown = false,
	      m_width,
	      m_height,
	      m_renderer,
	      m_camera,
	      m_outsideCanvas,
	      m_coords,
	      m_currentMousePos,
	      m_focalPoint,
	      m_focusWorldPt,
	      m_focusDisplayPt,
	      m_displayPt1,
	      m_displayPt2,
	      m_worldPt1,
	      m_worldPt2,
	      m_dx,
	      m_dy,
	      m_dz,
	      m_zTrans,
	      m_mouseLastPos = {
	        x: 0,
	        y: 0
	      };

	  function render() {
	    m_renderer.resetCameraClippingRange();
	    m_that.viewer().render();
	  }

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.handleMouseMove = function (event) {
	    var rens = [], i = null, secCameras = [], deltaxy = null;
	    m_width = m_that.viewer().renderWindow().windowSize()[0];
	    m_height = m_that.viewer().renderWindow().windowSize()[1];
	    m_renderer = m_that.viewer().renderWindow().activeRenderer();
	    m_camera = m_renderer.camera();
	    m_outsideCanvas = false;
	    m_coords = m_that.viewer().relMouseCoords(event);
	    m_currentMousePos = {
	      x: 0,
	      y: 0
	    };

	    // Get secondary cameras
	    rens = m_that.viewer().renderWindow().renderers();
	    for (i = 0; i < rens.length; i += 1) {
	      if (m_renderer !== rens[i]) {
	        secCameras.push(rens[i].camera());
	      }
	    }

	    if ((m_coords.x < 0) || (m_coords.x > m_width)) {
	      m_currentMousePos.x = 0;
	      m_outsideCanvas = true;
	    } else {
	      m_currentMousePos.x = m_coords.x;
	    }
	    if ((m_coords.y < 0) || (m_coords.y > m_height)) {
	      m_currentMousePos.y = 0;
	      m_outsideCanvas = true;
	    } else {
	      m_currentMousePos.y = m_coords.y;
	    }
	    if (m_outsideCanvas === true) {
	      return;
	    }
	    m_focalPoint = m_camera.focalPoint();
	    m_focusWorldPt = vec4.fromValues(m_focalPoint[0], m_focalPoint[1],
	                                     m_focalPoint[2], 1);
	    m_focusDisplayPt = m_renderer.worldToDisplay(m_focusWorldPt,
	        m_camera.viewMatrix(), m_camera.projectionMatrix(), m_width, m_height);
	    m_displayPt1 = vec4.fromValues(
	      m_currentMousePos.x, m_currentMousePos.y, m_focusDisplayPt[2], 1.0);
	    m_displayPt2 = vec4.fromValues(
	      m_mouseLastPos.x, m_mouseLastPos.y, m_focusDisplayPt[2], 1.0);
	    m_worldPt1 = m_renderer.displayToWorld(
	      m_displayPt1, m_camera.viewMatrix(), m_camera.projectionMatrix(),
	      m_width, m_height);
	    m_worldPt2 = m_renderer.displayToWorld(
	      m_displayPt2, m_camera.viewMatrix(), m_camera.projectionMatrix(),
	      m_width, m_height);

	    m_dx = m_worldPt1[0] - m_worldPt2[0];
	    m_dy = m_worldPt1[1] - m_worldPt2[1];
	    m_dz = m_worldPt1[2] - m_worldPt2[2];

	    if (m_middleMouseButtonDown) {
	      m_camera.pan(-m_dx, -m_dy, -m_dz);
	      render();
	    }
	    if (m_leftMouseButtonDown) {
	      deltaxy = [(m_mouseLastPos.x - m_currentMousePos.x),
	      (m_mouseLastPos.y - m_currentMousePos.y)];
	      m_camera.rotate(deltaxy[0], deltaxy[1]);

	      // Apply rotation to all other cameras
	      for (i = 0; i < secCameras.length; i += 1) {
	        secCameras[i].rotate(deltaxy[0], deltaxy[1]);
	      }

	      // Apply rotation to all other cameras
	      for (i = 0; i < rens.length; i += 1) {
	        rens[i].resetCameraClippingRange();
	      }
	      render();
	    }
	    if (m_rightMouseButtonDown) {
	      /// 2.0 is the speed up factor.
	      m_zTrans = 2.0 * (m_currentMousePos.y - m_mouseLastPos.y) / m_height;

	      // Calculate zoom scale here
	      if (m_zTrans > 0) {
	        m_camera.zoom(1 - Math.abs(m_zTrans));
	      } else {
	        m_camera.zoom(1 + Math.abs(m_zTrans));
	      }
	      render();
	    }
	    m_mouseLastPos.x = m_currentMousePos.x;
	    m_mouseLastPos.y = m_currentMousePos.y;
	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse down event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.handleMouseDown = function (event) {
	    if (event.button === 0) {
	      m_leftMouseButtonDown = true;
	    }
	    if (event.button === 1) {
	      m_middleMouseButtonDown = true;
	    }
	    if (event.button === 2) {
	      m_rightMouseButtonDown = true;
	    }
	    m_coords = m_that.viewer().relMouseCoords(event);
	    if (m_coords.x < 0) {
	      m_mouseLastPos.x = 0;
	    } else {
	      m_mouseLastPos.x = m_coords.x;
	    }
	    if (m_coords.y < 0) {
	      m_mouseLastPos.y = 0;
	    } else {
	      m_mouseLastPos.y = m_coords.y;
	    }
	    return false;
	  };

	  // @note We never get mouse up from scroll bar: See the bug report here
	  // http://bugs.jquery.com/ticket/8184
	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse up event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.handleMouseUp = function (event) {
	    if (event.button === 0) {
	      m_leftMouseButtonDown = false;
	    }
	    if (event.button === 1) {
	      m_middleMouseButtonDown = false;
	    }
	    if (event.button === 2) {
	      m_rightMouseButtonDown = false;
	    }
	    return false;
	  };

	  return this;
	};
	inherit(vgl.pvwInteractorStyle, vgl.trackballInteractorStyle);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global window, vgl, inherit, $*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class viewer
	 *
	 * @param canvas
	 * @returns {vgl.viewer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.viewer = function (canvas, options) {
	  'use strict';

	  if (!(this instanceof vgl.viewer)) {
	    return new vgl.viewer(canvas, options);
	  }

	  vgl.object.call(this);

	  var m_that = this,
	      m_canvas = canvas,
	      m_ready = true,
	      m_interactorStyle = null,
	      m_renderer = vgl.renderer(options),
	      m_renderWindow = vgl.renderWindow(m_canvas);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get canvas of the viewer
	   *
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.canvas = function () {
	    return m_canvas;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return render window of the viewer
	   *
	   * @returns {vgl.renderWindow}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.renderWindow = function () {
	    return m_renderWindow;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize the viewer
	   *
	   * This is a must call or otherwise render context may not initialized
	   * properly.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.init = function () {
	    if (m_renderWindow !== null) {
	      m_renderWindow._setup();
	    } else {
	      console.log('[ERROR] No render window attached');
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   *  Remove the viewer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.exit = function (renderState) {
	    if (m_renderWindow !== null) {
	      m_renderWindow._cleanup(renderState);
	    } else {
	      console.log('[ERROR] No render window attached');
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get interactor style of the viewer
	   *
	   * @returns {vgl.interactorStyle}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.interactorStyle = function () {
	    return m_interactorStyle;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set interactor style to be used by the viewer
	   *
	   * @param {vgl.interactorStyle} style
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setInteractorStyle = function (style) {
	    if (style !== m_interactorStyle) {
	      m_interactorStyle = style;
	      m_interactorStyle.setViewer(this);
	      this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse down event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseDown = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      // Only prevent default action for right mouse button
	      if (event.button === 2) {
	        fixedEvent.preventDefault();
	      }
	      fixedEvent.state = 'down';
	      fixedEvent.type = vgl.event.mousePress;
	      $(m_that).trigger(fixedEvent);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse up event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseUp = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.state = 'up';
	      fixedEvent.type = vgl.event.mouseRelease;
	      $(m_that).trigger(fixedEvent);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseMove = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.mouseMove;
	      $(m_that).trigger(fixedEvent);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse wheel scroll
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseWheel = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.mouseWheel;
	      $(m_that).trigger(fixedEvent);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleMouseOut = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.mouseOut;
	      $(m_that).trigger(fixedEvent);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle key press event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleKeyPress = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.keyPress;
	      $(m_that).trigger(fixedEvent);
	    }

	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle context menu event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleContextMenu = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.contextMenu;
	      $(m_that).trigger(fixedEvent);
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle click event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleClick = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.click;
	      $(m_that).trigger(fixedEvent);
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle double click event
	   *
	   * @param event
	   * @returns {boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.handleDoubleClick = function (event) {
	    if (m_ready === true) {
	      var fixedEvent = $.event.fix(event || window.event);
	      fixedEvent.preventDefault();
	      fixedEvent.type = vgl.event.dblClick;
	      $(m_that).trigger(fixedEvent);
	    }

	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get mouse coodinates related to canvas
	   *
	   * @param event
	   * @returns {{x: number, y: number}}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.relMouseCoords = function (event) {
	    if (event.pageX === undefined || event.pageY === undefined) {
	      throw 'Missing attributes pageX and pageY on the event';
	    }

	    var totalOffsetX = 0,
	        totalOffsetY = 0,
	        canvasX = 0,
	        canvasY = 0,
	        currentElement = m_canvas;

	    do {
	      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
	      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
	      currentElement = currentElement.offsetParent;
	    } while (currentElement);

	    canvasX = event.pageX - totalOffsetX;
	    canvasY = event.pageY - totalOffsetY;

	    return {
	      x: canvasX,
	      y: canvasY
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function () {
	    m_renderWindow.render();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind canvas mouse events to their default handlers
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bindEventHandlers = function () {
	    $(m_canvas).on('mousedown', this.handleMouseDown);
	    $(m_canvas).on('mouseup', this.handleMouseUp);
	    $(m_canvas).on('mousemove', this.handleMouseMove);
	    $(m_canvas).on('mousewheel', this.handleMouseWheel);
	    $(m_canvas).on('contextmenu', this.handleContextMenu);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo earlier binded  handlers for canvas mouse events
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.unbindEventHandlers = function () {
	    $(m_canvas).off('mousedown', this.handleMouseDown);
	    $(m_canvas).off('mouseup', this.handleMouseUp);
	    $(m_canvas).off('mousemove', this.handleMouseMove);
	    $(m_canvas).off('mousewheel', this.handleMouseWheel);
	    $(m_canvas).off('contextmenu', this.handleContextMenu);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    this.bindEventHandlers();
	    m_renderWindow.addRenderer(m_renderer);
	  };

	  this._init();
	  return this;
	};

	inherit(vgl.viewer, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class shader
	 *
	 * @param type
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.shader = function (type) {
	  'use strict';

	  if (!(this instanceof vgl.shader)) {
	    return new vgl.shader(type);
	  }
	  vgl.object.call(this);

	  var m_shaderContexts = [],
	      m_shaderType = type,
	      m_shaderSource = '';

	  /**
	   * A shader can be associated with multiple contexts.  Each context needs to
	   * be compiled and attached separately.  These are tracked in the
	   * m_shaderContexts array.
	   *
	   * @param renderState a renderState that includes a m_context value.
	   * @return an object with context, compileTimestamp, and, if compiled, a
	   *    shaderHandle entry.
	   */
	  this._getContextEntry = function (renderState) {
	    var context = renderState.m_context, i, entry;
	    for (i = 0; i < m_shaderContexts.length; i += 1) {
	      if (m_shaderContexts[i].context === context) {
	        return m_shaderContexts[i];
	      }
	    }
	    entry = {
	      context: context,
	      compileTimestamp: vgl.timestamp()
	    };
	    m_shaderContexts.push(entry);
	    return entry;
	  };

	  /**
	   * Remove the context from the list of tracked contexts.  This allows the
	   * associated shader handle to be GCed.  Does nothing if the context is not
	   * in the list of tracked contexts.
	   *
	   * @param renderState a renderState that includes a m_context value.
	   */
	  this.removeContext = function (renderState) {
	    var context = renderState.m_context, i;
	    for (i = 0; i < m_shaderContexts.length; i += 1) {
	      if (m_shaderContexts[i].context === context) {
	        m_shaderContexts.splice(i, 1);
	        return;
	      }
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get shader handle
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.shaderHandle = function (renderState) {
	    var entry = this._getContextEntry(renderState);
	    return entry.shaderHandle;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get type of the shader
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.shaderType = function () {
	    return m_shaderType;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get shader source
	   *
	   * @returns {string}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.shaderSource = function () {
	    return m_shaderSource;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set shader source
	   *
	   * @param {string} source
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setShaderSource = function (source) {
	    m_shaderSource = source;
	    this.modified();
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compile the shader
	   *
	   * @returns {null}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.compile = function (renderState) {
	    var entry = this._getContextEntry(renderState);
	    if (this.getMTime() < entry.compileTimestamp.getMTime()) {
	      return entry.shaderHandle;
	    }

	    renderState.m_context.deleteShader(entry.shaderHandle);
	    entry.shaderHandle = renderState.m_context.createShader(m_shaderType);
	    renderState.m_context.shaderSource(entry.shaderHandle, m_shaderSource);
	    renderState.m_context.compileShader(entry.shaderHandle);

	    // See if it compiled successfully
	    if (!renderState.m_context.getShaderParameter(entry.shaderHandle,
	        vgl.GL.COMPILE_STATUS)) {
	      console.log('[ERROR] An error occurred compiling the shaders: ' +
	                  renderState.m_context.getShaderInfoLog(entry.shaderHandle));
	      console.log(m_shaderSource);
	      renderState.m_context.deleteShader(entry.shaderHandle);
	      return null;
	    }

	    entry.compileTimestamp.modified();

	    return entry.shaderHandle;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Attach shader to the program
	   *
	   * @param programHandle
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.attachShader = function (renderState, programHandle) {
	    renderState.m_context.attachShader(
	        programHandle, this.shaderHandle(renderState));
	  };
	};

	inherit(vgl.shader, vgl.object);

	/* We can use the same shader multiple times if it is identical.  This caches
	 * the last N shaders and will reuse them when possible.  The cache keeps the
	 * most recently requested shader at the front.  If you are doing anything more
	 * to a shader then creating it and setting its source once, do not use this
	 * cache.
	 */
	(function () {
	  'use strict';
	  var m_shaderCache = [],
	      m_shaderCacheMaxSize = 10;

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get a shader from the cache.  Create a new shader if necessary using a
	   * specific source.
	   *
	   * @param type One of vgl.GL.*_SHADER
	   * @param context the GL context for the shader.
	   * @param {string} source the source code of the shader.
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  vgl.getCachedShader = function (type, context, source) {
	    for (var i = 0; i < m_shaderCache.length; i += 1) {
	      if (m_shaderCache[i].type === type &&
	          m_shaderCache[i].context === context &&
	          m_shaderCache[i].source === source) {
	        if (i) {
	          m_shaderCache.splice(0, 0, m_shaderCache.splice(i, 1)[0]);
	        }
	        return m_shaderCache[0].shader;
	      }
	    }
	    var shader = new vgl.shader(type);
	    shader.setShaderSource(source);
	    m_shaderCache.unshift({
	      type: type,
	      context: context,
	      source: source,
	      shader: shader
	    });
	    if (m_shaderCache.length >= m_shaderCacheMaxSize) {
	      m_shaderCache.splice(m_shaderCacheMaxSize,
	                           m_shaderCache.length - m_shaderCacheMaxSize);
	    }
	    return shader;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Clear the shader cache.
	   *
	   * @param context the GL context to clear, or null for clear all.
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  vgl.clearCachedShaders = function (context) {
	    for (var i = m_shaderCache.length - 1; i >= 0; i -= 1) {
	      if (context === null || context === undefined ||
	          m_shaderCache[i].context === context) {
	        m_shaderCache.splice(i, 1);
	      }
	    }
	  };
	})();

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit, $*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instace of class shaderProgram
	 *
	 * @class
	 * @returns {vgl.shaderProgram}
	 */
	//////////////////////////////////////////////////////////////////////////////

	var getBaseUrl = (function () {
	  'use strict';
	  var baseUrl = '.';
	  var scripts = document.getElementsByTagName('script');
	  /* When run in certain environments, there may be no scripts loaded.  For
	   * instance, jQuery's $.getScript won't add it to a script tag. */
	  if (scripts.length > 0) {
	    var index = scripts.length - 1;
	    var vglScript = scripts[index];
	    index = vglScript.src.lastIndexOf('/');
	    baseUrl = vglScript.src.substring(0, index);
	  }
	  return function () { return baseUrl; };
	})();

	vgl.shaderProgram = function () {
	  'use strict';

	  if (!(this instanceof vgl.shaderProgram)) {
	    return new vgl.shaderProgram();
	  }
	  vgl.materialAttribute.call(
	    this, vgl.materialAttributeType.ShaderProgram);

	  /** @private */
	  var m_this = this,
	      m_programHandle = 0,
	      m_compileTimestamp = vgl.timestamp(),
	      m_bindTimestamp = vgl.timestamp(),
	      m_shaders = [],
	      m_uniforms = [],
	      m_vertexAttributes = {},
	      m_uniformNameToLocation = {},
	      m_vertexAttributeNameToLocation = {};

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a particular shader type using GLSL shader strings from a file
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.loadFromFile = function (type, sourceUrl) {
	    var shader, success = false;
	    $.ajax({
	      url: sourceUrl,
	      type: 'GET',
	      dataType: 'text',
	      async: false,
	      success: function (result) {
	        //console.log(result);
	        shader = vgl.shader(type);
	        shader.setShaderSource(result);
	        m_this.addShader(shader);
	        success = true;
	      }
	    });
	    return success;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a particular shader type using GLSL shader strings from a file
	   * relative to VGL load URL.
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.loadShader = function (type, file) {
	    return this.loadFromFile(type, getBaseUrl() + '/shaders/' + file);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Query uniform location in the program
	   *
	   * @param name
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.queryUniformLocation = function (renderState, name) {
	    return renderState.m_context.getUniformLocation(m_programHandle, name);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Query attribute location in the program
	   *
	   * @param name
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.queryAttributeLocation = function (renderState, name) {
	    return renderState.m_context.getAttribLocation(m_programHandle, name);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add a new shader to the program
	   *
	   * @param shader
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.addShader = function (shader) {
	    if (m_shaders.indexOf(shader) > -1) {
	      return false;
	    }

	    var i;
	    for (i = m_shaders.length - 2; i >= 0; i -= 1) {
	      if (m_shaders[i].shaderType() === shader.shaderType()) {
	        m_shaders.splice(i, 1);
	      }
	    }

	    m_shaders.push(shader);
	    m_this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add a new uniform to the program
	   *
	   * @param uniform
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.addUniform = function (uniform) {
	    if (m_uniforms.indexOf(uniform) > -1) {
	      return false;
	    }

	    m_uniforms.push(uniform);
	    m_this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add a new vertex attribute to the program
	   *
	   * @param attr
	   * @param key
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.addVertexAttribute = function (attr, key) {
	    m_vertexAttributes[key] = attr;
	    m_this.modified();
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get uniform location
	   *
	   * This method does not perform any query into the program but relies on
	   * the fact that it depends on a call to queryUniformLocation earlier.
	   *
	   * @param name
	   * @returns {number}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.uniformLocation = function (name) {
	    return m_uniformNameToLocation[name];
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get attribute location
	   *
	   * This method does not perform any query into the program but relies on the
	   * fact that it depends on a call to queryUniformLocation earlier.
	   *
	   * @param name
	   * @returns {number}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.attributeLocation = function (name) {
	    return m_vertexAttributeNameToLocation[name];
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get uniform object using name as the key
	   *
	   * @param name
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.uniform = function (name) {
	    var i;
	    for (i = 0; i < m_uniforms.length; i += 1) {
	      if (m_uniforms[i].name() === name) {
	        return m_uniforms[i];
	      }
	    }

	    return null;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update all uniforms
	   *
	   * This method should be used directly unless required
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.updateUniforms = function (renderState) {
	    var i;

	    for (i = 0; i < m_uniforms.length; i += 1) {
	      m_uniforms[i].callGL(renderState,
	        m_uniformNameToLocation[m_uniforms[i].name()]);
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Link shader program
	   *
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.link = function (renderState) {
	    renderState.m_context.linkProgram(m_programHandle);

	    // If creating the shader program failed, alert
	    if (!renderState.m_context.getProgramParameter(m_programHandle,
	        vgl.GL.LINK_STATUS)) {
	      console.log('[ERROR] Unable to initialize the shader program.');
	      return false;
	    }

	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Use the shader program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.use = function (renderState) {
	    renderState.m_context.useProgram(m_programHandle);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Peform any initialization required
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this._setup = function (renderState) {
	    if (m_programHandle === 0) {
	      m_programHandle = renderState.m_context.createProgram();
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Peform any clean up required when the program gets deleted
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this._cleanup = function (renderState) {
	    m_this.deleteVertexAndFragment(renderState);
	    m_this.deleteProgram(renderState);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete the shader program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.deleteProgram = function (renderState) {
	    renderState.m_context.deleteProgram(m_programHandle);
	    m_programHandle = 0;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete vertex and fragment shaders
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.deleteVertexAndFragment = function (renderState) {
	    var i;
	    for (i = 0; i < m_shaders.length; i += 1) {
	      renderState.m_context.detachShader(m_shaders[i].shaderHandle(renderState));
	      renderState.m_context.deleteShader(m_shaders[i].shaderHandle(renderState));
	      m_shaders[i].removeContext(renderState);
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compile and link a shader
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.compileAndLink = function (renderState) {
	    var i;

	    if (m_compileTimestamp.getMTime() >= this.getMTime()) {
	      return;
	    }

	    m_this._setup(renderState);

	    // Compile shaders
	    for (i = 0; i < m_shaders.length; i += 1) {
	      m_shaders[i].compile(renderState);
	      m_shaders[i].attachShader(renderState, m_programHandle);
	    }

	    m_this.bindAttributes(renderState);

	    // link program
	    if (!m_this.link(renderState)) {
	      console.log('[ERROR] Failed to link Program');
	      m_this._cleanup(renderState);
	    }

	    m_compileTimestamp.modified();
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind the program with its shaders
	   *
	   * @param renderState
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.bind = function (renderState) {
	    var i = 0;

	    if (m_bindTimestamp.getMTime() < m_this.getMTime()) {

	      // Compile shaders
	      m_this.compileAndLink(renderState);

	      m_this.use(renderState);
	      m_this.bindUniforms(renderState);
	      m_bindTimestamp.modified();
	    } else {
	      m_this.use(renderState);
	    }

	    // Call update callback.
	    for (i = 0; i < m_uniforms.length; i += 1) {
	      m_uniforms[i].update(renderState, m_this);
	    }

	    // Now update values to GL.
	    m_this.updateUniforms(renderState);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo binding of the shader program
	   *
	   * @param renderState
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.undoBind = function (renderState) {
	    // REF https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUseProgram.xml
	    // If program is 0, then the current rendering state refers to an invalid
	    // program object, and the results of vertex and fragment shader execution
	    // due to any glDrawArrays or glDrawElements commands are undefined
	    renderState.m_context.useProgram(null);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind vertex data
	   *
	   * @param renderState
	   * @param key
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.bindVertexData = function (renderState, key) {
	    if (m_vertexAttributes.hasOwnProperty(key)) {
	      m_vertexAttributes[key].bindVertexData(renderState, key);
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo bind vetex data
	   *
	   * @param renderState
	   * @param key
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.undoBindVertexData = function (renderState, key) {
	    if (m_vertexAttributes.hasOwnProperty(key)) {
	      m_vertexAttributes[key].undoBindVertexData(renderState, key);
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind uniforms
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.bindUniforms = function (renderState) {
	    var i;
	    for (i = 0; i < m_uniforms.length; i += 1) {
	      m_uniformNameToLocation[m_uniforms[i].name()] = this
	          .queryUniformLocation(renderState, m_uniforms[i].name());
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind vertex attributes
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.bindAttributes = function (renderState) {
	    var key, name;
	    for (key in m_vertexAttributes) {
	      if (m_vertexAttributes.hasOwnProperty(key)) {
	        name = m_vertexAttributes[key].name();
	        renderState.m_context.bindAttribLocation(m_programHandle, key, name);
	        m_vertexAttributeNameToLocation[name] = key;
	      }
	    }
	  };

	  return m_this;
	};

	inherit(vgl.shaderProgram, vgl.materialAttribute);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global Uint8Array, vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class texture
	 *
	 * @class
	 * @returns {vgl.texture}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.texture = function () {
	  'use strict';

	  if (!(this instanceof vgl.texture)) {
	    return new vgl.texture();
	  }
	  vgl.materialAttribute.call(
	    this, vgl.materialAttributeType.Texture);

	  this.m_width = 0;
	  this.m_height = 0;
	  this.m_depth = 0;

	  this.m_textureHandle = null;
	  this.m_textureUnit = 0;

	  this.m_pixelFormat = vgl.GL.RGBA;
	  this.m_pixelDataType = vgl.GL.UNSIGNED_BYTE;
	  this.m_internalFormat = vgl.GL.RGBA;
	  this.m_nearestPixel = false;

	  this.m_image = null;

	  var m_setupTimestamp = vgl.timestamp(),
	      m_that = this;

	  function activateTextureUnit(renderState) {
	    switch (m_that.m_textureUnit) {
	      case 0:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE0);
	        break;
	      case 1:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE1);
	        break;
	      case 2:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE2);
	        break;
	      case 3:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE3);
	        break;
	      case 4:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE4);
	        break;
	      case 5:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE5);
	        break;
	      case 6:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE6);
	        break;
	      case 7:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE7);
	        break;
	      case 8:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE8);
	        break;
	      case 9:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE9);
	        break;
	      case 10:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE10);
	        break;
	      case 11:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE11);
	        break;
	      case 12:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE12);
	        break;
	      case 13:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE13);
	        break;
	      case 14:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE14);
	        break;
	      case 15:
	        renderState.m_context.activeTexture(vgl.GL.TEXTURE15);
	        break;
	      default:
	        throw '[error] Texture unit ' + m_that.m_textureUnit +
	              ' is not supported';
	    }
	  }

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create texture, update parameters, and bind data
	   *
	   * @param renderState
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setup = function (renderState) {
	    // Activate the texture unit first
	    activateTextureUnit(renderState);

	    renderState.m_context.deleteTexture(this.m_textureHandle);
	    this.m_textureHandle = renderState.m_context.createTexture();
	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, this.m_textureHandle);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MIN_FILTER,
	        this.m_nearestPixel ? vgl.GL.NEAREST : vgl.GL.LINEAR);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MAG_FILTER,
	        this.m_nearestPixel ? vgl.GL.NEAREST : vgl.GL.LINEAR);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);

	    if (this.m_image !== null) {
	      renderState.m_context.pixelStorei(vgl.GL.UNPACK_ALIGNMENT, 1);
	      renderState.m_context.pixelStorei(vgl.GL.UNPACK_FLIP_Y_WEBGL, true);

	      this.updateDimensions();
	      this.computeInternalFormatUsingImage();

	      // console.log('m_internalFormat ' + this.m_internalFormat);
	      // console.log('m_pixelFormat ' + this.m_pixelFormat);
	      // console.log('m_pixelDataType ' + this.m_pixelDataType);

	      // FOR now support only 2D textures
	      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, this.m_internalFormat,
	        this.m_pixelFormat, this.m_pixelDataType, this.m_image);
	    } else {
	      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, this.m_internalFormat,
	        this.m_width, this.m_height, 0, this.m_pixelFormat, this.m_pixelDataType, null);
	    }

	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
	    m_setupTimestamp.modified();
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create texture and if already created use it
	   *
	   * @param renderState
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.bind = function (renderState) {
	    // TODO Call setup via material setup
	    if (this.getMTime() > m_setupTimestamp.getMTime()) {
	      this.setup(renderState);
	    }

	    activateTextureUnit(renderState);
	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, this.m_textureHandle);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Turn off the use of this texture
	   *
	   * @param renderState
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.undoBind = function (renderState) {
	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get image used by the texture
	   *
	   * @returns {vgl.image}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.image = function () {
	    return this.m_image;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set image for the texture
	   *
	   * @param {vgl.image} image
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setImage = function (image) {
	    if (image !== null) {
	      this.m_image = image;
	      this.updateDimensions();
	      this.modified();
	      return true;
	    }

	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get nearest pixel flag for the texture
	   *
	   * @returns boolean
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.nearestPixel = function () {
	    return this.m_nearestPixel;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set nearest pixel flag for the texture
	   *
	   * @param {boolean} nearest pixel flag
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setNearestPixel = function (nearest) {
	    nearest = nearest ? true : false;
	    if (nearest !== this.m_nearestPixel) {
	      this.m_nearestPixel = nearest;
	      this.modified();
	      return true;
	    }
	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get texture unit of the texture
	   *
	   * @returns {number}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.textureUnit = function () {
	    return this.m_textureUnit;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set texture unit of the texture. Default is 0.
	   *
	   * @param {number} unit
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setTextureUnit = function (unit) {
	    if (this.m_textureUnit === unit) {
	      return false;
	    }

	    this.m_textureUnit = unit;
	    this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get width of the texture
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.width = function () {
	    return this.m_width;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set width of the texture
	   *
	   * @param {number} width
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setWidth = function (width) {
	    if (m_that.m_width !== width) {
	      m_that.m_width = width;
	      m_that.modified();
	      return true;
	    }

	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get width of the texture
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.height = function () {
	    return m_that.m_height;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set height of the texture
	   *
	   * @param {number} height
	   * @returns {vgl.texture}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setHeight = function (height) {
	    if (m_that.m_height !== height) {
	      m_that.m_height = height;
	      m_that.modified();
	      return true;
	    }

	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get depth of the texture
	   *
	   * @returns {number}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.depth = function () {
	    return this.m_depth;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set depth of the texture
	   *
	   * @param {number} depth
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setDepth = function (depth) {
	    if (this.m_image === null) {
	      return false;
	    }

	    this.m_depth = depth;
	    this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the texture handle (id) of the texture
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.textureHandle = function () {
	    return this.m_textureHandle;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get internal format of the texture
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.internalFormat = function () {
	    return this.m_internalFormat;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set internal format of the texture
	   *
	   * @param internalFormat
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setInternalFormat = function (internalFormat) {
	    if (this.m_internalFormat !== internalFormat) {
	      this.m_internalFormat = internalFormat;
	      this.modified();
	      return true;
	    }

	    return false;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get pixel format of the texture
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.pixelFormat = function () {
	    return this.m_pixelFormat;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set pixel format of the texture
	   *
	   * @param pixelFormat
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setPixelFormat = function (pixelFormat) {
	    if (this.m_image === null) {
	      return false;
	    }

	    this.m_pixelFormat = pixelFormat;
	    this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get pixel data type
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.pixelDataType = function () {
	    return this.m_pixelDataType;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set pixel data type
	   *
	   * @param pixelDataType
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setPixelDataType = function (pixelDataType) {
	    if (this.m_image === null) {
	      return false;
	    }

	    this.m_pixelDataType = pixelDataType;

	    this.modified();

	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute internal format of the texture
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.computeInternalFormatUsingImage = function () {
	    // Currently image does not define internal format
	    // and hence it's pixel format is the only way to query
	    // information on how color has been stored.
	    // switch (this.m_image.pixelFormat()) {
	    // case vgl.GL.RGB:
	    // this.m_internalFormat = vgl.GL.RGB;
	    // break;
	    // case vgl.GL.RGBA:
	    // this.m_internalFormat = vgl.GL.RGBA;
	    // break;
	    // case vgl.GL.Luminance:
	    // this.m_internalFormat = vgl.GL.Luminance;
	    // break;
	    // case vgl.GL.LuminanceAlpha:
	    // this.m_internalFormat = vgl.GL.LuminanceAlpha;
	    // break;
	    // // Do nothing when image pixel format is none or undefined.
	    // default:
	    // break;
	    // };

	    // TODO Fix this
	    this.m_internalFormat = vgl.GL.RGBA;
	    this.m_pixelFormat = vgl.GL.RGBA;
	    this.m_pixelDataType = vgl.GL.UNSIGNED_BYTE;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update texture dimensions
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.updateDimensions = function () {
	    if (this.m_image !== null) {
	      this.m_width = this.m_image.width;
	      this.m_height = this.m_image.height;
	      this.m_depth = 0; // Only 2D images are supported now
	    }
	  };

	  return this;
	};

	inherit(vgl.texture, vgl.materialAttribute);

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class lookupTable
	 *
	 * @class
	 * @returns {vgl.lookupTable}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.lookupTable = function () {
	  'use strict';

	  if (!(this instanceof vgl.lookupTable)) {
	    return new vgl.lookupTable();
	  }
	  vgl.texture.call(this);

	  var m_setupTimestamp = vgl.timestamp(),
	      m_range = [0, 0];

	  this.m_colorTable = //paraview bwr colortable
	    [0.07514311, 0.468049805, 1, 1,
	     0.247872569, 0.498782363, 1, 1,
	     0.339526309, 0.528909511, 1, 1,
	     0.409505078, 0.558608486, 1, 1,
	     0.468487184, 0.588057293, 1, 1,
	     0.520796675, 0.617435078, 1, 1,
	     0.568724526, 0.646924167, 1, 1,
	     0.613686735, 0.676713218, 1, 1,
	     0.656658579, 0.707001303, 1, 1,
	     0.698372844, 0.738002964, 1, 1,
	     0.739424025, 0.769954435, 1, 1,
	     0.780330104, 0.803121429, 1, 1,
	     0.821573924, 0.837809045, 1, 1,
	     0.863634967, 0.874374691, 1, 1,
	     0.907017747, 0.913245283, 1, 1,
	     0.936129275, 0.938743558, 0.983038586, 1,
	     0.943467973, 0.943498599, 0.943398095, 1,
	     0.990146732, 0.928791426, 0.917447482, 1,
	     1, 0.88332677, 0.861943246, 1,
	     1, 0.833985467, 0.803839606, 1,
	     1, 0.788626485, 0.750707739, 1,
	     1, 0.746206642, 0.701389973, 1,
	     1, 0.70590052, 0.654994046, 1,
	     1, 0.667019783, 0.610806959, 1,
	     1, 0.6289553, 0.568237474, 1,
	     1, 0.591130233, 0.526775617, 1,
	     1, 0.552955184, 0.485962266, 1,
	     1, 0.513776083, 0.445364274, 1,
	     1, 0.472800903, 0.404551679, 1,
	     1, 0.428977855, 0.363073592, 1,
	     1, 0.380759558, 0.320428137, 1,
	     0.961891484, 0.313155629, 0.265499262, 1,
	     0.916482116, 0.236630659, 0.209939162, 1].map(
	             function (x) { return x * 255; });

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create lookup table, initialize parameters, and bind data to it
	   *
	   * @param {vgl.renderState} renderState
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setup = function (renderState) {
	    if (this.textureUnit() === 0) {
	      renderState.m_context.activeTexture(vgl.GL.TEXTURE0);
	    } else if (this.textureUnit() === 1) {
	      renderState.m_context.activeTexture(vgl.GL.TEXTURE1);
	    }

	    renderState.m_context.deleteTexture(this.m_textureHandle);
	    this.m_textureHandle = renderState.m_context.createTexture();
	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, this.m_textureHandle);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MIN_FILTER, vgl.GL.LINEAR);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MAG_FILTER, vgl.GL.LINEAR);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
	    renderState.m_context.pixelStorei(vgl.GL.UNPACK_ALIGNMENT, 1);

	    this.m_width = this.m_colorTable.length / 4;
	    this.m_height = 1;
	    this.m_depth = 0;
	    renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D,
	        0, vgl.GL.RGBA, this.m_width, this.m_height, this.m_depth,
	        vgl.GL.RGBA, vgl.GL.UNSIGNED_BYTE, new Uint8Array(this.m_colorTable));

	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
	    m_setupTimestamp.modified();
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get color table used by the lookup table
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.colorTable = function () {
	    return this.m_colorTable;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set color table used by the lookup table
	   *
	   * @param colors
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setColorTable = function (colors) {
	    if (this.m_colorTable === colors) {
	      return false;
	    }

	    this.m_colorTable = colors;
	    this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get scalar range
	   *
	   * @returns {Array}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.range = function () {
	    return m_range;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set scalar range for the lookup table
	   *
	   * @param range
	   * @returns {boolean}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.setRange = function (range) {
	    if (m_range === range) {
	      return false;
	    }
	    m_range = range;
	    this.modified();
	    return true;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Given a [min,max] range update the lookup table range
	   *
	   * @param range
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.updateRange = function (range) {
	    if (!(range instanceof Array)) {
	      console.log('[error] Invalid data type for range. Requires array [min,max]');
	    }

	    if (range[0] < m_range[0]) {
	      m_range[0] = range[0];
	      this.modified();
	    }

	    if (range[1] > m_range[1]) {
	      m_range[1] = range[1];
	      this.modified();
	    }
	  };

	  return this;
	};

	inherit(vgl.lookupTable, vgl.texture);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, mat4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class uniform
	 *
	 * @param type
	 * @param name
	 * @returns {vgl.uniform} OpenGL uniform encapsulation
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.uniform = function (type, name) {
	  'use strict';

	  if (!(this instanceof vgl.uniform)) {
	    return new vgl.uniform(type, name);
	  }

	  this.getTypeNumberOfComponents = function (type) {
	    switch (type) {
	      case vgl.GL.FLOAT:
	      case vgl.GL.INT:
	      case vgl.GL.BOOL:
	        return 1;

	      case vgl.GL.FLOAT_VEC2:
	      case vgl.GL.INT_VEC2:
	      case vgl.GL.BOOL_VEC2:
	        return 2;

	      case vgl.GL.FLOAT_VEC3:
	      case vgl.GL.INT_VEC3:
	      case vgl.GL.BOOL_VEC3:
	        return 3;

	      case vgl.GL.FLOAT_VEC4:
	      case vgl.GL.INT_VEC4:
	      case vgl.GL.BOOL_VEC4:
	        return 4;

	      case vgl.GL.FLOAT_MAT3:
	        return 9;

	      case vgl.GL.FLOAT_MAT4:
	        return 16;

	      default:
	        return 0;
	    }
	  };

	  var m_type = type,
	      m_name = name,
	      m_dataArray = [];

	  m_dataArray.length = this.getTypeNumberOfComponents(m_type);

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get name of the uniform
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.name = function () {
	    return m_name;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get type of the uniform
	   *
	   * @returns {*}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.type = function () {
	    return m_type;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get value of the uniform
	   *
	   * @returns {Array}
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.get = function () {
	    return m_dataArray;
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set value of the uniform
	   *
	   * @param value
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.set = function (value) {
	    var i = 0, lendata = m_dataArray.length;
	    if (lendata !== 1) {
	      for (i = 0; i < lendata; i += 1) {
	        m_dataArray[i] = value[i];
	      }
	    } else {
	      m_dataArray[0] = value;
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Call GL and pass updated values to the current shader
	   *
	   * @param location
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.callGL = function (renderState, location) {
	    switch (m_type) {
	      case vgl.GL.BOOL:
	      case vgl.GL.INT:
	        renderState.m_context.uniform1iv(location, m_dataArray);
	        break;
	      case vgl.GL.FLOAT:
	        renderState.m_context.uniform1fv(location, m_dataArray);
	        break;
	      case vgl.GL.BOOL_VEC2:
	      case vgl.GL.INT_VEC2:
	        renderState.m_context.uniform2iv(location, m_dataArray);
	        break;
	      case vgl.GL.FLOAT_VEC2:
	        renderState.m_context.uniform2fv(location, m_dataArray);
	        break;
	      case vgl.GL.BOOL_VEC3:
	      case vgl.GL.INT_VEC3:
	        renderState.m_context.uniform3iv(location, m_dataArray);
	        break;
	      case vgl.GL.FLOAT_VEC3:
	        renderState.m_context.uniform3fv(location, m_dataArray);
	        break;
	      case vgl.GL.BOOL_VEC4:
	      case vgl.GL.INT_VEC4:
	        renderState.m_context.uniform4iv(location, m_dataArray);
	        break;
	      case vgl.GL.FLOAT_VEC4:
	        renderState.m_context.uniform4fv(location, m_dataArray);
	        break;
	      case vgl.GL.FLOAT_MAT3:
	        renderState.m_context.uniformMatrix3fv(location, vgl.GL.FALSE, m_dataArray);
	        break;
	      case vgl.GL.FLOAT_MAT4:
	        renderState.m_context.uniformMatrix4fv(location, vgl.GL.FALSE, m_dataArray);
	        break;
	      default:
	        break;
	    }
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Virtual method to update the uniform
	   *
	   * Should be implemented by the derived class.
	   *
	   * @param renderState
	   * @param program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.update = function (renderState, program) {
	    void renderState; /* unused parameter */
	    void program; /* unused parameter */
	    // Should be implemented by the derived class
	  };

	  return this;
	};

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of class modelViewUniform
	 *
	 * @param name
	 * @returns {vgl.modelViewUniform}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.modelViewUniform = function (name) {
	  'use strict';

	  if (!(this instanceof vgl.modelViewUniform)) {
	    return new vgl.modelViewUniform(name);
	  }

	  if (!name) {
	    name = 'modelViewMatrix';
	  }

	  vgl.uniform.call(this, vgl.GL.FLOAT_MAT4, name);

	  this.set(mat4.create());

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the uniform given a render state and shader program
	   *
	   * @param {vgl.renderState} renderState
	   * @param {vgl.shaderProgram} program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.update = function (renderState, program) {
	    void program; /* unused parameter */
	    this.set(renderState.m_modelViewMatrix);
	  };

	  return this;
	};

	inherit(vgl.modelViewUniform, vgl.uniform);

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of class modelViewOriginUniform.
	 *
	 * @param name
	 * @param {array} origin a triplet of floats.
	 * @returns {vgl.modelViewUniform}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.modelViewOriginUniform = function (name, origin) {
	  'use strict';

	  if (!(this instanceof vgl.modelViewOriginUniform)) {
	    return new vgl.modelViewOriginUniform(name, origin);
	  }

	  if (!name) {
	    name = 'modelViewMatrix';
	  }
	  origin = origin || [0, 0, 0];

	  var m_origin = [origin[0], origin[1], origin[2] || 0];

	  vgl.uniform.call(this, vgl.GL.FLOAT_MAT4, name);

	  this.set(mat4.create());

	  /**
	   * Change the origin used by the uniform view matrix.
	   *
	   * @param {array} origin a triplet of floats.
	   */
	  this.setOrigin = function (origin) {
	    origin = origin || [0, 0, 0];
	    m_origin = [origin[0], origin[1], origin[2] || 0];
	  };

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the uniform given a render state and shader program.  This offsets
	   * the modelViewMatrix by the origin, and, if the model view should be
	   * aligned, aligns it appropriately.  The alignment must be done after the
	   * origin offset to maintain precision.
	   *
	   * @param {vgl.renderState} renderState
	   * @param {vgl.shaderProgram} program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.update = function (renderState, program) {
	    void program; /* unused parameter */
	    var view = renderState.m_modelViewMatrix;
	    if (renderState.m_modelViewAlignment) {
	      /* adjust alignment before origin.  Otherwise, a changing origin can
	       * affect the rounding choice and result in a 1 pixe jitter. */
	      var align = renderState.m_modelViewAlignment;
	      /* Don't modify the orignal matrix.  If we are in an environment where
	       * you can't slice an Float32Array, switch to a regular array */
	      view = view.slice ? view.slice() : Array.prototype.slice.call(view);
	      /* view[12] and view[13] are the x and y offsets.  align.round is the
	       * units-per-pixel, and align.dx and .dy are either 0 or half the size of
	       * a unit-per-pixel.  The alignment guarantees that the texels are
	       * aligned with screen pixels. */
	      view[12] = Math.round(view[12] / align.roundx) * align.roundx + align.dx;
	      view[13] = Math.round(view[13] / align.roundy) * align.roundy + align.dy;
	    }
	    view = mat4.translate(mat4.create(), view, m_origin);
	    this.set(view);
	  };

	  return this;
	};

	inherit(vgl.modelViewOriginUniform, vgl.uniform);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class projectionUniform
	 *
	 * @param name
	 * @returns {vgl.projectionUniform}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.projectionUniform = function (name) {
	  'use strict';

	  if (!(this instanceof vgl.projectionUniform)) {
	    return new vgl.projectionUniform(name);
	  }

	  if (!name) {
	    name = 'projectionMatrix';
	  }

	  vgl.uniform.call(this, vgl.GL.FLOAT_MAT4, name);

	  this.set(mat4.create());

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the uniform given a render state and shader program
	   *
	   * @param renderState
	   * @param program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.update = function (renderState, program) {
	    void program; /* unused parameter */
	    this.set(renderState.m_projectionMatrix);
	  };

	  return this;
	};

	inherit(vgl.projectionUniform, vgl.uniform);

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class floatUniform
	 *
	 * @param name
	 * @param value
	 * @returns {vgl.floatUniform}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.floatUniform = function (name, value) {
	  'use strict';

	  if (!(this instanceof vgl.floatUniform)) {
	    return new vgl.floatUniform(name, value);
	  }

	  if (!name) {
	    name = 'floatUniform';
	  }

	  value = value === undefined ? 1.0 : value;

	  vgl.uniform.call(this, vgl.GL.FLOAT, name);

	  this.set(value);
	};

	inherit(vgl.floatUniform, vgl.uniform);

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create new instance of class normalMatrixUniform
	 *
	 * @param name
	 * @returns {vgl.normalMatrixUniform}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.normalMatrixUniform = function (name) {
	  'use strict';

	  if (!(this instanceof vgl.normalMatrixUniform)) {
	    return new vgl.normalMatrixUniform(name);
	  }

	  if (!name) {
	    name = 'normalMatrix';
	  }

	  vgl.uniform.call(this, vgl.GL.FLOAT_MAT4, name);

	  this.set(mat4.create());

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the uniform given a render state and shader program
	   *
	   * @param {vgl.renderState} renderState
	   * @param {vgl.shaderProgram} program
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.update = function (renderState, program) {
	    void program; /* unused parameter */
	    this.set(renderState.m_normalMatrix);
	  };

	  return this;
	};

	inherit(vgl.normalMatrixUniform, vgl.uniform);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Keys to identify vertex attributes
	 *
	 * @type {{Position: number, Normal: number, TextureCoordinate: number,
	 *         Color: number, Scalar: number, Scalar2: number, Scalar3: number,
	 *         Scalar4: number, Scalar5: number, Scalar6: number, Scalar7: number,
	 *         CountAttributeIndex: number}}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.vertexAttributeKeys = {
	  'Position' : 0,
	  'Normal' : 1,
	  'TextureCoordinate' : 2,
	  'Color' : 3,
	  'Scalar': 4,
	  'CountAttributeIndex' : 5
	};

	vgl.vertexAttributeKeysIndexed = {
	  'Zero' : 0,
	  'One' : 1,
	  'Two' : 2,
	  'Three' : 3,
	  'Four' : 4,
	  'Five' : 5,
	  'Six' : 6,
	  'Seven' : 7,
	  'Eight' : 8,
	  'Nine' : 9
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of vertexAttribute
	 *
	 * @param {string} name
	 * @returns {vgl.vertexAttribute}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.vertexAttribute = function (name) {
	  'use strict';

	  if (!(this instanceof vgl.vertexAttribute)) {
	    return new vgl.vertexAttribute(name);
	  }

	  var m_name = name;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get name of the vertex attribute
	   *
	   * @returns {string}
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.name = function () {
	    return m_name;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bind vertex data to the given render state
	   *
	   * @param {vgl.renderState} renderState
	   * @param {vgl.vertexAttributeKeys} key
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.bindVertexData = function (renderState, key) {
	    var geometryData = renderState.m_mapper.geometryData(),
	        sourceData = geometryData.sourceData(key),
	        program = renderState.m_material.shaderProgram();

	    renderState.m_context.vertexAttribPointer(program.attributeLocation(
	        m_name), sourceData
	        .attributeNumberOfComponents(key), sourceData.attributeDataType(key),
	                           sourceData.normalized(key), sourceData
	                               .attributeStride(key), sourceData
	                               .attributeOffset(key));

	    renderState.m_context.enableVertexAttribArray(program.attributeLocation(m_name));
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Undo bind vertex data for a given render state
	   *
	   * @param {vgl.renderState} renderState
	   * @param {vgl.vertexAttributeKeys} key
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.undoBindVertexData = function (renderState, key) {
	    key = key; /* unused parameter */

	    var program = renderState.m_material.shaderProgram();

	    renderState.m_context.disableVertexAttribArray(program.attributeLocation(m_name));
	  };
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class source
	 *
	 * @returns {vgl.source}
	 */
	///////////////////////////////////////////////////////////////////////////////
	vgl.source = function () {
	  'use strict';

	  if (!(this instanceof vgl.source)) {
	    return new vgl.source();
	  }

	  vgl.object.call(this);

	  /////////////////////////////////////////////////////////////////////////////
	  /**
	   * Virtual function to create a source instance
	   */
	  /////////////////////////////////////////////////////////////////////////////
	  this.create = function () {
	  };

	  return this;
	};

	inherit(vgl.source, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class planeSource
	 *
	 * @class
	 * @returns {vgl.planeSource}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.planeSource = function () {
	  'use strict';

	  if (!(this instanceof vgl.planeSource)) {
	    return new vgl.planeSource();
	  }
	  vgl.source.call(this);

	  var m_origin = [0.0, 0.0, 0.0],
	      m_point1 = [1.0, 0.0, 0.0],
	      m_point2 = [0.0, 1.0, 0.0],
	      m_normal = [0.0, 0.0, 1.0],
	      m_xresolution = 1,
	      m_yresolution = 1,
	      m_geom = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set origin of the plane
	   *
	   * @param x
	   * @param y
	   * @param z
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setOrigin = function (x, y, z) {
	    m_origin[0] = x;
	    m_origin[1] = y;
	    m_origin[2] = z;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set point that defines the first axis of the plane
	   *
	   * @param x
	   * @param y
	   * @param z
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setPoint1 = function (x, y, z) {
	    m_point1[0] = x;
	    m_point1[1] = y;
	    m_point1[2] = z;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set point that defines the first axis of the plane
	   *
	   * @param x
	   * @param y
	   * @param z
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setPoint2 = function (x, y, z) {
	    m_point2[0] = x;
	    m_point2[1] = y;
	    m_point2[2] = z;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a plane geometry given input parameters
	   *
	   * @returns {null}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.create = function () {
	    m_geom = new vgl.geometryData();

	    var x = [], tc = [], v1 = [], v2 = [],
	        pts = [], i, j, ii, numPts,
	        posIndex = 0, normIndex = 0, colorIndex = 0, texCoordIndex = 0,
	        positions = [], normals = [], colors = [],
	        texCoords = [], indices = [], tristrip = null,
	        sourcePositions = null, sourceColors = null, sourceTexCoords;

	    x.length = 3;
	    tc.length = 2;
	    v1.length = 3;
	    v2.length = 3;
	    pts.length = 3;

	    // Check input
	    for (i = 0; i < 3; i += 1) {
	      v1[i] = m_point1[i] - m_origin[i];
	      v2[i] = m_point2[i] - m_origin[i];
	    }

	    // TODO Compute center and normal
	    // Set things up; allocate memory
	    numPts = (m_xresolution + 1) * (m_yresolution + 1);
	    positions.length = 3 * numPts;
	    normals.length = 3 * numPts;
	    texCoords.length = 2 * numPts;
	    indices.length = numPts;

	    for (i = 0; i < (m_yresolution + 1); i += 1) {
	      tc[1] = i / m_yresolution;

	      for (j = 0; j < (m_xresolution + 1); j += 1) {
	        tc[0] = j / m_xresolution;

	        for (ii = 0; ii < 3; ii += 1) {
	          x[ii] = m_origin[ii] + tc[0] * v1[ii] + tc[1] * v2[ii];
	        }

	        //jshint plusplus: false
	        positions[posIndex++] = x[0];
	        positions[posIndex++] = x[1];
	        positions[posIndex++] = x[2];

	        colors[colorIndex++] = 1.0;
	        colors[colorIndex++] = 1.0;
	        colors[colorIndex++] = 1.0;

	        normals[normIndex++] = m_normal[0];
	        normals[normIndex++] = m_normal[1];
	        normals[normIndex++] = m_normal[2];

	        texCoords[texCoordIndex++] = tc[0];
	        texCoords[texCoordIndex++] = tc[1];
	        //jshint plusplus: true
	      }
	    }

	    /// Generate polygon connectivity
	    for (i = 0; i < m_yresolution; i += 1) {
	      for (j = 0; j < m_xresolution; j += 1) {
	        pts[0] = j + i * (m_xresolution + 1);
	        pts[1] = pts[0] + 1;
	        pts[2] = pts[0] + m_xresolution + 2;
	        pts[3] = pts[0] + m_xresolution + 1;
	      }
	    }

	    for (i = 0; i < numPts; i += 1) {
	      indices[i] = i;
	    }

	    tristrip = new vgl.triangleStrip();
	    tristrip.setIndices(indices);

	    sourcePositions = vgl.sourceDataP3fv();
	    sourcePositions.pushBack(positions);

	    sourceColors = vgl.sourceDataC3fv();
	    sourceColors.pushBack(colors);

	    sourceTexCoords = vgl.sourceDataT2fv();
	    sourceTexCoords.pushBack(texCoords);

	    m_geom.addSource(sourcePositions);
	    m_geom.addSource(sourceColors);
	    m_geom.addSource(sourceTexCoords);
	    m_geom.addPrimitive(tristrip);

	    return m_geom;
	  };
	};

	inherit(vgl.planeSource, vgl.source);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class pointSource
	 *
	 * @class
	 * @returns {vgl.pointSource}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.pointSource = function () {
	  'use strict';

	  if (!(this instanceof vgl.pointSource)) {
	    return new vgl.pointSource();
	  }
	  vgl.source.call(this);

	  var m_this = this,
	      m_positions = [],
	      m_colors = [],
	      m_textureCoords = [],
	      m_size = [],
	      m_geom = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get positions for the points
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getPositions = function () {
	    return m_positions;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set positions for the source
	   *
	   * @param positions
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setPositions = function (positions) {
	    if (positions instanceof Array) {
	      m_positions = positions;
	    } else {
	      console
	          .log('[ERROR] Invalid data type for positions. Array is required.');
	    }
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get colors for the points
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getColors = function () {
	    return m_colors;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set colors for the points
	   *
	   * @param colors
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setColors = function (colors) {
	    if (colors instanceof Array) {
	      m_colors = colors;
	    } else {
	      console.log('[ERROR] Invalid data type for colors. Array is required.');
	    }

	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get size for the points
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getSize = function () {
	    return m_size;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set colors for the points
	   *
	   * @param colors
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setSize = function (size) {
	    m_size = size;
	    this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set texture coordinates for the points
	   *
	   * @param texcoords
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setTextureCoordinates = function (texcoords) {
	    if (texcoords instanceof Array) {
	      m_textureCoords = texcoords;
	    } else {
	      console.log('[ERROR] Invalid data type for ' +
	                  'texture coordinates. Array is required.');
	    }
	    m_this.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a point geometry given input parameters
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.create = function () {
	    m_geom = new vgl.geometryData();

	    if (m_positions.length % 3 !== 0) {
	      console.log('[ERROR] Invalid length of the points array');
	      return;
	    }

	    var numPts = m_positions.length / 3,
	        i = 0,
	        indices = [],
	        pointsPrimitive,
	        sourcePositions,
	        sourceColors,
	        sourceTexCoords,
	        sourceSize;

	    indices.length = numPts;
	    for (i = 0; i < numPts; i += 1) {
	      indices[i] = i;
	    }

	    /// Generate array of size if needed
	    sourceSize = vgl.sourceDataDf();
	    if (numPts !== m_size.length) {
	      for (i = 0; i < numPts; i += 1) {
	        sourceSize.pushBack(m_size);
	      }
	    } else {
	      sourceSize.setData(m_size);
	    }
	    m_geom.addSource(sourceSize);

	    pointsPrimitive = new vgl.points();
	    pointsPrimitive.setIndices(indices);

	    sourcePositions = vgl.sourceDataP3fv();
	    sourcePositions.pushBack(m_positions);
	    m_geom.addSource(sourcePositions);

	    if ((m_colors.length > 0) && m_colors.length === m_positions.length) {
	      sourceColors = vgl.sourceDataC3fv();
	      sourceColors.pushBack(m_colors);
	      m_geom.addSource(sourceColors);
	    } else if ((m_colors.length > 0) && m_colors.length !== m_positions.length) {
	      console
	          .log('[ERROR] Number of colors are different than number of points');
	    }

	    if (m_textureCoords.length > 0 &&
	        m_textureCoords.length === m_positions.length) {
	      sourceTexCoords = vgl.sourceDataT2fv();
	      sourceTexCoords.pushBack(m_textureCoords);
	      m_geom.addSource(sourceTexCoords);
	    } else if (m_textureCoords.length > 0 &&
	        (m_textureCoords.length / 2) !== (m_positions.length / 3)) {
	      console
	          .log('[ERROR] Number of texture coordinates are different than ' +
	               'number of points');
	    }

	    m_geom.addPrimitive(pointsPrimitive);

	    return m_geom;
	  };
	};

	inherit(vgl.pointSource, vgl.source);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class lineSource
	 *
	 * @class
	 * @returns {vgl.lineSource}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.lineSource = function (positions, colors) {
	  'use strict';

	  if (!(this instanceof vgl.lineSource)) {
	    return new vgl.lineSource();
	  }
	  vgl.source.call(this);

	  var m_positions = positions,
	      m_colors = colors;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set start positions for the lines
	   *
	   * @param positions
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setPositions = function (positions) {
	    if (positions instanceof Array) {
	      m_positions = positions;
	      this.modified();
	      return true;
	    }

	    console
	      .log('[ERROR] Invalid data type for positions. Array is required.');
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set colors for the lines
	   *
	   * @param colors
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setColors = function (colors) {
	    if (colors instanceof Array) {
	      m_colors = colors;
	      this.modified();
	      return true;
	    }

	    console.log('[ERROR] Invalid data type for colors. Array is required.');
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a point geometry given input parameters
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.create = function () {
	    if (!m_positions) {
	      console.log('[error] Invalid positions');
	      return;
	    }

	    if (m_positions.length % 3 !== 0) {
	      console.log('[error] Line source requires 3d points');
	      return;
	    }

	    if (m_positions.length % 3 !== 0) {
	      console.log('[ERROR] Invalid length of the points array');
	      return;
	    }

	    var m_geom = new vgl.geometryData(),
	        numPts = m_positions.length / 3,
	        i,
	        indices = [],
	        linesPrimitive,
	        sourcePositions,
	        sourceColors;

	    indices.length = numPts;

	    for (i = 0; i < numPts; i += 1) {
	      indices[i] = i;
	    }

	    linesPrimitive = new vgl.lines();
	    linesPrimitive.setIndices(indices);

	    sourcePositions = vgl.sourceDataP3fv();
	    sourcePositions.pushBack(m_positions);
	    m_geom.addSource(sourcePositions);

	    if (m_colors && (m_colors.length > 0) &&
	         m_colors.length === m_positions.length) {
	      sourceColors = vgl.sourceDataC3fv();
	      sourceColors.pushBack(m_colors);
	      m_geom.addSource(sourceColors);
	    } else if (m_colors && (m_colors.length > 0) &&
	             m_colors.length !== m_positions.length) {
	      console
	        .log('[error] Number of colors are different than number of points');
	    }

	    m_geom.addPrimitive(linesPrimitive);

	    return m_geom;
	  };
	};

	inherit(vgl.lineSource, vgl.source);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global document, vgl, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class utils
	 *
	 * Utility class provides helper functions such as functions to create
	 * shaders, geometry etc.
	 *
	 * @returns {vgl.utils}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils = function () {
	  'use strict';

	  if (!(this instanceof vgl.utils)) {
	    return new vgl.utils();
	  }
	  vgl.object.call(this);

	  return this;
	};

	inherit(vgl.utils, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Helper function to compute power of 2 number
	 *
	 * @param value
	 * @param pow
	 *
	 * @returns {number}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.computePowerOfTwo = function (value, pow) {
	  'use strict';
	  pow = pow || 1;
	  while (pow < value) {
	    pow *= 2;
	  }
	  return pow;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of default vertex shader that uses a texture
	 *
	 * Helper function to create default vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createTextureVertexShader = function (context) {
	  'use strict';
	  var vertexShaderSource = [
	    'attribute vec3 vertexPosition;',
	    'attribute vec3 textureCoord;',
	    'uniform mediump float pointSize;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'varying highp vec3 iTextureCoord;',
	    'void main(void)',
	    '{',
	    'gl_PointSize = pointSize;',
	    'gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    ' iTextureCoord = textureCoord;', '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of default fragment shader that uses a texture
	 *
	 * Helper function to create default fragment shader with sampler
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createTextureFragmentShader = function (context) {
	  'use strict';
	  var fragmentShaderSource = [
	    'varying highp vec3 iTextureCoord;',
	    'uniform sampler2D sampler2d;',
	    'uniform mediump float opacity;',
	    'void main(void) {',
	    'gl_FragColor = vec4(texture2D(sampler2d, vec2(iTextureCoord.s, ' +
	                        'iTextureCoord.t)).xyz, opacity);',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create variation of createTextureFragmentShader which uses texture alpha
	 *
	 * Helper function to create default fragment shader with sampler
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createRgbaTextureFragmentShader = function (context) {
	  'use strict';
	  var fragmentShaderSource = [
	    'varying highp vec3 iTextureCoord;',
	    'uniform sampler2D sampler2d;',
	    'uniform mediump float opacity;',
	    'void main(void) {',
	    '  mediump vec4 color = vec4(texture2D(sampler2d, vec2(' +
	                                'iTextureCoord.s, iTextureCoord.t)).xyzw);',
	    '  color.w *= opacity;',
	    '  gl_FragColor = color;',
	    '}'
	  ].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of default vertex shader
	 *
	 * Helper function to create default vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createVertexShader = function (context) {
	  'use strict';
	  var vertexShaderSource = [
	    'attribute vec3 vertexPosition;',
	    'attribute vec3 vertexColor;',
	    'uniform mediump float pointSize;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'varying mediump vec3 iVertexColor;',
	    'varying highp vec3 iTextureCoord;',
	    'void main(void)',
	    '{',
	    'gl_PointSize = pointSize;',
	    'gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    ' iVertexColor = vertexColor;', '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of default vertex shader
	 *
	 * Helper function to create default vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPointVertexShader = function (context) {
	  'use strict';
	  var vertexShaderSource = [
	    'attribute vec3 vertexPosition;',
	    'attribute vec3 vertexColor;',
	    'attribute float vertexSize;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'varying mediump vec3 iVertexColor;',
	    'varying highp vec3 iTextureCoord;',
	    'void main(void)',
	    '{',
	    'gl_PointSize =  vertexSize;',
	    'gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    ' iVertexColor = vertexColor;', '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of vertex shader with a solid color
	 *
	 * Helper function to create default vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createVertexShaderSolidColor = function (context) {
	  'use strict';
	  var vertexShaderSource = [
	    'attribute vec3 vertexPosition;',
	    'uniform mediump float pointSize;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'void main(void)',
	    '{',
	    'gl_PointSize = pointSize;',
	    'gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of vertex shader that passes values through
	 * for color mapping
	 *
	 * Helper function to create default vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createVertexShaderColorMap = function (context, min, max) {
	  'use strict';
	  min = min; /* unused parameter */
	  max = max; /* unused parameter */
	  var vertexShaderSource = [
	    'attribute vec3 vertexPosition;',
	    'attribute float vertexScalar;',
	    'uniform mediump float pointSize;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'uniform float lutMin;',
	    'uniform float lutMax;',
	    'varying mediump float iVertexScalar;',
	    'void main(void)',
	    '{',
	    'gl_PointSize = pointSize;',
	    'gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    'iVertexScalar = (vertexScalar-lutMin)/(lutMax-lutMin);',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of default fragment shader
	 *
	 * Helper function to create default fragment shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createFragmentShader = function (context) {
	  'use strict';
	  var fragmentShaderSource = ['varying mediump vec3 iVertexColor;',
	                              'uniform mediump float opacity;',
	                              'void main(void) {',
	                              'gl_FragColor = vec4(iVertexColor, opacity);',
	                              '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a Phong vertex shader
	 *
	 * Helper function to create Phong vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPhongVertexShader = function (context) {
	  'use strict';
	  var vertexShaderSource = [
	    'attribute highp vec3 vertexPosition;',
	    'attribute mediump vec3 vertexNormal;',
	    'attribute mediump vec3 vertexColor;',

	    'uniform highp mat4 projectionMatrix;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 normalMatrix;',

	    'varying highp vec4 varPosition;',
	    'varying mediump vec3 varNormal;',
	    'varying mediump vec3 varVertexColor;',

	    'void main(void)',
	    '{',
	    'varPosition = modelViewMatrix * vec4(vertexPosition, 1.0);',
	    'gl_Position = projectionMatrix * varPosition;',
	    'varNormal = vec3(normalMatrix * vec4(vertexNormal, 0.0));',
	    'varVertexColor = vertexColor;',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of Phong fragment shader
	 *
	 * Helper function to create Phong fragment shader
	 *
	 * NOTE: Shader assumes directional light
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPhongFragmentShader = function (context) {
	  'use strict';
	  var fragmentShaderSource = [
	    'uniform mediump float opacity;',
	    'precision mediump float;',
	    'varying vec3 varNormal;',
	    'varying vec4 varPosition;',
	    'varying mediump vec3 varVertexColor;',
	    'const vec3 lightPos = vec3(0.0, 0.0,10000.0);',
	    'const vec3 ambientColor = vec3(0.01, 0.01, 0.01);',
	    'const vec3 specColor = vec3(0.0, 0.0, 0.0);',

	    'void main() {',
	    'vec3 normal = normalize(varNormal);',
	    'vec3 lightDir = normalize(lightPos);',
	    'vec3 reflectDir = -reflect(lightDir, normal);',
	    'vec3 viewDir = normalize(-varPosition.xyz);',

	    'float lambertian = max(dot(lightDir, normal), 0.0);',
	    'vec3 color = vec3(0.0);',
	    'if(lambertian > 0.0) {',
	    '  color = lambertian * varVertexColor;',
	    '}',
	    'gl_FragColor = vec4(color * opacity, 1.0 - opacity);',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of fragment shader with an assigned constant color.
	 *
	 * Helper function to create default fragment shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createFragmentShaderSolidColor = function (context, color) {
	  'use strict';
	  var fragmentShaderSource = [
	    'uniform mediump float opacity;',
	    'void main(void) {',
	    'gl_FragColor = vec4(' + color[0] + ',' + color[1] + ',' + color[2] + ', opacity);',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of fragment shader that maps values into colors bia lookup table
	 *
	 * Helper function to create default fragment shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createFragmentShaderColorMap = function (context) {
	  'use strict';
	  var fragmentShaderSource = [
	    'varying mediump float iVertexScalar;',
	    'uniform sampler2D sampler2d;',
	    'uniform mediump float opacity;',
	    'void main(void) {',
	    'gl_FragColor = vec4(texture2D(sampler2d, vec2(iVertexScalar, ' +
	            '0.0)).xyz, opacity);',
	    '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of vertex shader for point sprites
	 *
	 * Helper function to create default point sprites vertex shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPointSpritesVertexShader = function (context) {
	  'use strict';
	  var vertexShaderSource = [
	    'attribute vec3 vertexPosition;',
	    'attribute vec3 vertexColor;',
	    'uniform mediump vec2 pointSize;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'uniform float height;',
	    'varying mediump vec3 iVertexColor;',
	    'varying highp float iVertexScalar;',
	    'void main(void)',
	    '{',
	    'mediump float realPointSize = pointSize.y;',
	    'if (pointSize.x > pointSize.y) {',
	    '  realPointSize = pointSize.x;}',
	    'gl_PointSize = realPointSize ;',
	    'iVertexScalar = vertexPosition.z;',
	    'gl_Position = projectionMatrix * modelViewMatrix * ' +
	            'vec4(vertexPosition.xy, height, 1.0);',
	    ' iVertexColor = vertexColor;', '}'].join('\n');
	  return vgl.getCachedShader(vgl.GL.VERTEX_SHADER, context,
	                             vertexShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of fragment shader for point sprites
	 *
	 * Helper function to create default point sprites fragment shader
	 *
	 * @param context
	 * @returns {vgl.shader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPointSpritesFragmentShader = function (context) {
	  'use strict';
	  var fragmentShaderSource = [
	    'varying mediump vec3 iVertexColor;',
	    'varying highp float iVertexScalar;',
	    'uniform sampler2D opacityLookup;',
	    'uniform highp float lutMin;',
	    'uniform highp float lutMax;',
	    'uniform sampler2D scalarsToColors;',
	    'uniform int useScalarsToColors;',
	    'uniform int useVertexColors;',
	    'uniform mediump vec2 pointSize;',
	    'uniform mediump float vertexColorWeight;',
	    'void main(void) {',
	    'mediump vec2 realTexCoord;',
	    'if (pointSize.x > pointSize.y) {',
	    '  realTexCoord = vec2(1.0, pointSize.y/pointSize.x) * gl_PointCoord;',
	    '} else {',
	    '  realTexCoord = vec2(pointSize.x/pointSize.y, 1.0) * gl_PointCoord;',
	    '}',
	    'highp float texOpacity = texture2D(opacityLookup, realTexCoord).w;',
	    'if (useScalarsToColors == 1) {',
	    '  gl_FragColor = vec4(texture2D(scalarsToColors, vec2((' +
	            'iVertexScalar - lutMin)/(lutMax - lutMin), 0.0)).xyz, ' +
	            'texOpacity);',
	    '} else if (useVertexColors == 1) {',
	    '  gl_FragColor = vec4(iVertexColor, texOpacity);',
	    '} else {',
	    '  gl_FragColor = vec4(texture2D(opacityLookup, realTexCoord).xyz, texOpacity);',
	    '}}'
	  ].join('\n');
	  return vgl.getCachedShader(vgl.GL.FRAGMENT_SHADER, context,
	                             fragmentShaderSource);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of texture material
	 *
	 * Helper function to create a texture material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createTextureMaterial = function (isRgba, origin) {
	  'use strict';
	  var mat = new vgl.material(),
	      blend = new vgl.blend(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createTextureVertexShader(vgl.GL),
	      fragmentShader = null,
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      texCoordVertAttr = new vgl.vertexAttribute('textureCoord'),
	      pointsizeUniform = new vgl.floatUniform('pointSize', 5.0),
	      modelViewUniform,
	      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
	      samplerUniform = new vgl.uniform(vgl.GL.INT, 'sampler2d'),
	      opacityUniform = null;
	  if (origin !== undefined) {
	    modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix',
	                                                      origin);
	  } else {
	    modelViewUniform = new vgl.modelViewUniform('modelViewMatrix');
	  }

	  samplerUniform.set(0);

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(texCoordVertAttr,
	                          vgl.vertexAttributeKeys.TextureCoordinate);
	  prog.addUniform(pointsizeUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);

	  if (isRgba) {
	    fragmentShader = vgl.utils.createRgbaTextureFragmentShader(vgl.GL);
	  } else {
	    fragmentShader = vgl.utils.createTextureFragmentShader(vgl.GL);
	  }
	  opacityUniform = new vgl.floatUniform('opacity', 1.0);
	  prog.addUniform(opacityUniform);

	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);
	  mat.addAttribute(blend);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of geometry material
	 *
	 * Helper function to create geometry material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createGeometryMaterial = function () {
	  'use strict';
	  var mat = new vgl.material(),
	      prog = new vgl.shaderProgram(),
	      pointSize = 5.0,
	      opacity = 1.0,
	      vertexShader = vgl.utils.createVertexShader(vgl.GL),
	      fragmentShader = vgl.utils.createFragmentShader(vgl.GL),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      colorVertAttr = new vgl.vertexAttribute('vertexColor'),
	      pointsizeUniform = new vgl.floatUniform('pointSize', pointSize),
	      opacityUniform = new vgl.floatUniform('opacity', opacity),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix');

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(colorVertAttr, vgl.vertexAttributeKeys.Color);
	  prog.addUniform(pointsizeUniform);
	  prog.addUniform(opacityUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of geometry material
	 *
	 * Helper function to create geometry material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPointGeometryMaterial = function (opacity) {
	  'use strict';
	  opacity = opacity === undefined ? 1.0 : opacity;
	  var mat = new vgl.material(),
	      blend = new vgl.blend(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createPointVertexShader(vgl.GL),
	      fragmentShader = vgl.utils.createFragmentShader(vgl.GL),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      colorVertAttr = new vgl.vertexAttribute('vertexColor'),
	      sizeVertAttr = new vgl.vertexAttribute('vertexSize'),
	      opacityUniform = new vgl.floatUniform('opacity', opacity),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix');

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(colorVertAttr, vgl.vertexAttributeKeys.Color);
	  prog.addVertexAttribute(sizeVertAttr, vgl.vertexAttributeKeys.Scalar);
	  prog.addUniform(opacityUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);
	  mat.addAttribute(blend);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of geometry material with the phong shader
	 *
	 * Helper function to create color phong shaded geometry material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPhongMaterial = function () {
	  'use strict';
	  var mat = new vgl.material(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createPhongVertexShader(vgl.GL),
	      fragmentShader = vgl.utils.createPhongFragmentShader(vgl.GL),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      normalVertAttr = new vgl.vertexAttribute('vertexNormal'),
	      colorVertAttr = new vgl.vertexAttribute('vertexColor'),
	      opacityUniform = new vgl.floatUniform('opacity', 1.0),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      normalUniform = new vgl.normalMatrixUniform('normalMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix');

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(normalVertAttr, vgl.vertexAttributeKeys.Normal);
	  prog.addVertexAttribute(colorVertAttr, vgl.vertexAttributeKeys.Color);
	  prog.addUniform(opacityUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addUniform(normalUniform);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  //mat.addAttribute(blend);
	  mat.addAttribute(prog);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of colored geometry material
	 *
	 * Helper function to create color geometry material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createColorMaterial = function () {
	  'use strict';
	  var mat = new vgl.material(),
	      blend = new vgl.blend(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createVertexShader(vgl.GL),
	      fragmentShader = vgl.utils.createFragmentShader(vgl.GL),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      texCoordVertAttr = new vgl.vertexAttribute('textureCoord'),
	      colorVertAttr = new vgl.vertexAttribute('vertexColor'),
	      pointsizeUniform = new vgl.floatUniform('pointSize', 5.0),
	      opacityUniform = new vgl.floatUniform('opacity', 1.0),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix');

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(colorVertAttr, vgl.vertexAttributeKeys.Color);
	  prog.addVertexAttribute(texCoordVertAttr,
	                          vgl.vertexAttributeKeys.TextureCoordinate);
	  prog.addUniform(pointsizeUniform);
	  prog.addUniform(opacityUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);
	  mat.addAttribute(blend);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of geometry material
	 *
	 * Helper function to create geometry material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createColorMappedMaterial = function (lut) {
	  'use strict';
	  if (!lut) {
	    lut = new vgl.lookupTable();
	  }

	  var scalarRange = lut.range(),
	      mat = new vgl.material(),
	      blend = new vgl.blend(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createVertexShaderColorMap(
	        vgl.GL, scalarRange[0], scalarRange[1]),
	      fragmentShader = vgl.utils.createFragmentShaderColorMap(vgl.GL),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      scalarVertAttr = new vgl.vertexAttribute('vertexScalar'),
	      pointsizeUniform = new vgl.floatUniform('pointSize', 5.0),
	      opacityUniform = new vgl.floatUniform('opacity', 1.0),
	      lutMinUniform = new vgl.floatUniform('lutMin', scalarRange[0]),
	      lutMaxUniform = new vgl.floatUniform('lutMax', scalarRange[1]),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
	      samplerUniform = new vgl.uniform(vgl.GL.FLOAT, 'sampler2d'),
	      lookupTable = lut;

	  samplerUniform.set(0);

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(scalarVertAttr, vgl.vertexAttributeKeys.Scalar);
	  prog.addUniform(pointsizeUniform);
	  prog.addUniform(opacityUniform);
	  prog.addUniform(lutMinUniform);
	  prog.addUniform(lutMaxUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);
	  mat.addAttribute(blend);
	  mat.addAttribute(lookupTable);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Update color mapped material
	 *
	 * @param mat
	 * @param scalarRange
	 * @param lut
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.updateColorMappedMaterial = function (mat, lut) {
	  'use strict';
	  if (!mat) {
	    console.log('[warning] Invalid material. Nothing to update.');
	    return;
	  }

	  if (!lut) {
	    console.log('[warning] Invalid lookup table. Nothing to update.');
	    return;
	  }

	  var lutMin = mat.shaderProgram().uniform('lutMin'),
	      lutMax = mat.shaderProgram().uniform('lutMax');

	  lutMin.set(lut.range()[0]);
	  lutMax.set(lut.range()[1]);

	  // This will replace the existing lookup table
	  mat.setAttribute(lut);
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of solid color material
	 *
	 * Helper function to create geometry material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createSolidColorMaterial = function (color) {
	  'use strict';
	  if (!color) {
	    color = [1.0, 1.0, 1.0];
	  }

	  var mat = new vgl.material(),
	      blend = new vgl.blend(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createVertexShaderSolidColor(vgl.GL),
	      fragmentShader = vgl.utils.createFragmentShaderSolidColor(vgl.GL, color),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      pointsizeUniform = new vgl.floatUniform('pointSize', 5.0),
	      opacityUniform = new vgl.floatUniform('opacity', 1.0),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix');

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addUniform(pointsizeUniform);
	  prog.addUniform(opacityUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);
	  mat.addAttribute(blend);

	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of point sprites material
	 *
	 * Helper function to create point sprites material
	 *
	 * @returns {vgl.material}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPointSpritesMaterial = function (image, lut) {
	  'use strict';
	  var scalarRange = lut === undefined ? [0, 1] : lut.range(),
	      mat = new vgl.material(),
	      blend = new vgl.blend(),
	      prog = new vgl.shaderProgram(),
	      vertexShader = vgl.utils.createPointSpritesVertexShader(vgl.GL),
	      fragmentShader = vgl.utils.createPointSpritesFragmentShader(vgl.GL),
	      posVertAttr = new vgl.vertexAttribute('vertexPosition'),
	      colorVertAttr = new vgl.vertexAttribute('vertexColor'),
	      heightUniform = new vgl.floatUniform('height', 0.0),
	      vertexColorWeightUniform =
	        new vgl.floatUniform('vertexColorWeight', 0.0),
	      lutMinUniform = new vgl.floatUniform('lutMin', scalarRange[0]),
	      lutMaxUniform = new vgl.floatUniform('lutMax', scalarRange[1]),
	      modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
	      samplerUniform = new vgl.uniform(vgl.GL.INT, 'opacityLookup'),
	      scalarsToColors = new vgl.uniform(vgl.GL.INT, 'scalarsToColors'),
	      useScalarsToColors = new vgl.uniform(vgl.GL.INT, 'useScalarsToColors'),
	      useVertexColors = new vgl.uniform(vgl.GL.INT, 'useVertexColors'),
	      pointSize = new vgl.uniform(vgl.GL.FLOAT_VEC2, 'pointSize'),
	      texture = new vgl.texture();

	  samplerUniform.set(0);
	  scalarsToColors.set(1);
	  useScalarsToColors.set(0);
	  useVertexColors.set(0);
	  pointSize.set([1.0, 1.0]);

	  prog.addVertexAttribute(posVertAttr, vgl.vertexAttributeKeys.Position);
	  prog.addVertexAttribute(colorVertAttr, vgl.vertexAttributeKeys.Color);
	  prog.addUniform(heightUniform);
	  prog.addUniform(vertexColorWeightUniform);
	  prog.addUniform(modelViewUniform);
	  prog.addUniform(projectionUniform);
	  prog.addUniform(samplerUniform);
	  prog.addUniform(useVertexColors);
	  prog.addUniform(useScalarsToColors);
	  prog.addUniform(pointSize);
	  prog.addShader(fragmentShader);
	  prog.addShader(vertexShader);
	  mat.addAttribute(prog);
	  mat.addAttribute(blend);

	  if (lut) {
	    prog.addUniform(scalarsToColors);
	    useScalarsToColors.set(1);
	    prog.addUniform(lutMinUniform);
	    prog.addUniform(lutMaxUniform);
	    lut.setTextureUnit(1);
	    mat.addAttribute(lut);
	  }

	  texture.setImage(image);
	  texture.setTextureUnit(0);
	  mat.addAttribute(texture);
	  return mat;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of an actor that contains a plane geometry
	 *
	 * Function to create a plane node This method will create a plane actor
	 * with texture coordinates, eventually normal, and plane material.
	 *
	 * @returns {vgl.actor}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPlane = function (originX, originY, originZ,
	                                 point1X, point1Y, point1Z,
	                                 point2X, point2Y, point2Z) {
	  'use strict';
	  var mapper = new vgl.mapper(),
	      planeSource = new vgl.planeSource(),
	      mat = vgl.utils.createGeometryMaterial(),
	      actor = new vgl.actor();

	  planeSource.setOrigin(originX, originY, originZ);
	  planeSource.setPoint1(point1X, point1Y, point1Z);
	  planeSource.setPoint2(point2X, point2Y, point2Z);

	  mapper.setGeometryData(planeSource.create());
	  actor.setMapper(mapper);
	  actor.setMaterial(mat);

	  return actor;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of an actor that contains a texture plane geometry
	 *
	 * Helper function to create a plane textured node This method will create
	 * a plane actor with texture coordinates, eventually normal, and plane
	 * material.
	 *
	 * @returns {vgl.actor}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createTexturePlane = function (originX, originY, originZ,
	                                        point1X, point1Y, point1Z,
	                                        point2X, point2Y, point2Z,
	                                        isRgba) {
	  'use strict';
	  var mapper = new vgl.mapper(),
	      planeSource = new vgl.planeSource(),
	      mat = vgl.utils.createTextureMaterial(isRgba,
	                                            [originX, originY, originZ]),
	      actor = new vgl.actor();

	  planeSource.setPoint1(point1X - originX, point1Y - originY, point1Z - originZ);
	  planeSource.setPoint2(point2X - originX, point2Y - originY, point2Z - originZ);
	  mapper.setGeometryData(planeSource.create());

	  actor.setMapper(mapper);
	  actor.setMaterial(mat);

	  return actor;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of an actor that contains points
	 *
	 * Helper function to create a point node This method will create a point
	 * actor with texture coordinates, eventually normal, and plane material.
	 *
	 * @returns {vgl.actor}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPoints = function (positions, size, colors, texcoords, opacity) {
	  'use strict';
	  if (!positions) {
	    console.log('[ERROR] Cannot create points without positions');
	    return null;
	  }

	  opacity = opacity === undefined ? 1.0 : opacity;
	  var mapper = new vgl.mapper(),
	      pointSource = new vgl.pointSource(),
	      mat = vgl.utils.createPointGeometryMaterial(opacity),
	      actor = new vgl.actor();

	  pointSource.setPositions(positions);
	  if (colors) {
	    pointSource.setColors(colors);
	  }

	  if (texcoords) {
	    pointSource.setTextureCoordinates(texcoords);
	  }

	  if (size) {
	    pointSource.setSize(size);
	  } else {
	    pointSource.setSize(1.0);
	  }

	  mapper.setGeometryData(pointSource.create());
	  actor.setMapper(mapper);
	  actor.setMaterial(mat);

	  return actor;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of an actor that contains point sprites
	 *
	 * Helper function to create a point sprites node This method will create
	 * a point sprites actor with texture coordinates, normals, and a point sprites
	 * material.
	 *
	 * @returns {vgl.actor}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createPointSprites = function (image, positions, colors,
	                                              texcoords) {
	  'use strict';
	  if (!image) {
	    console.log('[ERROR] Point sprites requires an image');
	    return null;
	  }

	  if (!positions) {
	    console.log('[ERROR] Cannot create points without positions');
	    return null;
	  }

	  var mapper = new vgl.mapper(),
	      pointSource = new vgl.pointSource(),
	      mat = vgl.utils.createPointSpritesMaterial(image),
	      actor = new vgl.actor();

	  pointSource.setPositions(positions);
	  if (colors) {
	    pointSource.setColors(colors);
	  }

	  if (texcoords) {
	    pointSource.setTextureCoordinates(texcoords);
	  }

	  mapper.setGeometryData(pointSource.create());
	  actor.setMapper(mapper);
	  actor.setMaterial(mat);

	  return actor;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create lines given positions, colors, and desired length
	 *
	 * @param positions
	 * @param colors
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createLines = function (positions, colors) {
	  'use strict';
	  if (!positions) {
	    console.log('[ERROR] Cannot create points without positions');
	    return null;
	  }

	  var mapper = new vgl.mapper(),
	      lineSource = new vgl.lineSource(),
	      mat = vgl.utils.createGeometryMaterial(),
	      actor = new vgl.actor();

	  lineSource.setPositions(positions);
	  if (colors) {
	    lineSource.setColors(colors);
	  }

	  mapper.setGeometryData(lineSource.create());
	  actor.setMapper(mapper);
	  actor.setMaterial(mat);

	  return actor;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create color legend
	 *
	 * @param lookupTable
	 * @param width
	 * @param height
	 * @param origin
	 * @param divs
	 * @returns {Array}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.createColorLegend = function (varname, lookupTable, origin,
	                                             width, height, countMajor,
	                                             countMinor) {
	  'use strict';

	  if (!lookupTable) {
	    console.log('[error] Invalid lookup table');
	    return [];
	  }

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create labels for the legend
	   *
	   * @param ticks
	   * @param range
	   * @param divs
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  function createLabels(varname, positions, range) {
	    if (!positions) {
	      console.log('[error] Create labels requires positions (x,y,z) array');
	      return;
	    }

	    if (positions.length % 3 !== 0) {
	      console.log('[error] Create labels require positions array contain 3d points');
	      return;
	    }

	    if (!range) {
	      console.log('[error] Create labels requires Valid range');
	      return;
	    }

	    var actor = null,
	        size = vgl.utils.computePowerOfTwo(48),
	        index = 0,
	        actors = [],
	        origin = [],
	        pt1 = [],
	        pt2 = [],
	        delta = (positions[6] - positions[0]),
	        axisLabelOffset = 4, i;

	    origin.length = 3;
	    pt1.length = 3;
	    pt2.length = 3;

	    // For now just create labels for end points
	    for (i = 0; i < 2; i += 1) {
	      index = i * (positions.length - 3);

	      origin[0] = positions[index] - delta;
	      origin[1] = positions[index + 1] - 2 * delta;
	      origin[2] = positions[index + 2];

	      pt1[0] = positions[index] + delta;
	      pt1[1] = origin[1];
	      pt1[2] = origin[2];

	      pt2[0] = origin[0];
	      pt2[1] = positions[1];
	      pt2[2] = origin[2];

	      actor = vgl.utils.createTexturePlane(
	        origin[0], origin[1], origin[2],
	        pt1[0], pt1[1], pt1[2],
	        pt2[0], pt2[1], pt2[2], true);

	      actor.setReferenceFrame(vgl.boundingObject.ReferenceFrame.Absolute);
	      actor.material().setBinNumber(vgl.material.RenderBin.Overlay);
	      actor.material().addAttribute(vgl.utils.create2DTexture(
	        range[i].toFixed(2).toString(), 12, null));
	      actors.push(actor);
	    }

	    // Create axis label
	    origin[0] = (positions[0] + positions[positions.length - 3] - size) * 0.5;
	    origin[1] = positions[1] + axisLabelOffset;
	    origin[2] = positions[2];

	    pt1[0] = origin[0] + size;
	    pt1[1] = origin[1];
	    pt1[2] = origin[2];

	    pt2[0] = origin[0];
	    pt2[1] = origin[1] + size;
	    pt2[2] = origin[2];

	    actor = vgl.utils.createTexturePlane(
	      origin[0], origin[1], origin[2],
	      pt1[0], pt1[1], pt1[2],
	      pt2[0], pt2[1], pt2[2], true);
	    actor.setReferenceFrame(vgl.boundingObject.ReferenceFrame.Absolute);
	    actor.material().setBinNumber(vgl.material.RenderBin.Overlay);
	    actor.material().addAttribute(vgl.utils.create2DTexture(
	      varname, 24, null));
	    actors.push(actor);

	    return actors;
	  }

	  //////////////////////////////////////////////////////////////////////////////
	  // TODO Currently we assume that the ticks are laid on x-axis
	  // and this is on a 2D plane (ignoring Z axis. For now lets
	  // not draw minor ticks.
	  /**
	   * Create ticks and labels
	   *
	   * @param originX
	   * @param originY
	   * @param originZ
	   * @param pt1X
	   * @param pt1Y
	   * @param pt1Z
	   * @param pt2X
	   * @param pt2Y
	   * @param pt2Z
	   * @param divs
	   * @param heightMajor
	   * @param heightMinor
	   * @returns {Array} Returns array of vgl.actor
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  function createTicksAndLabels(varname, lut,
	                        originX, originY, originZ,
	                        pt1X, pt1Y, pt1Z,
	                        pt2X, pt2Y, pt2Z,
	                        countMajor, countMinor,
	                        heightMajor, heightMinor) {
	    heightMinor = heightMinor; /* unused parameter */
	    var width = pt2X - pt1X,
	        index = null,
	        delta = width / countMajor,
	        positions = [],
	        actors = [];

	    for (index = 0; index <= countMajor; index += 1) {
	      positions.push(pt1X + delta * index);
	      positions.push(pt1Y);
	      positions.push(pt1Z);

	      positions.push(pt1X + delta * index);
	      positions.push(pt1Y + heightMajor);
	      positions.push(pt1Z);
	    }

	    // TODO: Fix this
	    //actor = vgl.utils.createLines(positions, null);
	    //actor.setReferenceFrame(vgl.boundingObject.ReferenceFrame.Absolute);
	    //actor.material().setBinNumber(vgl.material.RenderBin.Overlay);
	    //actors.push(actor);

	    actors = actors.concat(createLabels(varname, positions, lut.range()));
	    return actors;
	  }

	  // TODO Currently we create only one type of legend
	  var pt1X = origin[0] + width,
	      pt1Y = origin[1],
	      pt1Z = 0.0,
	      pt2X = origin[0],
	      pt2Y = origin[1] + height,
	      pt2Z = 0.0,
	      actors = [],
	      actor = null,
	      mat = null,
	      group = vgl.groupNode();

	  actor = vgl.utils.createTexturePlane(
	    origin[0], origin[1], origin[2],
	    pt1X, pt1Y, pt1Z,
	    pt2X, pt2Y, pt2Z, true
	  );

	  mat = actor.material();
	  mat.addAttribute(lookupTable);
	  actor.setMaterial(mat);
	  group.addChild(actor);
	  actor.material().setBinNumber(vgl.material.RenderBin.Overlay);
	  actor.setReferenceFrame(vgl.boundingObject.ReferenceFrame.Absolute);
	  actors.push(actor);
	  actors = actors.concat(createTicksAndLabels(
	                          varname,
	                          lookupTable,
	                          origin[0], origin[1], origin[1],
	                          pt2X, pt1Y, pt1Z,
	                          pt1X, pt1Y, pt1Z,
	                          countMajor, countMinor, 5, 3));

	  // TODO This needs to change so that we can return a group node
	  // which should get appended to the scene graph
	  return actors;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create 2D texture by rendering text using canvas2D context
	 *
	 * @param textToWrite
	 * @param textSize
	 * @param color
	 * @returns {vgl.texture}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.utils.create2DTexture = function (textToWrite, textSize,
	  color, font, alignment, baseline, bold) {
	  'use strict';

	  var canvas = document.getElementById('textRendering'),
	      ctx = null,
	      texture = vgl.texture();

	  font = font || 'sans-serif';
	  alignment = alignment || 'center';
	  baseline = baseline || 'bottom';

	  if (typeof bold === 'undefined') {
	    bold = true;
	  }

	  if (!canvas) {
	    canvas = document.createElement('canvas');
	  }
	  ctx = canvas.getContext('2d');

	  canvas.setAttribute('id', 'textRendering');
	  canvas.style.display = 'none';

	  // Make width and height equal so that we get pretty looking text.
	  canvas.height = vgl.utils.computePowerOfTwo(8 * textSize);
	  canvas.width = canvas.height;

	  ctx.fillStyle = 'rgba(0, 0, 0, 0)';
	  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	  // This determines the text colour, it can take a hex value or rgba value
	  // (e.g. rgba(255,0,0,0.5))
	  ctx.fillStyle = 'rgba(200, 85, 10, 1.0)';

	  // This determines the alignment of text, e.g. left, center, right
	  ctx.textAlign = alignment;

	  // This determines the baseline of the text, e.g. top, middle, bottom
	  ctx.textBaseline = baseline;

	  // This determines the size of the text and the font family used
	  ctx.font = 4 * textSize + 'px ' + font;
	  if (bold) {
	    ctx.font = 'bold ' + ctx.font;
	  }

	  ctx.fillText(textToWrite, canvas.width / 2, canvas.height / 2, canvas.width);

	  texture.setImage(canvas);
	  texture.updateDimensions();

	  return texture;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, vec4, inherit*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class picker
	 *
	 * @class vgl.picker
	 * @returns {vgl.picker}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.picker = function () {
	  'use strict';

	  if (!(this instanceof vgl.picker)) {
	    return new vgl.picker();
	  }
	  vgl.object.call(this);

	  /** @private */
	  var m_actors = [];

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get actors intersected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getActors = function () {
	    return m_actors;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Perform pick operation
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pick = function (selectionX, selectionY, renderer) {
	    // Check if variables are acceptable
	    if (selectionX === undefined) {
	      return 0;
	    }
	    if (selectionY === undefined) {
	      return 0;
	    }
	    if (renderer === undefined) {
	      return 0;
	    }

	    // Clean list of actors intersected previously
	    m_actors = [];

	    //
	    var camera = renderer.camera(),
	        width = renderer.width(),
	        height = renderer.height(),
	        fpoint = camera.focalPoint(),
	        focusWorldPt = vec4.fromValues(fpoint[0], fpoint[1], fpoint[2], 1.0),
	        focusDisplayPt = renderer.worldToDisplay(
	          focusWorldPt, camera.viewMatrix(),
	        camera.projectionMatrix(), width, height),
	        displayPt = vec4.fromValues(selectionX,
	                      selectionY, focusDisplayPt[2], 1.0),
	        // Convert selection point into world coordinates
	        worldPt = renderer.displayToWorld(displayPt, camera.viewMatrix(),
	                    camera.projectionMatrix(), width, height),
	        cameraPos = camera.position(), ray = [], actors, count, i, bb,
	        tmin, tmax, tymin, tymax, tzmin, tzmax, actor;

	    for (i = 0; i < 3; i += 1) {
	      ray[i] = worldPt[i] - cameraPos[i];
	    }

	    // Go through all actors and check if intersects
	    actors = renderer.sceneRoot().children();
	    count = 0;

	    for (i = 0; i < actors.length; i += 1) {
	      actor = actors[i];
	      if (actor.visible() === true) {
	        bb = actor.bounds();
	        // Ray-aabb intersection - Smits' method
	        if (ray[0] >= 0) {
	          tmin = (bb[0] - cameraPos[0]) / ray[0];
	          tmax = (bb[1] - cameraPos[0]) / ray[0];
	        } else {
	          tmin = (bb[1] - cameraPos[0]) / ray[0];
	          tmax = (bb[0] - cameraPos[0]) / ray[0];
	        }
	        if (ray[1] >= 0) {
	          tymin = (bb[2] - cameraPos[1]) / ray[1];
	          tymax = (bb[3] - cameraPos[1]) / ray[1];
	        } else {
	          tymin = (bb[3] - cameraPos[1]) / ray[1];
	          tymax = (bb[2] - cameraPos[1]) / ray[1];
	        }
	        if ((tmin > tymax) || (tymin > tmax)) {
	          //jscs:disable disallowKeywords
	          continue;
	          //jscs:enable disallowKeywords
	        }

	        if (tymin > tmin) {
	          tmin = tymin;
	        }
	        if (tymax < tmax) {
	          tmax = tymax;
	        }
	        if (ray[2] >= 0) {
	          tzmin = (bb[4] - cameraPos[2]) / ray[2];
	          tzmax = (bb[5] - cameraPos[2]) / ray[2];
	        } else {
	          tzmin = (bb[5] - cameraPos[2]) / ray[2];
	          tzmax = (bb[4] - cameraPos[2]) / ray[2];
	        }
	        if ((tmin > tzmax) || (tzmin > tmax)) {
	          //jscs:disable disallowKeywords
	          continue;
	          //jscs:enable disallowKeywords
	        }
	        if (tzmin > tmin) {
	          tmin = tzmin;
	        }
	        if (tzmax < tmax) {
	          tmax = tzmax;
	        }

	        m_actors[count] = actor;
	        count += 1;
	      }
	    }
	    return count;
	  };

	  return this;
	};

	inherit(vgl.picker, vgl.object);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, $*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of shapefile reader
	 *
	 * This contains code that reads a shapefile and produces vgl geometries
	 *
	 * @class
	 * @returns {vgl.shapefileReader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	vgl.shapefileReader = function () {
	  'use strict';

	  if (!(this instanceof vgl.shapefileReader)) {
	    return new vgl.shapefileReader();
	  }

	  var m_that = this;
	  var SHP_NULL = 0;
	  var SHP_POINT = 1;
	  var SHP_POLYGON = 5;
	  var SHP_POLYLINE = 3;

	  this.int8 = function (data, offset) {
	    return data.charCodeAt(offset);
	  };

	  /*jshint bitwise: false */
	  this.bint32 = function (data, offset) {
	    return (
	      ((data.charCodeAt(offset) & 0xff) << 24) +
	        ((data.charCodeAt(offset + 1) & 0xff) << 16) +
	        ((data.charCodeAt(offset + 2) & 0xff) << 8) +
	        (data.charCodeAt(offset + 3) & 0xff)
	    );
	  };

	  this.lint32 = function (data, offset) {
	    return (
	      ((data.charCodeAt(offset + 3) & 0xff) << 24) +
	        ((data.charCodeAt(offset + 2) & 0xff) << 16) +
	        ((data.charCodeAt(offset + 1) & 0xff) << 8) +
	        (data.charCodeAt(offset) & 0xff)
	    );
	  };

	  this.bint16 = function (data, offset) {
	    return (
	      ((data.charCodeAt(offset) & 0xff) << 8) +
	        (data.charCodeAt(offset + 1) & 0xff)
	    );
	  };

	  this.lint16 = function (data, offset) {
	    return (
	      ((data.charCodeAt(offset + 1) & 0xff) << 8) +
	        (data.charCodeAt(offset) & 0xff)
	    );
	  };

	  this.ldbl64 = function (data, offset) {
	    var b0 = data.charCodeAt(offset) & 0xff;
	    var b1 = data.charCodeAt(offset + 1) & 0xff;
	    var b2 = data.charCodeAt(offset + 2) & 0xff;
	    var b3 = data.charCodeAt(offset + 3) & 0xff;
	    var b4 = data.charCodeAt(offset + 4) & 0xff;
	    var b5 = data.charCodeAt(offset + 5) & 0xff;
	    var b6 = data.charCodeAt(offset + 6) & 0xff;
	    var b7 = data.charCodeAt(offset + 7) & 0xff;

	    var sign = 1 - 2 * (b7 >> 7);
	    var exp = (((b7 & 0x7f) << 4) + ((b6 & 0xf0) >> 4)) - 1023;
	    //var frac = (b6 & 0x0f) * Math.pow (2, -4) + b5 * Math.pow (2, -12) + b4 *
	    // Math.pow (2, -20) + b3 * Math.pow (2, -28) + b2 * Math.pow (2, -36) + b1 *
	    // Math.pow (2, -44) + b0 * Math.pow (2, -52);

	    //return sign * (1 + frac) * Math.pow (2, exp);
	    var frac = (b6 & 0x0f) * Math.pow(2, 48) + b5 * Math.pow(2, 40) + b4 *
	                 Math.pow(2, 32) + b3 * Math.pow(2, 24) + b2 *
	                 Math.pow(2, 16) + b1 * Math.pow(2, 8) + b0;

	    return sign * (1 + frac * Math.pow(2, -52)) * Math.pow(2, exp);
	  };

	  this.lfloat32 = function (data, offset) {
	    var b0 = data.charCodeAt(offset) & 0xff;
	    var b1 = data.charCodeAt(offset + 1) & 0xff;
	    var b2 = data.charCodeAt(offset + 2) & 0xff;
	    var b3 = data.charCodeAt(offset + 3) & 0xff;

	    var sign = 1 - 2 * (b3 >> 7);
	    var exp = (((b3 & 0x7f) << 1) + ((b2 & 0xfe) >> 7)) - 127;
	    var frac = (b2 & 0x7f) * Math.pow(2, 16) + b1 * Math.pow(2, 8) + b0;

	    return sign * (1 + frac * Math.pow(2, -23)) * Math.pow(2, exp);
	  };
	  /*jshint bitwise: true */

	  this.str = function (data, offset, length) {
	    var chars = [];
	    var index = offset;
	    while (index < offset + length) {
	      var c = data[index];
	      if (c.charCodeAt(0) !== 0) {
	        chars.push(c);
	      } else {
	        break;
	      }
	      index += 1;
	    }
	    return chars.join('');
	  };

	  this.readHeader = function (data) {
	    var code = this.bint32(data, 0);
	    var length = this.bint32(data, 24);
	    var version = this.lint32(data, 28);
	    var shapetype = this.lint32(data, 32);

	    /*
	    var xmin = this.ldbl64(data, 36);
	    var ymin = this.ldbl64(data, 44);
	    var xmax = this.ldbl64(data, 52);
	    var ymax = this.ldbl64(data, 60);
	    */
	    return {
	      code: code,
	      length: length,
	      version: version,
	      shapetype: shapetype
	      // bounds: new Box (vect (xmin, ymin), vect (xmax, ymax))
	    };
	  };

	  this.loadShx = function (data) {
	    var indices = [];
	    var appendIndex = function (offset) {
	      indices.push(2 * m_that.bint32(data, offset));
	      return offset + 8;
	    };
	    var offset = 100;
	    while (offset < data.length) {
	      offset = appendIndex(offset);
	    }
	    return indices;
	  };

	  this.Shapefile = function (options) {
	    var path = options.path;
	    $.ajax({
	      url: path + '.shx',
	      mimeType: 'text/plain; charset=x-user-defined',
	      success: function (data) {
	        var indices = this.loadShx(data);
	        $.ajax({
	          url: path + '.shp',
	          mimeType: 'text/plain; charset=x-user-defined',
	          success: function (data) {
	            $.ajax({
	              url: path + '.dbf',
	              mimeType: 'text/plain; charset=x-user-defined',
	              success: function (dbf_data) {
	                var layer = this.loadShp(data, dbf_data, indices, options);
	                options.success(layer);
	              }
	            });
	          }
	        });
	      }
	    });
	  };

	  this.localShapefile = function (options) {
	    var shxFile = options.shx;
	    var shpFile = options.shp;
	    var dbfFile = options.dbf;
	    var shxReader = new FileReader();
	    shxReader.onloadend = function () {
	      var indices = m_that.loadShx(shxReader.result);
	      var shpReader = new FileReader();

	      shpReader.onloadend = function () {
	        var shpData = shpReader.result;

	        var dbfReader = new FileReader();
	        dbfReader.onloadend = function () {
	          var dbfData = dbfReader.result;
	          var layer = m_that.loadShp(shpData, dbfData, indices, options);
	          options.success(layer);
	        };
	        dbfReader.readAsBinaryString(dbfFile);
	      };
	      shpReader.readAsBinaryString(shpFile);
	    };
	    shxReader.readAsBinaryString(shxFile);
	  };

	  this.loadDBF = function (data) {
	    var readHeader = function (offset) {
	      var name = m_that.str(data, offset, 10);
	      var type = m_that.str(data, offset + 11, 1);
	      var length = m_that.int8(data, offset + 16);
	      return {
	        name: name,
	        type: type,
	        length: length
	      };
	    };

	    // Level of the dBASE file
	    var level = m_that.int8(data, 0);
	    if (level === 4) {
	      throw 'Level 7 dBASE not supported';
	    }

	    // Date of last update
	    /*
	    var year = m_that.int8(data, 1);
	    var month = m_that.int8(data, 2);
	    var day = m_that.int8(data, 3);
	    */

	    var num_entries = m_that.lint32(data, 4);
	    var header_size = m_that.lint16(data, 8);
	    var record_size = m_that.lint16(data, 10);

	    var FIELDS_START = 32;
	    var HEADER_LENGTH = 32;

	    var header_offset = FIELDS_START;
	    var headers = [];
	    while (header_offset < header_size - 1) {
	      headers.push(readHeader(header_offset));
	      header_offset += HEADER_LENGTH;
	    }

	    var records = [];
	    var record_offset = header_size;
	    while (record_offset < header_size + num_entries * record_size) {
	      var declare = m_that.str(data, record_offset, 1);
	      if (declare === '*') {
	        // Record size in the header include the size of the delete indicator
	        record_offset += record_size;
	      } else {
	        // Move offset to the start of the actual data
	        record_offset += 1;
	        var record = {};
	        for (var i = 0; i < headers.length; i += 1) {
	          var header = headers[i];
	          var value;
	          if (header.type === 'C') {
	            value = m_that.str(data, record_offset, header.length).trim();
	          } else if (header.type === 'N') {
	            value = parseFloat(m_that.str(data, record_offset, header.length));
	          }
	          record_offset += header.length;
	          record[header.name] = value;
	        }
	        records.push(record);
	      }
	    }
	    return records;
	  };

	  this.loadShp = function (data, dbf_data, indices, options) {
	    options = options; /* unused parameter */
	    var features = [];
	    var readRing = function (offset, start, end) {
	      var ring = [];
	      for (var i = end - 1; i >= start; i -= 1) {
	        var x = m_that.ldbl64(data, offset + 16 * i);
	        var y = m_that.ldbl64(data, offset + 16 * i + 8);
	        ring.push([x, y]);
	      }
	      //if (ring.length <= 3)
	      // return [];
	      return ring;
	    };

	    var readRecord = function (offset) {
	      // var index = m_that.bint32(data, offset);
	      // var record_length = m_that.bint32(data, offset + 4);
	      var record_offset = offset + 8;
	      var geom_type = m_that.lint32(data, record_offset);
	      var num_parts, num_points, parts_start, points_start, i,
	          start, end, ring, rings;

	      if (geom_type === SHP_NULL) {
	        console.log('NULL Shape');
	        //return offset + 12;
	      } else if (geom_type === SHP_POINT) {
	        var x = m_that.ldbl64(data, record_offset + 4);
	        var y = m_that.ldbl64(data, record_offset + 12);

	        features.push({
	          type: 'Point',
	          attr: {},
	          geom: [[x, y]]
	        });
	      } else if (geom_type === SHP_POLYGON) {
	        num_parts = m_that.lint32(data, record_offset + 36);
	        num_points = m_that.lint32(data, record_offset + 40);

	        parts_start = offset + 52;
	        points_start = offset + 52 + 4 * num_parts;

	        rings = [];
	        for (i = 0; i < num_parts; i += 1) {
	          start = m_that.lint32(data, parts_start + i * 4);
	          if (i + 1 < num_parts) {
	            end = m_that.lint32(data, parts_start + (i + 1) * 4);
	          } else {
	            end = num_points;
	          }
	          ring = readRing(points_start, start, end);
	          rings.push(ring);
	        }
	        features.push({
	          type: 'Polygon',
	          attr: {},
	          geom: [rings]
	        });
	      } else if (geom_type === SHP_POLYLINE) {
	        num_parts = m_that.lint32(data, record_offset + 36);
	        num_points = m_that.lint32(data, record_offset + 40);

	        parts_start = offset + 52;
	        points_start = offset + 52 + 4 * num_parts;

	        rings = [];
	        for (i = 0; i < num_parts; i += 1) {
	          start = m_that.lint32(data, parts_start + i * 4);
	          if (i + 1 < num_parts) {
	            end = m_that.lint32(data, parts_start + (i + 1) * 4);
	          } else {
	            end = num_points;
	          }
	          ring = readRing(points_start, start, end);
	          rings.push(ring);
	        }
	        features.push({
	          type: 'Polyline',
	          attr: {},
	          geom: [rings]
	        });
	      } else {
	        throw 'Not Implemented: ' + geom_type;
	      }
	      //return offset + 2 * record_length + SHP_HEADER_LEN;
	    };

	    var attr = this.loadDBF(dbf_data), i;

	    //var offset = 100;
	    //while (offset < length * 2) {
	    // offset = readRecord (offset);
	    //}
	    for (i = 0; i < indices.length; i += 1) {
	      var offset = indices[i];
	      readRecord(offset);
	    }

	    var layer = []; //new Layer ();

	    for (i = 0; i < features.length; i += 1) {
	      var feature = features[i];
	      feature.attr = attr[i];
	      layer.push(feature);
	    }
	    return layer;
	  };

	  return this;
	};

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @module vgl
	 */

	/*global vgl, mat4, unescape, Float32Array, Int8Array, Uint16Array*/
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	//
	// vbgModule.vtkReader class
	// This contains code that unpack a json base64 encoded vtkdataset,
	// such as those produced by ParaView's webGL exporter (where much
	// of the code originated from) and convert it to VGL representation.
	//
	//////////////////////////////////////////////////////////////////////////////

	vgl.vtkReader = function () {
	  'use strict';

	  if (!(this instanceof vgl.vtkReader)) {
	    return new vgl.vtkReader();
	  }

	  var m_base64Chars =
	    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'],
	      m_reverseBase64Chars = [],
	      m_vtkRenderedList = {},
	      m_vtkObjectCount = 0,
	      m_vtkScene = null,
	      m_node = null,
	      END_OF_INPUT = -1,
	      m_base64Str = '',
	      m_base64Count = 0,
	      m_pos = 0,
	      m_viewer = null,
	      i = 0;

	  //initialize the array here if not already done.
	  if (m_reverseBase64Chars.length === 0) {
	    for (i = 0; i < m_base64Chars.length; i += 1) {
	      m_reverseBase64Chars[m_base64Chars[i]] = i;
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * ntos
	   *
	   * @param n
	   * @returns unescaped n
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.ntos = function (n) {
	    var unN;

	    unN = n.toString(16);
	    if (unN.length === 1) {
	      unN = '0' + unN;
	    }
	    unN = '%' + unN;

	    return unescape(unN);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * readReverseBase64
	   *
	   * @returns
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readReverseBase64 = function () {
	    var nextCharacter;

	    if (!m_base64Str) {
	      return END_OF_INPUT;
	    }

	    while (true) {
	      if (m_base64Count >= m_base64Str.length) {
	        return END_OF_INPUT;
	      }
	      nextCharacter = m_base64Str.charAt(m_base64Count);
	      m_base64Count += 1;

	      if (m_reverseBase64Chars[nextCharacter]) {
	        return m_reverseBase64Chars[nextCharacter];
	      }
	      if (nextCharacter === 'A') {
	        return 0;
	      }
	    }

	    return END_OF_INPUT;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * decode64
	   *
	   * @param str
	   * @returns result
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.decode64 = function (str) {
	    var result = '',
	        inBuffer = new Array(4),
	        done = false;

	    m_base64Str = str;
	    m_base64Count = 0;

	    while (!done &&
	           (inBuffer[0] = this.readReverseBase64()) !== END_OF_INPUT &&
	           (inBuffer[1] = this.readReverseBase64()) !== END_OF_INPUT) {
	      inBuffer[2] = this.readReverseBase64();
	      inBuffer[3] = this.readReverseBase64();
	      /*jshint bitwise: false */
	      result += this.ntos((((inBuffer[0] << 2) & 0xff) | inBuffer[1] >> 4));
	      if (inBuffer[2] !== END_OF_INPUT) {
	        result += this.ntos((((inBuffer[1] << 4) & 0xff) | inBuffer[2] >> 2));
	        if (inBuffer[3] !== END_OF_INPUT) {
	          result += this.ntos((((inBuffer[2] << 6) & 0xff) | inBuffer[3]));
	        } else {
	          done = true;
	        }
	      } else {
	        done = true;
	      }
	      /*jshint bitwise: true */
	    }

	    return result;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * readNumber
	   *
	   * @param ss
	   * @returns v
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readNumber = function (ss) {
	    //jshint plusplus: false, bitwise: false
	    var v = ((ss[m_pos++]) +
	             (ss[m_pos++] << 8) +
	             (ss[m_pos++] << 16) +
	             (ss[m_pos++] << 24));
	    //jshint plusplus: true, bitwise: true
	    return v;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * readF3Array
	   *
	   * @param numberOfPoints
	   * @param ss
	   * @returns points
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readF3Array = function (numberOfPoints, ss) {
	    var size = numberOfPoints * 4 * 3, test = new Int8Array(size),
	        points = null, i;

	    for (i = 0; i < size; i += 1) {
	      test[i] = ss[m_pos];
	      m_pos += 1;
	    }

	    points = new Float32Array(test.buffer);

	    return points;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * readColorArray
	   *
	   * @param numberOfPoints
	   * @param ss
	   * @param vglcolors
	   * @returns points
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.readColorArray = function (numberOfPoints, ss, vglcolors) {
	    var i, idx = 0, tmp = new Array(numberOfPoints * 3);
	    //jshint plusplus: false
	    for (i = 0; i < numberOfPoints; i += 1) {
	      tmp[idx++] = ss[m_pos++] / 255.0;
	      tmp[idx++] = ss[m_pos++] / 255.0;
	      tmp[idx++] = ss[m_pos++] / 255.0;
	      m_pos++;
	    }
	    //jshint plusplus: true
	    vglcolors.insert(tmp);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * parseObject
	   *
	   * @param buffer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parseObject = function (vtkObject) {
	    var geom = new vgl.geometryData(), mapper = vgl.mapper(), ss = [],
	        type = null, data = null, size, matrix = null, material = null,
	        actor, colorMapData, shaderProg, opacityUniform, lookupTable,
	        colorTable, windowSize, width, height, position;

	    //dehexlify
	    //data = this.decode64(vtkObject.data);
	    data = atob(vtkObject.data);
	    //jshint bitwise: false
	    for (i = 0; i < data.length; i += 1) {
	      ss[i] = data.charCodeAt(i) & 0xff;
	    }
	    //jshint bitwise: true

	    //Determine the Object type
	    m_pos = 0;
	    size = this.readNumber(ss);
	    type = String.fromCharCode(ss[m_pos]);
	    m_pos += 1;
	    geom.setName(type);

	    // Lines
	    if (type === 'L') {
	      matrix = this.parseLineData(geom, ss);
	      material = vgl.utils.createGeometryMaterial();
	    // Mesh
	    } else if (type === 'M') {
	      matrix = this.parseMeshData(geom, ss);
	      material = vgl.utils.createPhongMaterial();
	    // Points
	    } else if (type === 'P') {
	      matrix = this.parsePointData(geom, ss);
	      material = vgl.utils.createGeometryMaterial();
	    // ColorMap
	    } else if (type === 'C') {
	      colorMapData = this.parseColorMapData(geom, ss, size);
	      colorTable = [];

	      for (i = 0; i < colorMapData.colors.length; i += 1) {
	        colorTable.push(colorMapData.colors[i][1]);
	        colorTable.push(colorMapData.colors[i][2]);
	        colorTable.push(colorMapData.colors[i][3]);
	        colorTable.push(colorMapData.colors[i][0] * 255);
	      }

	      lookupTable = new vgl.lookupTable();
	      lookupTable.setColorTable(colorTable);

	      windowSize = m_viewer.renderWindow().windowSize();
	      width = colorMapData.size[0] * windowSize[0];
	      height = colorMapData.size[1] * windowSize[1];

	      position = [colorMapData.position[0] * windowSize[0],
	                  (1 - colorMapData.position[1]) * windowSize[1], 0];
	      position[1] = position[1] - height;

	      // For now hardcode the height
	      height = 30;

	      return vgl.utils.createColorLegend(colorMapData.title,
	          lookupTable, position, width, height, 3, 0);
	    // Unknown
	    } else {
	      console.log('Ignoring unrecognized encoded data type ' + type);
	    }

	    mapper.setGeometryData(geom);

	    //default opacity === solid. If were transparent, set it lower.
	    if (vtkObject.hasTransparency) {
	      shaderProg = material.shaderProgram();
	      opacityUniform = shaderProg.uniform('opacity');
	      console.log('opacity ', vtkObject.opacity);
	      opacityUniform.set(vtkObject.opacity);
	      material.setBinNumber(1000);
	    }

	    actor = vgl.actor();
	    actor.setMapper(mapper);
	    actor.setMaterial(material);
	    actor.setMatrix(mat4.transpose(mat4.create(), matrix));

	    return [actor];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * parseLineData
	   *
	   * @param geom, ss
	   * @returns matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parseLineData = function (geom, ss) {
	    var vglpoints = null, vglcolors = null, vgllines = null,
	        matrix = mat4.create(),
	        numberOfIndex, numberOfPoints, points,
	        temp, index, size, m, i,
	        p = null, idx = 0;

	    numberOfPoints = this.readNumber(ss);
	    p = new Array(numberOfPoints * 3);

	    //Getting Points
	    vglpoints = new vgl.sourceDataP3fv();
	    points = this.readF3Array(numberOfPoints, ss);

	    //jshint plusplus: false
	    for (i = 0; i < numberOfPoints; i += 1) {
	      p[idx++] = points[i * 3];
	      p[idx++] = points[i * 3 + 1];
	      p[idx++] = points[i * 3 + 2];
	    }
	    //jshint plusplus: true
	    vglpoints.insert(p);
	    geom.addSource(vglpoints);

	    //Getting Colors
	    vglcolors = new vgl.sourceDataC3fv();
	    this.readColorArray(numberOfPoints, ss, vglcolors);
	    geom.addSource(vglcolors);

	    //Getting connectivity
	    vgllines = new vgl.lines();
	    geom.addPrimitive(vgllines);
	    numberOfIndex = this.readNumber(ss);

	    temp = new Int8Array(numberOfIndex * 2);
	    for (i = 0; i < numberOfIndex * 2; i += 1) {
	      temp[i] = ss[m_pos];
	      m_pos += 1;
	    }

	    index = new Uint16Array(temp.buffer);
	    vgllines.setIndices(index);
	    vgllines.setPrimitiveType(vgl.GL.LINES);

	    //Getting Matrix
	    size = 16 * 4;
	    temp = new Int8Array(size);
	    for (i = 0; i < size; i += 1) {
	      temp[i] = ss[m_pos];
	      m_pos += 1;
	    }

	    m = new Float32Array(temp.buffer);
	    mat4.copy(matrix, m);

	    return matrix;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * parseMeshData
	   *
	   * @param geom, ss
	   * @returns matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parseMeshData = function (geom, ss) {
	    var vglpoints = null, vglcolors = null,
	        normals = null, matrix = mat4.create(),
	        vgltriangles = null, numberOfIndex, numberOfPoints,
	        points, temp, index, size, m, i,
	        pn = null, idx = 0;

	    numberOfPoints = this.readNumber(ss);
	    pn = new Array(numberOfPoints * 6);
	    //Getting Points
	    vglpoints = new vgl.sourceDataP3N3f();
	    points = this.readF3Array(numberOfPoints, ss);

	    //Getting Normals
	    normals = this.readF3Array(numberOfPoints, ss);
	    //jshint plusplus: false
	    for (i = 0; i < numberOfPoints; i += 1) {
	      pn[idx++] = points[i * 3];
	      pn[idx++] = points[i * 3 + 1];
	      pn[idx++] = points[i * 3 + 2];
	      pn[idx++] = normals[i * 3];
	      pn[idx++] = normals[i * 3 + 1];
	      pn[idx++] = normals[i * 3 + 2];
	    }
	    //jshint plusplus: true
	    vglpoints.insert(pn);
	    geom.addSource(vglpoints);

	    //Getting Colors
	    vglcolors = new vgl.sourceDataC3fv();
	    this.readColorArray(numberOfPoints, ss, vglcolors);
	    geom.addSource(vglcolors);

	    //Getting connectivity
	    temp = [];
	    vgltriangles = new vgl.triangles();
	    numberOfIndex = this.readNumber(ss);

	    temp = new Int8Array(numberOfIndex * 2);
	    for (i = 0; i < numberOfIndex * 2; i += 1) {
	      temp[i] = ss[m_pos];
	      m_pos += 1;
	    }

	    index = new Uint16Array(temp.buffer);
	    vgltriangles.setIndices(index);
	    geom.addPrimitive(vgltriangles);

	    //Getting Matrix
	    size = 16 * 4;
	    temp = new Int8Array(size);
	    for (i = 0; i < size; i += 1) {
	      temp[i] = ss[m_pos];
	      m_pos += 1;
	    }

	    m = new Float32Array(temp.buffer);
	    mat4.copy(matrix, m);

	    return matrix;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * parsePointData
	   *
	   * @param geom, ss
	   * @returns matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parsePointData = function (geom, ss) {
	    var numberOfPoints, points, indices, temp, size,
	        matrix = mat4.create(), vglpoints = null,
	        vglcolors = null, vglVertexes = null, m,
	        p = null, idx = 0;

	    numberOfPoints = this.readNumber(ss);
	    p = new Array(numberOfPoints * 3);

	    //Getting Points and creating 1:1 connectivity
	    vglpoints = new vgl.sourceDataP3fv();
	    points = this.readF3Array(numberOfPoints, ss);

	    indices = new Uint16Array(numberOfPoints);

	    //jshint plusplus: false
	    for (i = 0; i < numberOfPoints; i += 1) {
	      indices[i] = i;
	      p[idx++] = points[i * 3];
	      p[idx++] = points[i * 3 + 1];
	      p[idx++] = points[i * 3 + 2];
	    }
	    //jshint plusplus: true
	    vglpoints.insert(p);
	    geom.addSource(vglpoints);

	    //Getting Colors
	    vglcolors = new vgl.sourceDataC3fv();
	    this.readColorArray(numberOfPoints, ss, vglcolors);
	    geom.addSource(vglcolors);

	    //Getting connectivity
	    vglVertexes = new vgl.points();
	    vglVertexes.setIndices(indices);
	    geom.addPrimitive(vglVertexes);

	    //Getting matrix
	    size = 16 * 4;
	    temp = new Int8Array(size);
	    for (i = 0; i < size; i += 1) {
	      temp[i] = ss[m_pos];
	      m_pos += 1;
	    }

	    m = new Float32Array(temp.buffer);
	    mat4.copy(matrix, m);

	    return matrix;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * parseColorMapData
	   *
	   * @param geom, ss
	   * @returns matrix
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parseColorMapData = function (geom, ss, numColors) {

	    var tmpArray, size, xrgb, i, c, obj = {};

	    // Set number of colors
	    obj.numOfColors = numColors;

	    // Getting Position
	    size = 8;
	    tmpArray = new Int8Array(size);
	    for (i = 0; i < size; i += 1) {
	      tmpArray[i] = ss[m_pos];
	      m_pos += 1;
	    }
	    obj.position = new Float32Array(tmpArray.buffer);

	    // Getting Size
	    size = 8;
	    tmpArray = new Int8Array(size);
	    for (i = 0; i < size; i += 1) {
	      tmpArray[i] = ss[m_pos];
	      m_pos += 1;
	    }
	    obj.size = new Float32Array(tmpArray.buffer);

	    //Getting Colors
	    obj.colors = [];
	    //jshint plusplus: false
	    for (c = 0; c < obj.numOfColors; c += 1) {
	      tmpArray = new Int8Array(4);
	      for (i = 0; i < 4; i += 1) {
	        tmpArray[i] = ss[m_pos];
	        m_pos += 1;
	      }

	      xrgb = [
	        new Float32Array(tmpArray.buffer)[0],
	        ss[m_pos++],
	        ss[m_pos++],
	        ss[m_pos++]
	      ];
	      obj.colors[c] = xrgb;
	    }

	    obj.orientation = ss[m_pos++];
	    obj.numOfLabels = ss[m_pos++];
	    obj.title = '';
	    while (m_pos < ss.length) {
	      obj.title += String.fromCharCode(ss[m_pos++]);
	    }
	    //jshint plusplus: true

	    return obj;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * parseSceneMetadata
	   *
	   * @param data
	   * @returns renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parseSceneMetadata = function (renderer, layer) {

	    var sceneRenderer = m_vtkScene.Renderers[layer],
	        camera = renderer.camera(), bgc, localWidth, localHeight;

	    localWidth = (sceneRenderer.size[0] - sceneRenderer.origin[0]) * m_node.width;
	    localHeight = (sceneRenderer.size[1] - sceneRenderer.origin[1]) * m_node.height;
	    renderer.resize(localWidth, localHeight);

	    /// We are setting the center to the focal point because of
	    /// a possible paraview web bug. The center of rotation isn't
	    /// getting updated correctly on resetCamera.
	    camera.setCenterOfRotation(
	      [sceneRenderer.LookAt[1], sceneRenderer.LookAt[2],
	       sceneRenderer.LookAt[3]]);
	    camera.setViewAngleDegrees(sceneRenderer.LookAt[0]);
	    camera.setPosition(
	      sceneRenderer.LookAt[7], sceneRenderer.LookAt[8],
	      sceneRenderer.LookAt[9]);
	    camera.setFocalPoint(
	      sceneRenderer.LookAt[1], sceneRenderer.LookAt[2],
	      sceneRenderer.LookAt[3]);
	    camera.setViewUpDirection(
	      sceneRenderer.LookAt[4], sceneRenderer.LookAt[5],
	      sceneRenderer.LookAt[6]);

	    if (layer === 0) {
	      bgc = sceneRenderer.Background1;
	      renderer.setBackgroundColor(bgc[0], bgc[1], bgc[2], 1);
	    } else {
	      renderer.setResizable(false);
	    }
	    renderer.setLayer(layer);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * initScene
	   *
	   * @returns viewer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.initScene = function () {
	    var renderer, layer;

	    if (m_vtkScene === null) {
	      return m_viewer;
	    }
	    for (layer = m_vtkScene.Renderers.length - 1; layer >= 0; layer -= 1) {

	      renderer = this.getRenderer(layer);
	      this.parseSceneMetadata(renderer, layer);
	    }

	    return m_viewer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * createViewer - Creates a viewer object.
	   *
	   * @param
	   *
	   * @returns viewer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createViewer = function (node) {
	    var interactorStyle;

	    if (m_viewer === null) {
	      m_node = node;
	      m_viewer = vgl.viewer(node);
	      m_viewer.init();
	      m_viewer.renderWindow().removeRenderer(m_viewer.renderWindow().activeRenderer());
	      m_viewer.renderWindow().addRenderer(new vgl.depthPeelRenderer());
	      m_vtkRenderedList[0] = m_viewer.renderWindow().activeRenderer();
	      m_viewer.renderWindow().resize(node.width, node.height);
	      interactorStyle = vgl.pvwInteractorStyle();
	      m_viewer.setInteractorStyle(interactorStyle);
	    }

	    return m_viewer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * deleteViewer - Deletes the viewer object associated with the reader.
	   *
	   * @returns void
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.deleteViewer = function () {
	    m_vtkRenderedList = {};
	    m_viewer = null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * updateCanvas -
	   *
	   * @param
	   *
	   * @returns void
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateCanvas = function (node) {
	    m_node = node;
	    m_viewer.renderWindow().resize(node.width, node.height);

	    return m_viewer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * clearVtkObjectData - Clear out the list of VTK geometry data.
	   *
	   * @param void
	   * @returns void
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.numObjects = function () {
	    return m_vtkObjectCount;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * getRenderer - Gets (or creates) the renderer for a layer.
	   *
	   * @param layer
	   * @returns renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.getRenderer = function (layer) {
	    var renderer;

	    renderer = m_vtkRenderedList[layer];
	    if (renderer === null || typeof renderer === 'undefined') {
	      renderer = new vgl.renderer();
	      renderer.setResetScene(false);
	      renderer.setResetClippingRange(false);
	      m_viewer.renderWindow().addRenderer(renderer);

	      if (layer !== 0) {
	        renderer.camera().setClearMask(vgl.GL.DepthBufferBit);
	      }

	      m_vtkRenderedList[layer] = renderer;
	    }

	    return renderer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * setVtkScene - Set the VTK scene data for camera initialization.
	   *
	   * @param scene
	   * @returns void
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.setVtkScene = function (scene) {
	    m_vtkScene = scene;
	  };

	  return this;
	};

	vgl.DataBuffers = function (initialSize) {
	  'use strict';
	  if (!(this instanceof vgl.DataBuffers)) {
	    return new vgl.DataBuffers(initialSize);
	  }

	  var data = {};

	  var size;
	  if (!initialSize && initialSize !== 0) {
	    size = 256;
	  } else {
	    size = initialSize;
	  }

	  var current = 0;

	  var copyArray = function (dst, src, start, count) {
	    if (!dst) {
	      throw 'No destination';
	    }
	    if (!start) {
	      start = 0;
	    }
	    if (!count) {
	      count = src.length;
	    }
	    for (var i = 0; i < count; i += 1) {
	      dst[start + i] = src[i];
	    }
	  };

	  var resize = function (min_expand) {
	    var new_size = size;
	    /* If the array would increase substantially, don't just double its
	     * size.  If the array has been increasing gradually, double it as the
	     * expectation is that it will increase again. */
	    if (new_size * 2 < min_expand) {
	      new_size = min_expand;
	    }
	    while (new_size < min_expand) {
	      new_size *= 2;
	    }
	    size = new_size;
	    for (var name in data) {
	      if (data.hasOwnProperty(name)) {
	        var newArray = new Float32Array(new_size * data[name].len);
	        var oldArray = data[name].array;
	        copyArray(newArray, oldArray);
	        data[name].array = newArray;
	        data[name].dirty = true;
	      }
	    }
	  };

	  /**
	   * Allocate a buffer with a name and a specific number of components per
	   * entry.  If a buffer with the specified name already exists, it will be
	   * overwritten.
	   *
	   * @param name: the name of the buffer to create or replace.
	   * @param len: number of components per entry.  Most be a positive integer.
	   */
	  this.create = function (name, len) {
	    if (!len || len < 0) {
	      throw 'Length of buffer must be a positive integer';
	    }
	    var array = new Float32Array(size * len);
	    data[name] = {
	      array: array,
	      len: len,
	      dirty: false
	    };
	    return data[name].array;
	  };

	  this.alloc = function (num) {
	    if ((current + num) >= size) {
	      resize(current + num);
	    }
	    var start = current;
	    current += num;
	    return start;
	  };

	  this.get = function (name) {
	    return data[name].array;
	  };

	  this.write = function (name, array, start, count) {
	    if (start + count > size) {
	      throw 'Write would exceed buffer size';
	    }
	    copyArray(data[name].array, array, start * data[name].len, count * data[name].len);
	    data[name].dirty = true;
	  };

	  this.repeat = function (name, elem, start, count) {
	    if (start + count > size) {
	      throw 'Repeat would exceed buffer size';
	    }
	    for (var i = 0; i < count; i += 1) {
	      copyArray(data[name].array, elem,
	                 (start + i) * data[name].len, data[name].len);
	    }
	    data[name].dirty = true;
	  };

	  this.count = function () {
	    return current;
	  };

	  this.data = function (name) {
	    return data[name].array;
	  };
	};

	////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class renderer *
	 *
	 * @returns {vgl.renderer}
	 */
	////////////////////////////////////////////////////////////////////////////

	vgl.depthPeelRenderer = function () {
	  'use strict';

	  if (!(this instanceof vgl.depthPeelRenderer)) {
	    return new vgl.depthPeelRenderer();
	  }
	  vgl.renderer.call(this);

	  var m_this = this, fbo = [], texID = [], depthTexID = [],
	      colorBlenderTexID, colorBlenderFBOID, setupTime = vgl.timestamp(),
	      fpMaterial = vgl.material(), blMaterial = vgl.material(),
	      fiMaterial = vgl.material(), frontPeelShader = null, blendShader = null,
	      finalShader, NUM_PASSES = 6, m_quad = null, fpwidth, fpheight, blwidth, blheight,
	      fiwidth, fiheight, fpopacity, fibackgroundColor;

	  function drawFullScreenQuad(renderState, material) {
	    m_quad.setMaterial(material);

	    renderState.m_mapper = m_quad.mapper();
	    renderState.m_material = material;

	    renderState.m_material.bind(renderState);
	    renderState.m_mapper.render(renderState);
	    renderState.m_material.undoBind(renderState);

	    m_quad.setMaterial(null);
	  }

	  function initScreenQuad(renderState, width, height) {
	    console.log(width);
	    console.log(height);
	    m_quad = vgl.utils.createPlane(0.0, 0.0, 0.0,
	                                   1.0, 0.0, 0.0,
	                                   0.0, 1.0, 0.0);
	  }

	  function initShaders(renderState) {
	    var fpmv, fpproj, fpvertex, fpcolor, fpdepthTex, fpnormal, fpnr,
	        blvertex, blColorSamp, blPrevDepthSamp, blCurrDepthSamp,
	        fivertex, fitempTex;

	    // Load the front to back peeling shader
	    fpvertex = new vgl.vertexAttribute('vertexPosition');
	    fpnormal = new vgl.vertexAttribute('vertexNormal');
	    fpcolor = new vgl.vertexAttribute('vertexColor');
	    fpmv = new vgl.modelViewUniform('modelViewMatrix');
	    fpnr = new vgl.modelViewUniform('normalMatrix');
	    fpproj = new vgl.projectionUniform('projectionMatrix');
	    fpwidth = new vgl.floatUniform('width');
	    fpheight = new vgl.floatUniform('height');
	    fpopacity = new vgl.floatUniform('opacity', 1.0);
	    fpdepthTex = new vgl.uniform(vgl.GL.INT, 'depthTexture');
	    fpdepthTex.set(0);

	    frontPeelShader = new vgl.shaderProgram();
	    frontPeelShader.loadShader(vgl.GL.VERTEX_SHADER, 'front_peel.vert');
	    frontPeelShader.loadShader(vgl.GL.FRAGMENT_SHADER, 'front_peel.frag');

	    frontPeelShader.addUniform(fpmv);
	    frontPeelShader.addUniform(fpnr);
	    frontPeelShader.addUniform(fpproj);
	    frontPeelShader.addUniform(fpdepthTex);
	    frontPeelShader.addUniform(fpwidth);
	    frontPeelShader.addUniform(fpheight);
	    frontPeelShader.addUniform(fpopacity);
	    frontPeelShader.addVertexAttribute(fpvertex, vgl.vertexAttributeKeys.Position);
	    frontPeelShader.addVertexAttribute(fpnormal, vgl.vertexAttributeKeys.Normal);
	    frontPeelShader.addVertexAttribute(fpcolor, vgl.vertexAttributeKeys.Color);

	    // Compile and link the shader
	    frontPeelShader.compileAndLink(renderState);

	    fpMaterial.addAttribute(frontPeelShader);

	    //     //add attributes and uniforms
	    //     frontPeelShader.AddAttribute('vVertex');
	    //     frontPeelShader.AddUniform('MVP');
	    //     frontPeelShader.AddUniform('vColor');
	    //     frontPeelShader.AddUniform('depthTexture');
	    //     //pass constant uniforms at initialization
	    //     glUniform1i(frontPeelShader('depthTexture'), 0);
	    // frontPeelShader.UnUse();

	    // Load the blending shader
	    blendShader = new vgl.shaderProgram();
	    blendShader.loadShader(vgl.GL.VERTEX_SHADER, 'blend.vert');
	    blendShader.loadShader(vgl.GL.FRAGMENT_SHADER, 'blend.frag');
	    blColorSamp = new vgl.uniform(vgl.GL.INT, 'currColorTexture');
	    blPrevDepthSamp = new vgl.uniform(vgl.GL.INT, 'prevDepthTexture');
	    blCurrDepthSamp = new vgl.uniform(vgl.GL.INT, 'currDepthTexture');

	    blwidth = new vgl.floatUniform('width');
	    blheight = new vgl.floatUniform('height');
	    blColorSamp.set(0);
	    blPrevDepthSamp.set(1);
	    blCurrDepthSamp.set(2);

	    blvertex = new vgl.vertexAttribute('vertexPosition');

	    blendShader.addUniform(blColorSamp);
	    blendShader.addUniform(blPrevDepthSamp);
	    blendShader.addUniform(blPrevDepthSamp);
	    blendShader.addUniform(blwidth);
	    blendShader.addUniform(blheight);
	    blendShader.addVertexAttribute(blvertex,
	      vgl.vertexAttributeKeys.Position);

	    // Compile and link the shader
	    blendShader.compileAndLink(renderState);
	    blMaterial.addAttribute(blendShader);

	    //     //add attributes and uniforms
	    //     blendShader.AddAttribute('vVertex');
	    //     blendShader.AddUniform('currColorTexture');
	    //     //pass constant uniforms at initialization
	    //     glUniform1i(blendShader('currColorTexture'), 0);
	    // blendShader.UnUse();

	    //Load the final shader
	    finalShader = new vgl.shaderProgram();
	    finalShader.loadShader(vgl.GL.VERTEX_SHADER, 'blend.vert');
	    finalShader.loadShader(vgl.GL.FRAGMENT_SHADER, 'final.frag');

	    //fimv = new vgl.modelViewUniform('modelViewMatrix');
	    //fiproj = new vgl.projectionUniform('projectionMatrix');
	    fitempTex = new vgl.uniform(vgl.GL.INT, 'colorTexture');
	    fiwidth = new vgl.floatUniform('width');
	    fiheight = new vgl.floatUniform('height');
	    fibackgroundColor = new vgl.uniform(vgl.GL.FLOAT_VEC3, 'backgroundColor');
	    fitempTex.set(0);
	    fivertex = new vgl.vertexAttribute('vertexPosition');

	    //finalShader.addUniform(fimv);
	    //finalShader.addUniform(fiproj);
	    finalShader.addUniform(fitempTex);
	    finalShader.addUniform(fiwidth);
	    finalShader.addUniform(fiheight);
	    finalShader.addUniform(fibackgroundColor);
	    finalShader.addVertexAttribute(fivertex, vgl.vertexAttributeKeys.Position);
	    finalShader.compileAndLink(renderState);
	    fiMaterial.addAttribute(finalShader);
	  }

	  function initFBO(renderState, WIDTH, HEIGHT) {
	    var i, textureFloatExt, textureFloatLinearExt, depthTextureExt, filtering;

	    // Or browser-appropriate prefix
	    depthTextureExt = renderState.m_context.getExtension('WEBKIT_WEBGL_depth_texture');
	    if (!depthTextureExt) {
	      depthTextureExt = renderState.m_context.getExtension('WEBGL_depth_texture');

	      if (!depthTextureExt) {
	        console.log('Depth textures are not supported');
	      }
	    }

	    var floatTextureExt = renderState.m_context.getExtension('OES_texture_float');
	    if (!floatTextureExt) {
	      console.log('float textures are not supported');
	    }

	    textureFloatExt = renderState.m_context.getExtension('OES_texture_float');
	    if (!textureFloatExt) {
	      console.log('Extension Texture Float is not working');
	      window.alert(':( Sorry, Your browser doesn\'t support texture float extension.');
	      return;
	    }
	    textureFloatLinearExt = renderState.m_context.getExtension(
	        'OES_texture_float_linear');
	    depthTextureExt = renderState.m_context.getExtension('WEBGL_depth_texture');

	    if (!depthTextureExt) {
	      console.log('Extension Depth texture is not working');
	      window.alert(':( Sorry, Your browser doesn\'t support depth texture extension.');
	      return;
	    }

	    filtering = textureFloatLinearExt ? vgl.GL.LINEAR : vgl.GL.NEAREST;

	    //FBO initialization function
	    // Generate 2 FBO
	    fbo.push(renderState.m_context.createFramebuffer());
	    fbo.push(renderState.m_context.createFramebuffer());

	    // Create two textures
	    texID.push(renderState.m_context.createTexture());
	    texID.push(renderState.m_context.createTexture());

	    //The FBO has two depth attachments
	    depthTexID.push(renderState.m_context.createTexture());
	    depthTexID.push(renderState.m_context.createTexture());

	    // For each attachment
	    for (i = 0; i < 2; i += 1) {
	      // First initialize the depth texture
	      renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, depthTexID[i]);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MAG_FILTER, vgl.GL.NEAREST);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MIN_FILTER, vgl.GL.NEAREST);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
	      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0,
	        vgl.GL.DEPTH_COMPONENT, WIDTH, HEIGHT, 0, vgl.GL.DEPTH_COMPONENT,
	        vgl.GL.UNSIGNED_SHORT, null);

	      // Second initialize the color attachment
	      renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, texID[i]);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MAG_FILTER, filtering);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MIN_FILTER, filtering);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
	      renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
	      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, vgl.GL.RGBA,
	        WIDTH, HEIGHT, 0, vgl.GL.RGBA, vgl.GL.FLOAT, null);

	      // Bind FBO and attach the depth and color attachments
	      renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, fbo[i]);
	      renderState.m_context.framebufferTexture2D(vgl.GL.FRAMEBUFFER,
	        vgl.GL.DEPTH_ATTACHMENT, vgl.GL.TEXTURE_2D, depthTexID[i], 0);
	      renderState.m_context.framebufferTexture2D(vgl.GL.FRAMEBUFFER,
	        vgl.GL.COLOR_ATTACHMENT0, vgl.GL.TEXTURE_2D, texID[i], 0);
	    }

	    // Now setup the color attachment for color blend FBO
	    colorBlenderTexID = renderState.m_context.createTexture();
	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, colorBlenderTexID);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MIN_FILTER, vgl.GL.NEAREST);
	    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D,
	        vgl.GL.TEXTURE_MAG_FILTER, vgl.GL.NEAREST);
	    renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, vgl.GL.RGBA,
	        WIDTH, HEIGHT, 0, vgl.GL.RGBA, vgl.GL.FLOAT, null);

	    // Generate the color blend FBO ID
	    colorBlenderFBOID = renderState.m_context.createFramebuffer();
	    renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, colorBlenderFBOID);

	    // Set the depth attachment of previous FBO as depth attachment for this FBO
	    renderState.m_context.framebufferTexture2D(vgl.GL.FRAMEBUFFER,
	        vgl.GL.DEPTH_ATTACHMENT, vgl.GL.TEXTURE_2D, depthTexID[0], 0);

	    // Set the color blender texture as the FBO color attachment
	    renderState.m_context.framebufferTexture2D(vgl.GL.FRAMEBUFFER,
	        vgl.GL.COLOR_ATTACHMENT0, vgl.GL.TEXTURE_2D, colorBlenderTexID, 0);

	    // Check the FBO completeness status
	    var status = renderState.m_context.checkFramebufferStatus(
	        vgl.GL.FRAMEBUFFER);
	    if (status === vgl.GL.FRAMEBUFFER_COMPLETE) {
	      console.log('FBO setup successful !!! \n');
	    } else {
	      console.log('Problem with FBO setup');
	    }
	    // Unbind FBO
	    renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, null);
	  }

	  function setup(renderState) {
	    if (setupTime.getMTime() < m_this.getMTime()) {
	      initScreenQuad(renderState, m_this.width(), m_this.height());
	      initShaders(renderState, m_this.width(), m_this.height());
	      initFBO(renderState, m_this.width(), m_this.height());
	      setupTime.modified();
	    }
	  }

	  function drawScene(renderState, sortedActors, material) {

	    var i, actor, mvMatrixInv = mat4.create();

	    // // Enable alpha blending with over compositing
	    // gl.enable(vgl.GL.BLEND);
	    // gl.blendFunc(vgl.GL.SRC_ALPHA, vgl.GL.ONE_MINUS_SRC_ALPHA);

	    for (i = 0; i < sortedActors.length; i += 1) {
	      actor = sortedActors[i][2];

	      if (actor.referenceFrame() ===
	          vgl.boundingObject.ReferenceFrame.Relative) {
	        mat4.multiply(renderState.m_modelViewMatrix, m_this.m_camera.viewMatrix(),
	          actor.matrix());
	        renderState.m_projectionMatrix = m_this.m_camera.projectionMatrix();
	      } else {
	        renderState.m_modelViewMatrix = actor.matrix();
	        renderState.m_projectionMatrix = mat4.create();
	        mat4.ortho(renderState.m_projectionMatrix, 0,
	                   m_this.m_width, 0, m_this.m_height, -1, 1);
	      }

	      mat4.invert(mvMatrixInv, renderState.m_modelViewMatrix);
	      mat4.transpose(renderState.m_normalMatrix, mvMatrixInv);
	      renderState.m_mapper = actor.mapper();

	      // TODO Fix this shortcut
	      if (!material) {
	        renderState.m_material = actor.material();
	        renderState.m_material.bind(renderState);
	        renderState.m_mapper.render(renderState);
	        renderState.m_material.undoBind(renderState);
	      } else {

	        var ou = actor.material().shaderProgram().uniform('opacity');
	        if (ou) {
	          fpopacity.set(ou.get()[0]);
	        } else {
	          fpopacity.set(1.0);
	        }
	        renderState.m_material = material;
	        renderState.m_material.bind(renderState);
	        renderState.m_mapper.render(renderState);
	        renderState.m_material.undoBind(renderState);
	      }
	    }
	  }

	  function depthPeelRender(renderState, actors) {
	    var layer;

	    fpwidth.set(m_this.width());
	    fpheight.set(m_this.height());
	    blwidth.set(m_this.width());
	    blheight.set(m_this.height());
	    fiwidth.set(m_this.width());
	    fiheight.set(m_this.height());

	    // Clear color and depth buffer
	    renderState.m_context.clearColor(0.0, 0.0, 0.0, 0.0);
	    /*jshint bitwise: false */
	    renderState.m_context.clear(vgl.GL.OLOR_BUFFER_BIT | vgl.GL.DEPTH_BUFFER_BIT);
	    /*jshint bitwise: true */

	    // Bind the color blending FBO
	    renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, colorBlenderFBOID);

	    // 1. In the first pass, we render normally with depth test enabled to
	    // get the nearest surface
	    renderState.m_context.enable(vgl.GL.DEPTH_TEST);
	    renderState.m_context.disable(vgl.GL.BLEND);

	    var clearColor = m_this.m_camera.clearColor();
	    renderState.m_context.clearColor(clearColor[0], clearColor[1], clearColor[2], 0.0);
	    /*jshint bitwise: false */
	    renderState.m_context.clear(vgl.GL.COLOR_BUFFER_BIT | vgl.GL.DEPTH_BUFFER_BIT);
	    /*jshint bitwise: true */

	    drawScene(renderState, actors);

	    // 2. Depth peeling + blending pass
	    var numLayers = (NUM_PASSES - 1) * 2;

	    // For each pass
	    for (layer = 1; layer < numLayers; layer += 1) {
	      var currId = layer % 2;
	      var prevId = 1 - currId;

	      // Bind the current FBO
	      renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, fbo[currId]);

	      // Disbale blending and enable depth testing
	      renderState.m_context.disable(vgl.GL.BLEND);
	      renderState.m_context.enable(vgl.GL.DEPTH_TEST);

	      // Bind the depth texture from the previous step
	      renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, depthTexID[prevId]);

	      // Set clear color to black
	      renderState.m_context.clearColor(0.0, 0.0, 0.0, 0.0);

	      // Clear the color and depth buffers
	      /*jshint bitwise: false */
	      renderState.m_context.clear(vgl.GL.COLOR_BUFFER_BIT | vgl.GL.DEPTH_BUFFER_BIT);
	      /*jshint bitwise: true */

	      // Render scene with the front to back peeling shader
	      drawScene(renderState, actors, fpMaterial);

	      // Bind the color blender FBO
	      renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, colorBlenderFBOID);

	      // Enable blending but disable depth testing
	      renderState.m_context.disable(vgl.GL.DEPTH_TEST);
	      renderState.m_context.enable(vgl.GL.BLEND);

	      // Change the blending equation to add
	      renderState.m_context.blendEquation(vgl.GL.FUNC_ADD);

	      // Use separate blending function
	      renderState.m_context.blendFuncSeparate(vgl.GL.DST_ALPHA, vgl.GL.ONE,
	          vgl.GL.ZERO, vgl.GL.ONE_MINUS_SRC_ALPHA);

	      // Bind the result from the previous iteration as texture
	      renderState.m_context.activeTexture(vgl.GL.TEXTURE0);
	      renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, texID[currId]);

	      renderState.m_context.activeTexture(vgl.GL.TEXTURE1);
	      renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, depthTexID[prevId]);

	      renderState.m_context.activeTexture(vgl.GL.TEXTURE2);
	      renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, depthTexID[currId]);

	      drawFullScreenQuad(renderState, blMaterial);

	      renderState.m_context.activeTexture(vgl.GL.TEXTURE0);

	      // Disable blending
	      renderState.m_context.disable(vgl.GL.BLEND);
	    }

	    // 3. Final render pass
	    //remove the FBO
	    renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, null);

	    // Disable depth testing and blending
	    renderState.m_context.disable(vgl.GL.DEPTH_TEST);
	    renderState.m_context.disable(vgl.GL.BLEND);

	    // Bind the color blender texture
	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, colorBlenderTexID);

	    fibackgroundColor.set(m_this.m_camera.clearColor());

	    // Draw full screen quad
	    drawFullScreenQuad(renderState, fiMaterial);

	    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the scene
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.render = function () {
	    var i, renSt, children, actor = null, sortedActors = [];

	    renSt = new vgl.renderState();
	    renSt.m_renderer = m_this;
	    renSt.m_context = m_this.renderWindow().context();
	    renSt.m_contextChanged = m_this.m_contextChanged;

	    // Set the viewport for this renderer
	    renSt.m_context.viewport(m_this.m_x, m_this.m_y, m_this.m_width, m_this.m_height);

	    // Check if we have initialized
	    setup(renSt);

	    children = m_this.m_sceneRoot.children();

	    if (children.length > 0 && m_this.m_resetScene) {
	      this.resetCamera();
	      m_this.m_resetScene = false;
	    }

	    for (i = 0; i < children.length; i += 1) {
	      actor = children[i];
	      actor.computeBounds();
	      if (actor.visible()) {
	        sortedActors.push([actor.material().binNumber(),
	          actor.material().shaderProgram().uniform('opacity').get()[0],
	          actor]);
	      }
	    }

	    // Now perform sorting
	    sortedActors.sort(function (a, b) { return a[0] - b[0]; });
	    sortedActors.sort(function (a, b) { return b[1] - a[1]; });

	    depthPeelRender(renSt, sortedActors);
	  };
	};

	inherit(vgl.depthPeelRenderer, vgl.renderer);

	return vgl;

	}));



/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  create: __webpack_require__(84)
	  , clone: __webpack_require__(85)
	  , copy: __webpack_require__(86)
	  , identity: __webpack_require__(87)
	  , transpose: __webpack_require__(88)
	  , invert: __webpack_require__(89)
	  , adjoint: __webpack_require__(90)
	  , determinant: __webpack_require__(91)
	  , multiply: __webpack_require__(92)
	  , translate: __webpack_require__(93)
	  , scale: __webpack_require__(94)
	  , rotate: __webpack_require__(95)
	  , rotateX: __webpack_require__(96)
	  , rotateY: __webpack_require__(97)
	  , rotateZ: __webpack_require__(98)
	  , fromRotationTranslation: __webpack_require__(99)
	  , fromQuat: __webpack_require__(100)
	  , frustum: __webpack_require__(101)
	  , perspective: __webpack_require__(102)
	  , perspectiveFromFieldOfView: __webpack_require__(103)
	  , ortho: __webpack_require__(104)
	  , lookAt: __webpack_require__(105)
	  , str: __webpack_require__(106)
	}

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = create;

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */
	function create() {
	    var out = new Float32Array(16);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = clone;

	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {mat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */
	function clone(a) {
	    var out = new Float32Array(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = copy;

	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function copy(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports = identity;

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	function identity(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = transpose;

	/**
	 * Transpose the values of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function transpose(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];

	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }
	    
	    return out;
	};

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = invert;

	/**
	 * Inverts a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function invert(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	};

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = adjoint;

	/**
	 * Calculates the adjugate of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function adjoint(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
	    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
	    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
	    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
	    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
	    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
	    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
	    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
	    return out;
	};

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = determinant;

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant(a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;

	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = multiply;

	/**
	 * Multiplies two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	function multiply(out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	};

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = translate;

	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	function translate(out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	};

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = scale;

	/**
	 * Scales the mat4 by the dimensions in the given vec3
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	function scale(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];

	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports = rotate;

	/**
	 * Rotates a mat4 by the given angle
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	function rotate(out, a, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;

	    if (Math.abs(len) < 0.000001) { return null; }
	    
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	};

/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = rotateX;

	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateX(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	};

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = rotateY;

	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateY(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = rotateZ;

	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateZ(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	};

/***/ },
/* 99 */
/***/ function(module, exports) {

	module.exports = fromRotationTranslation;

	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	function fromRotationTranslation(out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    
	    return out;
	};

/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = fromQuat;

	/**
	 * Creates a matrix from a quaternion rotation.
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @returns {mat4} out
	 */
	function fromQuat(out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;

	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;

	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;

	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;

	    return out;
	};

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = frustum;

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function frustum(out, left, right, bottom, top, near, far) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	};

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = perspective;

	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function perspective(out, fovy, aspect, near, far) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	};

/***/ },
/* 103 */
/***/ function(module, exports) {

	module.exports = perspectiveFromFieldOfView;

	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function perspectiveFromFieldOfView(out, fov, near, far) {
	    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
	        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
	        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
	        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
	        xScale = 2.0 / (leftTan + rightTan),
	        yScale = 2.0 / (upTan + downTan);

	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	}



/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = ortho;

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function ortho(out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(87);

	module.exports = lookAt;

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	function lookAt(out, eye, center, up) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];

	    if (Math.abs(eyex - centerx) < 0.000001 &&
	        Math.abs(eyey - centery) < 0.000001 &&
	        Math.abs(eyez - centerz) < 0.000001) {
	        return identity(out);
	    }

	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;

	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;

	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }

	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;

	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }

	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;

	    return out;
	};

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = str;

	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {mat4} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	function str(a) {
	    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
	                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
	                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
	                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  create: __webpack_require__(108),
	  clone: __webpack_require__(109),
	  fromValues: __webpack_require__(110),
	  copy: __webpack_require__(111),
	  set: __webpack_require__(112),
	  add: __webpack_require__(113),
	  subtract: __webpack_require__(114),
	  multiply: __webpack_require__(115),
	  divide: __webpack_require__(116),
	  min: __webpack_require__(117),
	  max: __webpack_require__(118),
	  scale: __webpack_require__(119),
	  scaleAndAdd: __webpack_require__(120),
	  distance: __webpack_require__(121),
	  squaredDistance: __webpack_require__(122),
	  length: __webpack_require__(123),
	  squaredLength: __webpack_require__(124),
	  negate: __webpack_require__(125),
	  inverse: __webpack_require__(126),
	  normalize: __webpack_require__(127),
	  dot: __webpack_require__(128),
	  lerp: __webpack_require__(129),
	  random: __webpack_require__(130),
	  transformMat4: __webpack_require__(131),
	  transformQuat: __webpack_require__(132)
	}


/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = create

	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {vec4} a new 4D vector
	 */
	function create () {
	  var out = new Float32Array(4)
	  out[0] = 0
	  out[1] = 0
	  out[2] = 0
	  out[3] = 0
	  return out
	}


/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = clone

	/**
	 * Creates a new vec4 initialized with values from an existing vector
	 *
	 * @param {vec4} a vector to clone
	 * @returns {vec4} a new 4D vector
	 */
	function clone (a) {
	  var out = new Float32Array(4)
	  out[0] = a[0]
	  out[1] = a[1]
	  out[2] = a[2]
	  out[3] = a[3]
	  return out
	}


/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = fromValues

	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} a new 4D vector
	 */
	function fromValues (x, y, z, w) {
	  var out = new Float32Array(4)
	  out[0] = x
	  out[1] = y
	  out[2] = z
	  out[3] = w
	  return out
	}


/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = copy

	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the source vector
	 * @returns {vec4} out
	 */
	function copy (out, a) {
	  out[0] = a[0]
	  out[1] = a[1]
	  out[2] = a[2]
	  out[3] = a[3]
	  return out
	}


/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = set

	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} out
	 */
	function set (out, x, y, z, w) {
	  out[0] = x
	  out[1] = y
	  out[2] = z
	  out[3] = w
	  return out
	}


/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = add

	/**
	 * Adds two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function add (out, a, b) {
	  out[0] = a[0] + b[0]
	  out[1] = a[1] + b[1]
	  out[2] = a[2] + b[2]
	  out[3] = a[3] + b[3]
	  return out
	}


/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = subtract

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function subtract (out, a, b) {
	  out[0] = a[0] - b[0]
	  out[1] = a[1] - b[1]
	  out[2] = a[2] - b[2]
	  out[3] = a[3] - b[3]
	  return out
	}


/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = multiply

	/**
	 * Multiplies two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function multiply (out, a, b) {
	  out[0] = a[0] * b[0]
	  out[1] = a[1] * b[1]
	  out[2] = a[2] * b[2]
	  out[3] = a[3] * b[3]
	  return out
	}


/***/ },
/* 116 */
/***/ function(module, exports) {

	module.exports = divide

	/**
	 * Divides two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function divide (out, a, b) {
	  out[0] = a[0] / b[0]
	  out[1] = a[1] / b[1]
	  out[2] = a[2] / b[2]
	  out[3] = a[3] / b[3]
	  return out
	}


/***/ },
/* 117 */
/***/ function(module, exports) {

	module.exports = min

	/**
	 * Returns the minimum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function min (out, a, b) {
	  out[0] = Math.min(a[0], b[0])
	  out[1] = Math.min(a[1], b[1])
	  out[2] = Math.min(a[2], b[2])
	  out[3] = Math.min(a[3], b[3])
	  return out
	}


/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = max

	/**
	 * Returns the maximum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function max (out, a, b) {
	  out[0] = Math.max(a[0], b[0])
	  out[1] = Math.max(a[1], b[1])
	  out[2] = Math.max(a[2], b[2])
	  out[3] = Math.max(a[3], b[3])
	  return out
	}


/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = scale

	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec4} out
	 */
	function scale (out, a, b) {
	  out[0] = a[0] * b
	  out[1] = a[1] * b
	  out[2] = a[2] * b
	  out[3] = a[3] * b
	  return out
	}


/***/ },
/* 120 */
/***/ function(module, exports) {

	module.exports = scaleAndAdd

	/**
	 * Adds two vec4's after scaling the second operand by a scalar value
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec4} out
	 */
	function scaleAndAdd (out, a, b, scale) {
	  out[0] = a[0] + (b[0] * scale)
	  out[1] = a[1] + (b[1] * scale)
	  out[2] = a[2] + (b[2] * scale)
	  out[3] = a[3] + (b[3] * scale)
	  return out
	}


/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = distance

	/**
	 * Calculates the euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} distance between a and b
	 */
	function distance (a, b) {
	  var x = b[0] - a[0],
	    y = b[1] - a[1],
	    z = b[2] - a[2],
	    w = b[3] - a[3]
	  return Math.sqrt(x * x + y * y + z * z + w * w)
	}


/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = squaredDistance

	/**
	 * Calculates the squared euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	function squaredDistance (a, b) {
	  var x = b[0] - a[0],
	    y = b[1] - a[1],
	    z = b[2] - a[2],
	    w = b[3] - a[3]
	  return x * x + y * y + z * z + w * w
	}


/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = length

	/**
	 * Calculates the length of a vec4
	 *
	 * @param {vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length (a) {
	  var x = a[0],
	    y = a[1],
	    z = a[2],
	    w = a[3]
	  return Math.sqrt(x * x + y * y + z * z + w * w)
	}


/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = squaredLength

	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength (a) {
	  var x = a[0],
	    y = a[1],
	    z = a[2],
	    w = a[3]
	  return x * x + y * y + z * z + w * w
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	module.exports = negate

	/**
	 * Negates the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to negate
	 * @returns {vec4} out
	 */
	function negate (out, a) {
	  out[0] = -a[0]
	  out[1] = -a[1]
	  out[2] = -a[2]
	  out[3] = -a[3]
	  return out
	}


/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = inverse

	/**
	 * Returns the inverse of the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to invert
	 * @returns {vec4} out
	 */
	function inverse (out, a) {
	  out[0] = 1.0 / a[0]
	  out[1] = 1.0 / a[1]
	  out[2] = 1.0 / a[2]
	  out[3] = 1.0 / a[3]
	  return out
	}


/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = normalize

	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to normalize
	 * @returns {vec4} out
	 */
	function normalize (out, a) {
	  var x = a[0],
	    y = a[1],
	    z = a[2],
	    w = a[3]
	  var len = x * x + y * y + z * z + w * w
	  if (len > 0) {
	    len = 1 / Math.sqrt(len)
	    out[0] = x * len
	    out[1] = y * len
	    out[2] = z * len
	    out[3] = w * len
	  }
	  return out
	}


/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = dot

	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot (a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
	}


/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = lerp

	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec4} out
	 */
	function lerp (out, a, b, t) {
	  var ax = a[0],
	    ay = a[1],
	    az = a[2],
	    aw = a[3]
	  out[0] = ax + t * (b[0] - ax)
	  out[1] = ay + t * (b[1] - ay)
	  out[2] = az + t * (b[2] - az)
	  out[3] = aw + t * (b[3] - aw)
	  return out
	}


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var vecNormalize = __webpack_require__(127)
	var vecScale = __webpack_require__(119)

	module.exports = random

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec4} out
	 */
	function random (out, scale) {
	  scale = scale || 1.0

	  // TODO: This is a pretty awful way of doing this. Find something better.
	  out[0] = Math.random()
	  out[1] = Math.random()
	  out[2] = Math.random()
	  out[3] = Math.random()
	  vecNormalize(out, out)
	  vecScale(out, out, scale)
	  return out
	}


/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = transformMat4

	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec4} out
	 */
	function transformMat4 (out, a, m) {
	  var x = a[0], y = a[1], z = a[2], w = a[3]
	  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w
	  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w
	  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w
	  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w
	  return out
	}


/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = transformQuat

	/**
	 * Transforms the vec4 with a quat
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec4} out
	 */
	function transformQuat (out, a, q) {
	  var x = a[0], y = a[1], z = a[2],
	    qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	    // calculate quat * vec
	    ix = qw * x + qy * z - qz * y,
	    iy = qw * y + qz * x - qx * z,
	    iz = qw * z + qx * y - qy * x,
	    iw = -qx * x - qy * y - qz * z

	  // calculate result * inverse quat
	  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
	  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
	  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
	  out[3] = a[3]
	  return out
	}


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  create: __webpack_require__(134)
	  , clone: __webpack_require__(135)
	  , angle: __webpack_require__(136)
	  , fromValues: __webpack_require__(137)
	  , copy: __webpack_require__(140)
	  , set: __webpack_require__(141)
	  , add: __webpack_require__(142)
	  , subtract: __webpack_require__(143)
	  , multiply: __webpack_require__(144)
	  , divide: __webpack_require__(145)
	  , min: __webpack_require__(146)
	  , max: __webpack_require__(147)
	  , scale: __webpack_require__(148)
	  , scaleAndAdd: __webpack_require__(149)
	  , distance: __webpack_require__(150)
	  , squaredDistance: __webpack_require__(151)
	  , length: __webpack_require__(152)
	  , squaredLength: __webpack_require__(153)
	  , negate: __webpack_require__(154)
	  , inverse: __webpack_require__(155)
	  , normalize: __webpack_require__(138)
	  , dot: __webpack_require__(139)
	  , cross: __webpack_require__(156)
	  , lerp: __webpack_require__(157)
	  , random: __webpack_require__(158)
	  , transformMat4: __webpack_require__(159)
	  , transformMat3: __webpack_require__(160)
	  , transformQuat: __webpack_require__(161)
	  , rotateX: __webpack_require__(162)
	  , rotateY: __webpack_require__(163)
	  , rotateZ: __webpack_require__(164)
	  , forEach: __webpack_require__(165)
	}

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = create;

	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {vec3} a new 3D vector
	 */
	function create() {
	    var out = new Float32Array(3)
	    out[0] = 0
	    out[1] = 0
	    out[2] = 0
	    return out
	}

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = clone;

	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {vec3} a vector to clone
	 * @returns {vec3} a new 3D vector
	 */
	function clone(a) {
	    var out = new Float32Array(3)
	    out[0] = a[0]
	    out[1] = a[1]
	    out[2] = a[2]
	    return out
	}

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = angle

	var fromValues = __webpack_require__(137)
	var normalize = __webpack_require__(138)
	var dot = __webpack_require__(139)

	/**
	 * Get the angle between two 3D vectors
	 * @param {vec3} a The first operand
	 * @param {vec3} b The second operand
	 * @returns {Number} The angle in radians
	 */
	function angle(a, b) {
	    var tempA = fromValues(a[0], a[1], a[2])
	    var tempB = fromValues(b[0], b[1], b[2])
	 
	    normalize(tempA, tempA)
	    normalize(tempB, tempB)
	 
	    var cosine = dot(tempA, tempB)

	    if(cosine > 1.0){
	        return 0
	    } else {
	        return Math.acos(cosine)
	    }     
	}


/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = fromValues;

	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */
	function fromValues(x, y, z) {
	    var out = new Float32Array(3)
	    out[0] = x
	    out[1] = y
	    out[2] = z
	    return out
	}

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = normalize;

	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to normalize
	 * @returns {vec3} out
	 */
	function normalize(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2]
	    var len = x*x + y*y + z*z
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len)
	        out[0] = a[0] * len
	        out[1] = a[1] * len
	        out[2] = a[2] * len
	    }
	    return out
	}

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = dot;

	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
	}

/***/ },
/* 140 */
/***/ function(module, exports) {

	module.exports = copy;

	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the source vector
	 * @returns {vec3} out
	 */
	function copy(out, a) {
	    out[0] = a[0]
	    out[1] = a[1]
	    out[2] = a[2]
	    return out
	}

/***/ },
/* 141 */
/***/ function(module, exports) {

	module.exports = set;

	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} out
	 */
	function set(out, x, y, z) {
	    out[0] = x
	    out[1] = y
	    out[2] = z
	    return out
	}

/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = add;

	/**
	 * Adds two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function add(out, a, b) {
	    out[0] = a[0] + b[0]
	    out[1] = a[1] + b[1]
	    out[2] = a[2] + b[2]
	    return out
	}

/***/ },
/* 143 */
/***/ function(module, exports) {

	module.exports = subtract;

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function subtract(out, a, b) {
	    out[0] = a[0] - b[0]
	    out[1] = a[1] - b[1]
	    out[2] = a[2] - b[2]
	    return out
	}

/***/ },
/* 144 */
/***/ function(module, exports) {

	module.exports = multiply;

	/**
	 * Multiplies two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function multiply(out, a, b) {
	    out[0] = a[0] * b[0]
	    out[1] = a[1] * b[1]
	    out[2] = a[2] * b[2]
	    return out
	}

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = divide;

	/**
	 * Divides two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function divide(out, a, b) {
	    out[0] = a[0] / b[0]
	    out[1] = a[1] / b[1]
	    out[2] = a[2] / b[2]
	    return out
	}

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports = min;

	/**
	 * Returns the minimum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function min(out, a, b) {
	    out[0] = Math.min(a[0], b[0])
	    out[1] = Math.min(a[1], b[1])
	    out[2] = Math.min(a[2], b[2])
	    return out
	}

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = max;

	/**
	 * Returns the maximum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function max(out, a, b) {
	    out[0] = Math.max(a[0], b[0])
	    out[1] = Math.max(a[1], b[1])
	    out[2] = Math.max(a[2], b[2])
	    return out
	}

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = scale;

	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec3} out
	 */
	function scale(out, a, b) {
	    out[0] = a[0] * b
	    out[1] = a[1] * b
	    out[2] = a[2] * b
	    return out
	}

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = scaleAndAdd;

	/**
	 * Adds two vec3's after scaling the second operand by a scalar value
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec3} out
	 */
	function scaleAndAdd(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale)
	    out[1] = a[1] + (b[1] * scale)
	    out[2] = a[2] + (b[2] * scale)
	    return out
	}

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = distance;

	/**
	 * Calculates the euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} distance between a and b
	 */
	function distance(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2]
	    return Math.sqrt(x*x + y*y + z*z)
	}

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = squaredDistance;

	/**
	 * Calculates the squared euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	function squaredDistance(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2]
	    return x*x + y*y + z*z
	}

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = length;

	/**
	 * Calculates the length of a vec3
	 *
	 * @param {vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length(a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2]
	    return Math.sqrt(x*x + y*y + z*z)
	}

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = squaredLength;

	/**
	 * Calculates the squared length of a vec3
	 *
	 * @param {vec3} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength(a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2]
	    return x*x + y*y + z*z
	}

/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = negate;

	/**
	 * Negates the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to negate
	 * @returns {vec3} out
	 */
	function negate(out, a) {
	    out[0] = -a[0]
	    out[1] = -a[1]
	    out[2] = -a[2]
	    return out
	}

/***/ },
/* 155 */
/***/ function(module, exports) {

	module.exports = inverse;

	/**
	 * Returns the inverse of the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to invert
	 * @returns {vec3} out
	 */
	function inverse(out, a) {
	  out[0] = 1.0 / a[0]
	  out[1] = 1.0 / a[1]
	  out[2] = 1.0 / a[2]
	  return out
	}

/***/ },
/* 156 */
/***/ function(module, exports) {

	module.exports = cross;

	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function cross(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2],
	        bx = b[0], by = b[1], bz = b[2]

	    out[0] = ay * bz - az * by
	    out[1] = az * bx - ax * bz
	    out[2] = ax * by - ay * bx
	    return out
	}

/***/ },
/* 157 */
/***/ function(module, exports) {

	module.exports = lerp;

	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	function lerp(out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2]
	    out[0] = ax + t * (b[0] - ax)
	    out[1] = ay + t * (b[1] - ay)
	    out[2] = az + t * (b[2] - az)
	    return out
	}

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = random;

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec3} out
	 */
	function random(out, scale) {
	    scale = scale || 1.0

	    var r = Math.random() * 2.0 * Math.PI
	    var z = (Math.random() * 2.0) - 1.0
	    var zScale = Math.sqrt(1.0-z*z) * scale

	    out[0] = Math.cos(r) * zScale
	    out[1] = Math.sin(r) * zScale
	    out[2] = z * scale
	    return out
	}

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = transformMat4;

	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec3} out
	 */
	function transformMat4(out, a, m) {
	    var x = a[0], y = a[1], z = a[2],
	        w = m[3] * x + m[7] * y + m[11] * z + m[15]
	    w = w || 1.0
	    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
	    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
	    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
	    return out
	}

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = transformMat3;

	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m the 3x3 matrix to transform with
	 * @returns {vec3} out
	 */
	function transformMat3(out, a, m) {
	    var x = a[0], y = a[1], z = a[2]
	    out[0] = x * m[0] + y * m[3] + z * m[6]
	    out[1] = x * m[1] + y * m[4] + z * m[7]
	    out[2] = x * m[2] + y * m[5] + z * m[8]
	    return out
	}

/***/ },
/* 161 */
/***/ function(module, exports) {

	module.exports = transformQuat;

	/**
	 * Transforms the vec3 with a quat
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec3} out
	 */
	function transformQuat(out, a, q) {
	    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
	    return out
	}

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports = rotateX;

	/**
	 * Rotate a 3D vector around the x-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateX(out, a, b, c){
	    var p = [], r=[]
	    //Translate point to the origin
	    p[0] = a[0] - b[0]
	    p[1] = a[1] - b[1]
	    p[2] = a[2] - b[2]

	    //perform rotation
	    r[0] = p[0]
	    r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c)
	    r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c)

	    //translate to correct position
	    out[0] = r[0] + b[0]
	    out[1] = r[1] + b[1]
	    out[2] = r[2] + b[2]

	    return out
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports = rotateY;

	/**
	 * Rotate a 3D vector around the y-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateY(out, a, b, c){
	    var p = [], r=[]
	    //Translate point to the origin
	    p[0] = a[0] - b[0]
	    p[1] = a[1] - b[1]
	    p[2] = a[2] - b[2]
	  
	    //perform rotation
	    r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c)
	    r[1] = p[1]
	    r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c)
	  
	    //translate to correct position
	    out[0] = r[0] + b[0]
	    out[1] = r[1] + b[1]
	    out[2] = r[2] + b[2]
	  
	    return out
	}

/***/ },
/* 164 */
/***/ function(module, exports) {

	module.exports = rotateZ;

	/**
	 * Rotate a 3D vector around the z-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateZ(out, a, b, c){
	    var p = [], r=[]
	    //Translate point to the origin
	    p[0] = a[0] - b[0]
	    p[1] = a[1] - b[1]
	    p[2] = a[2] - b[2]
	  
	    //perform rotation
	    r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c)
	    r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c)
	    r[2] = p[2]
	  
	    //translate to correct position
	    out[0] = r[0] + b[0]
	    out[1] = r[1] + b[1]
	    out[2] = r[2] + b[2]
	  
	    return out
	}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = forEach;

	var vec = __webpack_require__(134)()

	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	function forEach(a, stride, offset, count, fn, arg) {
	        var i, l
	        if(!stride) {
	            stride = 3
	        }

	        if(!offset) {
	            offset = 0
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length)
	        } else {
	            l = a.length
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i] 
	            vec[1] = a[i+1] 
	            vec[2] = a[i+2]
	            fn(vec, vec, arg)
	            a[i] = vec[0] 
	            a[i+1] = vec[1] 
	            a[i+2] = vec[2]
	        }
	        
	        return a
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  create: __webpack_require__(167)
	  , clone: __webpack_require__(168)
	  , fromValues: __webpack_require__(169)
	  , copy: __webpack_require__(170)
	  , set: __webpack_require__(171)
	  , add: __webpack_require__(172)
	  , subtract: __webpack_require__(173)
	  , multiply: __webpack_require__(174)
	  , divide: __webpack_require__(175)
	  , min: __webpack_require__(176)
	  , max: __webpack_require__(177)
	  , scale: __webpack_require__(178)
	  , scaleAndAdd: __webpack_require__(179)
	  , distance: __webpack_require__(180)
	  , squaredDistance: __webpack_require__(181)
	  , length: __webpack_require__(182)
	  , squaredLength: __webpack_require__(183)
	  , negate: __webpack_require__(184)
	  , normalize: __webpack_require__(185)
	  , dot: __webpack_require__(186)
	  , cross: __webpack_require__(187)
	  , lerp: __webpack_require__(188)
	  , random: __webpack_require__(189)
	  , transformMat2: __webpack_require__(190)
	  , transformMat2d: __webpack_require__(191)
	  , transformMat3: __webpack_require__(192)
	  , transformMat4: __webpack_require__(193)
	  , forEach: __webpack_require__(194)
	}

/***/ },
/* 167 */
/***/ function(module, exports) {

	module.exports = create

	/**
	 * Creates a new, empty vec2
	 *
	 * @returns {vec2} a new 2D vector
	 */
	function create() {
	    var out = new Float32Array(2)
	    out[0] = 0
	    out[1] = 0
	    return out
	}

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = clone

	/**
	 * Creates a new vec2 initialized with values from an existing vector
	 *
	 * @param {vec2} a vector to clone
	 * @returns {vec2} a new 2D vector
	 */
	function clone(a) {
	    var out = new Float32Array(2)
	    out[0] = a[0]
	    out[1] = a[1]
	    return out
	}

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = fromValues

	/**
	 * Creates a new vec2 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} a new 2D vector
	 */
	function fromValues(x, y) {
	    var out = new Float32Array(2)
	    out[0] = x
	    out[1] = y
	    return out
	}

/***/ },
/* 170 */
/***/ function(module, exports) {

	module.exports = copy

	/**
	 * Copy the values from one vec2 to another
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the source vector
	 * @returns {vec2} out
	 */
	function copy(out, a) {
	    out[0] = a[0]
	    out[1] = a[1]
	    return out
	}

/***/ },
/* 171 */
/***/ function(module, exports) {

	module.exports = set

	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	function set(out, x, y) {
	    out[0] = x
	    out[1] = y
	    return out
	}

/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports = add

	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function add(out, a, b) {
	    out[0] = a[0] + b[0]
	    out[1] = a[1] + b[1]
	    return out
	}

/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports = subtract

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function subtract(out, a, b) {
	    out[0] = a[0] - b[0]
	    out[1] = a[1] - b[1]
	    return out
	}

/***/ },
/* 174 */
/***/ function(module, exports) {

	module.exports = multiply

	/**
	 * Multiplies two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function multiply(out, a, b) {
	    out[0] = a[0] * b[0]
	    out[1] = a[1] * b[1]
	    return out
	}

/***/ },
/* 175 */
/***/ function(module, exports) {

	module.exports = divide

	/**
	 * Divides two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function divide(out, a, b) {
	    out[0] = a[0] / b[0]
	    out[1] = a[1] / b[1]
	    return out
	}

/***/ },
/* 176 */
/***/ function(module, exports) {

	module.exports = min

	/**
	 * Returns the minimum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function min(out, a, b) {
	    out[0] = Math.min(a[0], b[0])
	    out[1] = Math.min(a[1], b[1])
	    return out
	}

/***/ },
/* 177 */
/***/ function(module, exports) {

	module.exports = max

	/**
	 * Returns the maximum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function max(out, a, b) {
	    out[0] = Math.max(a[0], b[0])
	    out[1] = Math.max(a[1], b[1])
	    return out
	}

/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = scale

	/**
	 * Scales a vec2 by a scalar number
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec2} out
	 */
	function scale(out, a, b) {
	    out[0] = a[0] * b
	    out[1] = a[1] * b
	    return out
	}

/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = scaleAndAdd

	/**
	 * Adds two vec2's after scaling the second operand by a scalar value
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec2} out
	 */
	function scaleAndAdd(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale)
	    out[1] = a[1] + (b[1] * scale)
	    return out
	}

/***/ },
/* 180 */
/***/ function(module, exports) {

	module.exports = distance

	/**
	 * Calculates the euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} distance between a and b
	 */
	function distance(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1]
	    return Math.sqrt(x*x + y*y)
	}

/***/ },
/* 181 */
/***/ function(module, exports) {

	module.exports = squaredDistance

	/**
	 * Calculates the squared euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	function squaredDistance(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1]
	    return x*x + y*y
	}

/***/ },
/* 182 */
/***/ function(module, exports) {

	module.exports = length

	/**
	 * Calculates the length of a vec2
	 *
	 * @param {vec2} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length(a) {
	    var x = a[0],
	        y = a[1]
	    return Math.sqrt(x*x + y*y)
	}

/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = squaredLength

	/**
	 * Calculates the squared length of a vec2
	 *
	 * @param {vec2} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength(a) {
	    var x = a[0],
	        y = a[1]
	    return x*x + y*y
	}

/***/ },
/* 184 */
/***/ function(module, exports) {

	module.exports = negate

	/**
	 * Negates the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to negate
	 * @returns {vec2} out
	 */
	function negate(out, a) {
	    out[0] = -a[0]
	    out[1] = -a[1]
	    return out
	}

/***/ },
/* 185 */
/***/ function(module, exports) {

	module.exports = normalize

	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	function normalize(out, a) {
	    var x = a[0],
	        y = a[1]
	    var len = x*x + y*y
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len)
	        out[0] = a[0] * len
	        out[1] = a[1] * len
	    }
	    return out
	}

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports = dot

	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot(a, b) {
	    return a[0] * b[0] + a[1] * b[1]
	}

/***/ },
/* 187 */
/***/ function(module, exports) {

	module.exports = cross

	/**
	 * Computes the cross product of two vec2's
	 * Note that the cross product must by definition produce a 3D vector
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec3} out
	 */
	function cross(out, a, b) {
	    var z = a[0] * b[1] - a[1] * b[0]
	    out[0] = out[1] = 0
	    out[2] = z
	    return out
	}

/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = lerp

	/**
	 * Performs a linear interpolation between two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec2} out
	 */
	function lerp(out, a, b, t) {
	    var ax = a[0],
	        ay = a[1]
	    out[0] = ax + t * (b[0] - ax)
	    out[1] = ay + t * (b[1] - ay)
	    return out
	}

/***/ },
/* 189 */
/***/ function(module, exports) {

	module.exports = random

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec2} out
	 */
	function random(out, scale) {
	    scale = scale || 1.0
	    var r = Math.random() * 2.0 * Math.PI
	    out[0] = Math.cos(r) * scale
	    out[1] = Math.sin(r) * scale
	    return out
	}

/***/ },
/* 190 */
/***/ function(module, exports) {

	module.exports = transformMat2

	/**
	 * Transforms the vec2 with a mat2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat2(out, a, m) {
	    var x = a[0],
	        y = a[1]
	    out[0] = m[0] * x + m[2] * y
	    out[1] = m[1] * x + m[3] * y
	    return out
	}

/***/ },
/* 191 */
/***/ function(module, exports) {

	module.exports = transformMat2d

	/**
	 * Transforms the vec2 with a mat2d
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2d} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat2d(out, a, m) {
	    var x = a[0],
	        y = a[1]
	    out[0] = m[0] * x + m[2] * y + m[4]
	    out[1] = m[1] * x + m[3] * y + m[5]
	    return out
	}

/***/ },
/* 192 */
/***/ function(module, exports) {

	module.exports = transformMat3

	/**
	 * Transforms the vec2 with a mat3
	 * 3rd vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat3} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat3(out, a, m) {
	    var x = a[0],
	        y = a[1]
	    out[0] = m[0] * x + m[3] * y + m[6]
	    out[1] = m[1] * x + m[4] * y + m[7]
	    return out
	}

/***/ },
/* 193 */
/***/ function(module, exports) {

	module.exports = transformMat4

	/**
	 * Transforms the vec2 with a mat4
	 * 3rd vector component is implicitly '0'
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat4(out, a, m) {
	    var x = a[0], 
	        y = a[1]
	    out[0] = m[0] * x + m[4] * y + m[12]
	    out[1] = m[1] * x + m[5] * y + m[13]
	    return out
	}

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = forEach

	var vec = __webpack_require__(167)()

	/**
	 * Perform some operation over an array of vec2s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	function forEach(a, stride, offset, count, fn, arg) {
	    var i, l
	    if(!stride) {
	        stride = 2
	    }

	    if(!offset) {
	        offset = 0
	    }
	    
	    if(count) {
	        l = Math.min((count * stride) + offset, a.length)
	    } else {
	        l = a.length
	    }

	    for(i = offset; i < l; i += stride) {
	        vec[0] = a[i]
	        vec[1] = a[i+1]
	        fn(vec, vec, arg)
	        a[i] = vec[0]
	        a[i+1] = vec[1]
	    }
	    
	    return a
	}

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var vgl = __webpack_require__(81);
	var inherit = __webpack_require__(4);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class timestamp
	 *
	 * @class geo.timestamp
	 * @extends vgl.timestamp
	 * @returns {geo.timestamp}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var timestamp = function () {
	  'use strict';
	  if (!(this instanceof timestamp)) {
	    return new timestamp();
	  }
	  vgl.timestamp.call(this);
	};

	inherit(timestamp, vgl.timestamp);
	module.exports = timestamp;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);

	/**
	 * @module geo.util
	 */
	var util = __webpack_require__(197);
	$.extend(util, __webpack_require__(198));
	util.DistanceGrid = __webpack_require__(199);
	util.ClusterGroup = __webpack_require__(200);

	module.exports = util;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	
	(function () {
	  'use strict';

	  var $ = __webpack_require__(1);
	  var geo = {util: {}};
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

	  var m_timingData = {},
	      m_timingKeepRecent = 200,
	      m_threshold = 15,
	      m_originalRequestAnimationFrame;

	  /**
	   * Takes a variable number of arguments and returns the first numeric value
	   * it finds.
	   * @private
	   */
	  function setNumeric() {
	    var i;
	    for (i = 0; i < arguments.length; i += 1) {
	      if (isFinite(arguments[i])) {
	        return arguments[i];
	      }
	    }
	  }

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Contains utility classes and methods used by geojs.
	   * @namespace
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  geo.util = {
	    /**
	     * Returns true if the given point lies in the given polygon.
	     * Algorithm description:
	     *   http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
	     * @param {geo.screenPosition} point The test point
	     * @param {geo.screenPosition[]} outer The outer boundary of the polygon
	     * @param {geo.screenPosition[][]} [inner] Inner boundaries (holes)
	     * @param {Object} [range] If specified, range.min.x, range.min.y,
	     *   range.max.x, and range.max.y specified the extents of the outer
	     *   polygon and are used for early detection.
	     * @returns {boolean} true if the point is inside the polygon.
	     */
	    pointInPolygon: function (point, outer, inner, range) {
	      var inside = false, n = outer.length, i, j;

	      if (range && range.min && range.max) {
	        if (point.x < range.min.x || point.y < range.min.y ||
	            point.x > range.max.x || point.y > range.max.y) {
	          return;
	        }
	      }

	      if (n < 3) {
	        // we need 3 coordinates for this to make sense
	        return false;
	      }

	      for (i = 0, j = n - 1; i < n; j = i, i += 1) {
	        if (((outer[i].y > point.y) !== (outer[j].y > point.y)) &&
	            (point.x < (outer[j].x - outer[i].x) *
	            (point.y - outer[i].y) / (outer[j].y - outer[i].y) + outer[i].x)) {
	          inside = !inside;
	        }
	      }

	      if (inner && inside) {
	        (inner || []).forEach(function (hole) {
	          inside = inside && !geo.util.pointInPolygon(point, hole);
	        });
	      }

	      return inside;
	    },

	    /**
	     * Returns true if the argument is a function.
	     */
	    isFunction: function (f) {
	      return typeof f === 'function';
	    },

	    /**
	     * Returns the argument if it is function, otherwise returns a function
	     * that returns the argument.
	     */
	    ensureFunction: function (f) {
	      if (geo.util.isFunction(f)) {
	        return f;
	      } else {
	        return function () { return f; };
	      }
	    },

	    /**
	     * Return a random string of length n || 8.
	     */
	    randomString: function (n) {
	      var s, i, r;
	      n = n || 8;
	      s = '';
	      for (i = 0; i < n; i += 1) {
	        r = Math.floor(Math.random() * chars.length);
	        s += chars.substring(r, r + 1);
	      }
	      return s;
	    },

	    /**
	     * Convert a color from hex value or css name to rgb objects
	     */
	    convertColor: function (color) {
	      if (color.r !== undefined && color.g !== undefined &&
	          color.b !== undefined) {
	        return color;
	      }
	      if (typeof color === 'string') {
	        if (geo.util.cssColors.hasOwnProperty(color)) {
	          color = geo.util.cssColors[color];
	        } else if (color.charAt(0) === '#') {
	          if (color.length === 4) {
	            /* interpret values of the form #rgb as #rrggbb */
	            color = parseInt(color.slice(1), 16);
	            color = (color & 0xf00) * 0x1100 + (color & 0xf0) * 0x110 + (color & 0xf) * 0x11;
	          } else {
	            color = parseInt(color.slice(1), 16);
	          }
	        }
	      }
	      if (isFinite(color)) {
	        color = {
	          r: ((color & 0xff0000) >> 16) / 255,
	          g: ((color & 0xff00) >> 8) / 255,
	          b: ((color & 0xff)) / 255
	        };
	      }
	      return color;
	    },

	    /**
	     * Normalize a coordinate object into {x: ..., y: ..., z: ... } form.
	     * Accepts 2-3d arrays,
	     * latitude -> lat -> y
	     * longitude -> lon -> lng -> x
	     */
	    normalizeCoordinates: function (p) {
	      p = p || {};
	      if (Array.isArray(p)) {
	        return {
	          x: p[0],
	          y: p[1],
	          z: p[2] || 0
	        };
	      }
	      return {
	        x: setNumeric(
	          p.x,
	          p.longitude,
	          p.lng,
	          p.lon,
	          0
	        ),
	        y: setNumeric(
	          p.y,
	          p.latitude,
	          p.lat,
	          0
	        ),
	        z: setNumeric(
	          p.z,
	          p.elevation,
	          p.elev,
	          p.height,
	          0
	        )
	      };
	    },

	    /**
	     * Radius of the earth in meters, from the equatorial radius of SRID 4326.
	     */
	    radiusEarth: 6378137,

	    /**
	     * Linearly combine two "coordinate-like" objects in a uniform way.
	     * Coordinate like objects have ``x``, ``y``, and optionally a ``z``
	     * key.  The first object is mutated.
	     *
	     *   a <= ca * a + cb * b
	     *
	     * @param {number} ca
	     * @param {object} a
	     * @param {number} [a.x=0]
	     * @param {number} [a.y=0]
	     * @param {number} [a.z=0]
	     * @param {number} cb
	     * @param {object} b
	     * @param {number} [b.x=0]
	     * @param {number} [b.y=0]
	     * @param {number} [b.z=0]
	     * @returns {object} ca * a + cb * b
	     */
	    lincomb: function (ca, a, cb, b) {
	      a.x = ca * (a.x || 0) + cb * (b.x || 0);
	      a.y = ca * (a.y || 0) + cb * (b.y || 0);
	      a.z = ca * (a.x || 0) + cb * (b.x || 0);
	      return a;
	    },

	    /**
	     * Element-wise product of two coordinate-like object.  Mutates
	     * the first object.  Note the default values for ``b``, which
	     * are intended to used as a anisotropic scaling factors.
	     *
	     *   a <= a * b^pow
	     *
	     * @param {object} a
	     * @param {number} [a.x=0]
	     * @param {number} [a.y=0]
	     * @param {number} [a.z=0]
	     * @param {object} b
	     * @param {number} [b.x=1]
	     * @param {number} [b.y=1]
	     * @param {number} [b.z=1]
	     * @param {number} [pow=1]
	     * @returns {object} a * b^pow
	     */
	    scale: function (a, b, pow) {
	      a.x = (a.x || 0) * Math.pow(b.x || 1, pow);
	      a.y = (a.y || 0) * Math.pow(b.y || 1, pow);
	      a.z = (a.z || 0) * Math.pow(b.z || 1, pow);
	      return a;
	    },

	    /**
	     * Compare two arrays and return if their contents are equal.
	     * @param {array} a1 first array to compare
	     * @param {array} a2 second array to compare
	     * @returns {boolean} true if the contents of the arrays are equal.
	     */
	    compareArrays: function (a1, a2) {
	      return (a1.length === a2.length && a1.every(function (el, idx) {
	        return el === a2[idx];
	      }));
	    },

	    /**
	     * Create a vec3 that is always an array.  This should only be used if it
	     * will not be used in a WebGL context.  Plain arrays usually use 64-bit
	     * float values, whereas vec3 defaults to 32-bit floats.
	     *
	     * @returns {Array} zeroed-out vec3 compatible array.
	     */
	    vec3AsArray: function () {
	      return [0, 0, 0];
	    },

	    /**
	     * Create a mat4 that is always an array.  This should only be used if it
	     * will not be used in a WebGL context.  Plain arrays usually use 64-bit
	     * float values, whereas mat4 defaults to 32-bit floats.
	     *
	     * @returns {Array} identity mat4 compatible array.
	     */
	    mat4AsArray: function () {
	      return [
	        1, 0, 0, 0,
	        0, 1, 0, 0,
	        0, 0, 1, 0,
	        0, 0, 0, 1
	      ];
	    },

	    /**
	     * Get a buffer for a vgl geometry source.  If a buffer already exists and
	     * is the correct size, return it.  Otherwise, allocate a new buffer; any
	     * data in an old buffer is discarded.
	     *
	     * @param geom: the geometry to reference and modify.
	     * @param srcName: the name of the source.
	     * @param len: the number of elements for the array.
	     * @returns {Float32Array}
	     */
	    getGeomBuffer: function (geom, srcName, len) {
	      var src = geom.sourceByName(srcName), data;

	      data = src.data();
	      if (data instanceof Float32Array && data.length === len) {
	        return data;
	      }
	      data = new Float32Array(len);
	      src.setData(data);
	      return data;
	    },

	    /**
	     * Ensure that the input and modifiers properties of all actions are
	     * objects, not plain strings.
	     *
	     * @param {Array} actions: an array of actions to adjust as needed.
	     */
	    adjustActions: function (actions) {
	      var action, i;
	      for (i = 0; i < actions.length; i += 1) {
	        action = actions[i];
	        if ($.type(action.input) === 'string') {
	          var actionEvents = {};
	          actionEvents[action.input] = true;
	          action.input = actionEvents;
	        }
	        if (!action.modifiers) {
	          action.modifiers = {};
	        }
	        if ($.type(action.modifiers) === 'string') {
	          var actionModifiers = {};
	          actionModifiers[action.modifiers] = true;
	          action.modifiers = actionModifiers;
	        }
	      }
	    },

	    /**
	     * Add an action to the list of handled actions.
	     *
	     * @param {Array} actions: an array of actions to adjust as needed.
	     * @param {object} action: an object defining the action.  This must have
	     *    action and event properties, and may have modifiers, name, and owner.
	     *    Use action, name, and owner to make this entry distinct if it will
	     *    need to be removed later.
	     * @param {boolean} toEnd: the action is added at the beginning of the
	     *    actions list unless toEnd is true.  Earlier actions prevent later
	     *    actions with the similar input and modifiers.
	     */
	    addAction: function (actions, action, toEnd) {
	      if (toEnd) {
	        actions.push(action);
	      } else {
	        actions.unshift(action);
	      }
	      geo.util.adjustActions(actions);
	    },

	    /**
	     * Check if an action is in the actions list.  An action matches if the
	     * action, name, and owner match.  A null or undefined value will match all
	     * actions.  If using an action object, this is the same as passing
	     * (action.action, action.name, action.owner).
	     *
	     * @param {Array} actions: an array of actions to search.
	     * @param {object|string} action Either an action object or the name of an
	     *    action.
	     * @param {string} name Optional name associated with the action.
	     * @param {string} owner Optional owner associated with the action.
	     * @return action the first matching action or null.
	     */
	    hasAction: function (actions, action, name, owner) {
	      if (action && action.action) {
	        name = action.name;
	        owner = action.owner;
	        action = action.action;
	      }
	      for (var i = 0; i < actions.length; i += 1) {
	        if ((!action || actions[i].action === action) &&
	            (!name || actions[i].name === name) &&
	            (!owner || actions[i].owner === owner)) {
	          return actions[i];
	        }
	      }
	      return null;
	    },

	    /**
	     * Remove all matching actions.  Actions are matched as with hasAction.
	     *
	     * @param {Array} actions: an array of actions to adjust as needed.
	     * @param {object|string} action Either an action object or the name of an
	     *    action.
	     * @param {string} name Optional name associated with the action.
	     * @param {string} owner Optional owner associated with the action.
	     * @return numRemoved the number of actions that were removed.
	     */
	    removeAction: function (actions, action, name, owner) {
	      var found, removed = 0;

	      do {
	        found = geo.util.hasAction(actions, action, name, owner);
	        if (found) {
	          actions.splice($.inArray(found, actions), 1);
	          removed += 1;
	        }
	      } while (found);
	      return removed;
	    },

	    /**
	     * Determine if the current inputs and modifiers match a known action.
	     *
	     * @param {object} inputs: an object where each input that is currently
	     *    active is truthy.  Common inputs are left, right, middle, wheel.
	     * @param {object} modifiers: an object where each currently applied
	     *    modifier is truthy.  Common modifiers are shift, ctrl, alt, meta.
	     * @param {Array} actions: a list of actions to compare to the inputs and
	     *    modifiers.  The first action that matches will be returned.
	     * @returns {object} action A matching action or undefined.
	     */
	    actionMatch: function (inputs, modifiers, actions) {
	      var matched;

	      /* actions must have already been processed by adjustActions */
	      if (actions.some(function (action) {
	        for (var input in action.input) {
	          if (action.input.hasOwnProperty(input)) {
	            if ((action.input[input] === false && inputs[input]) ||
	                (action.input[input] && !inputs[input])) {
	              return false;
	            }
	          }
	        }
	        for (var modifier in action.modifiers) {
	          if (action.modifiers.hasOwnProperty(modifier)) {
	            if ((action.modifiers[modifier] === false && modifiers[modifier]) ||
	                (action.modifiers[modifier] && !modifiers[modifier])) {
	              return false;
	            }
	          }
	        }
	        matched = action;
	        return true;
	      })) {
	        return matched;
	      }
	    },

	    /**
	     * Report on one or all of the tracked timings.
	     *
	     * @param {string} name name to report on, or undefined to report all.
	     */
	    timeReport: function (name) {
	      $.each(m_timingData, function (key, item) {
	        /* calculate the standard deviation of each item. */
	        if (item.count) {
	          item.stddev = Math.sqrt(Math.abs((
	            item.sum2 - item.sum * item.sum / item.count) / item.count));
	          item.average = item.sum / item.count;
	        } else {
	          item.stddev = 0;
	          item.average = 0;
	        }
	      });
	      if (name) {
	        return m_timingData[name];
	      }
	      return m_timingData;
	    },

	    /**
	     * Note the start time of a function (or any other section of code).  This
	     * should be paired with timeFunctionStop, which will collect statistics on
	     * the amount of time spent in a function.
	     *
	     * @param {string} name name to use for tracking the timing.
	     * @param {boolean} reset if true, clear old tracking data.
	     */
	    timeFunctionStart: function (name, reset) {
	      if (!m_timingData[name] || reset) {
	        m_timingData[name] = {
	          count: 0, sum: 0, sum2: 0, max: 0, recent: []
	        };
	      }
	      m_timingData[name].start = window.performance.now();
	    },

	    /**
	     * Note the stop time of a function (or any other section of code).  This
	     * should be paired with timeFunctionStart.
	     *
	     * @param {string} name name to use for tracking the timing.
	     */
	    timeFunctionStop: function (name) {
	      if (!m_timingData[name] || !m_timingData[name].start) {
	        return;
	      }
	      var duration = window.performance.now() - m_timingData[name].start;
	      m_timingData[name].start = null;
	      m_timingData[name].sum += duration;
	      m_timingData[name].sum2 += duration * duration;
	      m_timingData[name].count += 1;
	      m_timingData[name].max = Math.max(
	        m_timingData[name].max, duration);
	      m_timingData[name].recent.push(duration);
	      if (m_timingData[name].recent.length > m_timingKeepRecent) {
	        m_timingData[name].recent.splice(
	            0, m_timingData[name].recent.length - m_timingKeepRecent);
	      }
	    },

	    /**
	     * Start or stop tracking the time spent in requestAnimationFrame.  If
	     * tracked, the results can be fetched via
	     * timeFunctionReport('requestAnimationFrame').
	     *
	     * @param {boolean} stop falsy to start tracking, truthy to start tracking.
	     * @param {boolean} reset if true, reset the statistics.
	     * @param {number} threshold if present, set the threshold used in tracking
	     *   slow callbacks.
	     * @param {number} keep if present, set the number of recent frame times
	     *   to track.
	     */
	    timeRequestAnimationFrame: function (stop, reset, threshold, keep) {
	      if (!m_timingData.requestAnimationFrame || reset) {
	        m_timingData.requestAnimationFrame = {
	          count: 0, sum: 0, sum2: 0, max: 0, above_threshold: 0,
	          recent: [], recentsub: []
	        };
	      }
	      if (threshold) {
	        m_threshold = threshold;
	      }
	      if (keep) {
	        m_timingKeepRecent = keep;
	      }
	      if (stop && m_originalRequestAnimationFrame) {
	        window.requestAnimationFrame = m_originalRequestAnimationFrame;
	        m_originalRequestAnimationFrame = null;
	      } else if (!stop && !m_originalRequestAnimationFrame) {
	        m_originalRequestAnimationFrame = window.requestAnimationFrame;
	        window.requestAnimationFrame = function (callback) {
	          m_originalRequestAnimationFrame.call(window, function (timestamp) {
	            var track = m_timingData.requestAnimationFrame, recent;
	            /* Some environments have unsynchronized performance and time
	             * counters.  The nowDelta factor compensates for this.  For
	             * instance, our test enviornment has performance.now() values on
	             * the order of ~3000 and timestamps approximating epoch. */
	            if (track.timestamp !== timestamp) {
	              track.nowDelta = window.performance.now() - timestamp;
	              if (Math.abs(track.nowDelta) < 1000) {
	                track.nowDelta = 0;
	              }
	              track.timestamp = timestamp;
	              track.subcalls = track.subcalls || 0;
	              track.start = {
	                sum: track.sum,
	                sum2: track.sum2,
	                count: track.count,
	                max: track.max,
	                above_threshold: track.above_threshold
	              };
	              track.recent.push([0]);
	              track.recentsub.push([]);
	              if (track.recent.length > m_timingKeepRecent) {
	                track.recent.splice(
	                    0, track.recent.length - m_timingKeepRecent);
	                track.recentsub.splice(
	                    0, track.recentsub.length - m_timingKeepRecent);
	              }
	            }
	            track.subcalls += 1;
	            callback.apply(this, arguments);
	            var duration = window.performance.now() - timestamp;
	            duration -= track.nowDelta;
	            track.sum = track.start.sum + duration;
	            track.sum2 = track.start.sum2 + duration * duration;
	            track.count = track.start.count + 1;
	            track.max = Math.max(track.max, duration);
	            track.above_threshold = track.start.above_threshold + (
	              duration >= m_threshold ? 1 : 0);
	            track.recent[track.recent.length - 1] = duration;
	            recent = track.recentsub[track.recent.length - 1];
	            recent.push({
	              total_duration: duration,
	              duration: duration - (recent.length ?
	                recent[recent.length - 1].total_duration : 0),
	              callback: callback.name || callback
	            });
	          });
	        };
	      }
	    }
	  };

	  geo.util.cssColors = {
	    aliceblue: 0xf0f8ff,
	    antiquewhite: 0xfaebd7,
	    aqua: 0x00ffff,
	    aquamarine: 0x7fffd4,
	    azure: 0xf0ffff,
	    beige: 0xf5f5dc,
	    bisque: 0xffe4c4,
	    black: 0x000000,
	    blanchedalmond: 0xffebcd,
	    blue: 0x0000ff,
	    blueviolet: 0x8a2be2,
	    brown: 0xa52a2a,
	    burlywood: 0xdeb887,
	    cadetblue: 0x5f9ea0,
	    chartreuse: 0x7fff00,
	    chocolate: 0xd2691e,
	    coral: 0xff7f50,
	    cornflowerblue: 0x6495ed,
	    cornsilk: 0xfff8dc,
	    crimson: 0xdc143c,
	    cyan: 0x00ffff,
	    darkblue: 0x00008b,
	    darkcyan: 0x008b8b,
	    darkgoldenrod: 0xb8860b,
	    darkgray: 0xa9a9a9,
	    darkgreen: 0x006400,
	    darkgrey: 0xa9a9a9,
	    darkkhaki: 0xbdb76b,
	    darkmagenta: 0x8b008b,
	    darkolivegreen: 0x556b2f,
	    darkorange: 0xff8c00,
	    darkorchid: 0x9932cc,
	    darkred: 0x8b0000,
	    darksalmon: 0xe9967a,
	    darkseagreen: 0x8fbc8f,
	    darkslateblue: 0x483d8b,
	    darkslategray: 0x2f4f4f,
	    darkslategrey: 0x2f4f4f,
	    darkturquoise: 0x00ced1,
	    darkviolet: 0x9400d3,
	    deeppink: 0xff1493,
	    deepskyblue: 0x00bfff,
	    dimgray: 0x696969,
	    dimgrey: 0x696969,
	    dodgerblue: 0x1e90ff,
	    firebrick: 0xb22222,
	    floralwhite: 0xfffaf0,
	    forestgreen: 0x228b22,
	    fuchsia: 0xff00ff,
	    gainsboro: 0xdcdcdc,
	    ghostwhite: 0xf8f8ff,
	    gold: 0xffd700,
	    goldenrod: 0xdaa520,
	    gray: 0x808080,
	    green: 0x008000,
	    greenyellow: 0xadff2f,
	    grey: 0x808080,
	    honeydew: 0xf0fff0,
	    hotpink: 0xff69b4,
	    indianred: 0xcd5c5c,
	    indigo: 0x4b0082,
	    ivory: 0xfffff0,
	    khaki: 0xf0e68c,
	    lavender: 0xe6e6fa,
	    lavenderblush: 0xfff0f5,
	    lawngreen: 0x7cfc00,
	    lemonchiffon: 0xfffacd,
	    lightblue: 0xadd8e6,
	    lightcoral: 0xf08080,
	    lightcyan: 0xe0ffff,
	    lightgoldenrodyellow: 0xfafad2,
	    lightgray: 0xd3d3d3,
	    lightgreen: 0x90ee90,
	    lightgrey: 0xd3d3d3,
	    lightpink: 0xffb6c1,
	    lightsalmon: 0xffa07a,
	    lightseagreen: 0x20b2aa,
	    lightskyblue: 0x87cefa,
	    lightslategray: 0x778899,
	    lightslategrey: 0x778899,
	    lightsteelblue: 0xb0c4de,
	    lightyellow: 0xffffe0,
	    lime: 0x00ff00,
	    limegreen: 0x32cd32,
	    linen: 0xfaf0e6,
	    magenta: 0xff00ff,
	    maroon: 0x800000,
	    mediumaquamarine: 0x66cdaa,
	    mediumblue: 0x0000cd,
	    mediumorchid: 0xba55d3,
	    mediumpurple: 0x9370db,
	    mediumseagreen: 0x3cb371,
	    mediumslateblue: 0x7b68ee,
	    mediumspringgreen: 0x00fa9a,
	    mediumturquoise: 0x48d1cc,
	    mediumvioletred: 0xc71585,
	    midnightblue: 0x191970,
	    mintcream: 0xf5fffa,
	    mistyrose: 0xffe4e1,
	    moccasin: 0xffe4b5,
	    navajowhite: 0xffdead,
	    navy: 0x000080,
	    oldlace: 0xfdf5e6,
	    olive: 0x808000,
	    olivedrab: 0x6b8e23,
	    orange: 0xffa500,
	    orangered: 0xff4500,
	    orchid: 0xda70d6,
	    palegoldenrod: 0xeee8aa,
	    palegreen: 0x98fb98,
	    paleturquoise: 0xafeeee,
	    palevioletred: 0xdb7093,
	    papayawhip: 0xffefd5,
	    peachpuff: 0xffdab9,
	    peru: 0xcd853f,
	    pink: 0xffc0cb,
	    plum: 0xdda0dd,
	    powderblue: 0xb0e0e6,
	    purple: 0x800080,
	    red: 0xff0000,
	    rosybrown: 0xbc8f8f,
	    royalblue: 0x4169e1,
	    saddlebrown: 0x8b4513,
	    salmon: 0xfa8072,
	    sandybrown: 0xf4a460,
	    seagreen: 0x2e8b57,
	    seashell: 0xfff5ee,
	    sienna: 0xa0522d,
	    silver: 0xc0c0c0,
	    skyblue: 0x87ceeb,
	    slateblue: 0x6a5acd,
	    slategray: 0x708090,
	    slategrey: 0x708090,
	    snow: 0xfffafa,
	    springgreen: 0x00ff7f,
	    steelblue: 0x4682b4,
	    tan: 0xd2b48c,
	    teal: 0x008080,
	    thistle: 0xd8bfd8,
	    tomato: 0xff6347,
	    turquoise: 0x40e0d0,
	    violet: 0xee82ee,
	    wheat: 0xf5deb3,
	    white: 0xffffff,
	    whitesmoke: 0xf5f5f5,
	    yellow: 0xffff00,
	    yellowgreen: 0x9acd32
	  };

	  module.exports = geo.util;
	}());


/***/ },
/* 198 */
/***/ function(module, exports) {

	/**
	 * @file
	 * Based on the following jquery throttle / debounce plugin:
	 *
	 * jQuery throttle / debounce - v1.1 - 3/7/2010
	 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
	 *
	 * @copyright 2010 "Cowboy" Ben Alman
	 * Dual licensed under the MIT and GPL licenses.
	 * http://benalman.com/about/license/
	 *
	 * The implementation included here is modified to support a callback
	 * method that can accumulate values between actual invocations of
	 * the throttled method.
	 */

	(function (window) {
	  'use strict';

	  /**
	   * Throttle execution of a function. Especially useful for rate limiting
	   * execution of handlers on events like resize and scroll. If you want to
	   * rate-limit execution of a function to a single time see
	   * {@link geo.util.debounce}.
	   *
	   * In this visualization, | is a throttled-function call and X is the actual
	   * callback execution:
	   *
	   * ::
	   *   Throttled with `no_trailing` specified as false or unspecified:
	   *   ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
	   *   X    X    X    X    X    X        X    X    X    X    X    X
	   *
	   *   Throttled with `no_trailing` specified as true:
	   *   ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
	   *   X    X    X    X    X             X    X    X    X    X
	   *
	   * @function geo.util.throttle
	   * @param {number} delay A zero-or-greater delay in milliseconds. For event
	   *    callbacks, values around 100 or 250 (or even higher) are most useful.
	   * @param {boolean} [no_trailing=false] If no_trailing is
	   *    true, callback will only execute every `delay` milliseconds while the
	   *    throttled-function is being called. If no_trailing is false or
	   *    unspecified, callback will be executed one final time after the last
	   *    throttled-function call. (After the throttled-function has not been
	   *    called for `delay` milliseconds, the internal counter is reset)
	   * @param {function} callback A function to be executed after `delay`
	   *    milliseconds. The `this` context and all arguments are passed through,
	   *    as-is, to `callback` when the throttled-function is executed.
	   * @param {function} [accumulator] A function to be executed (synchronously)
	   *    during **each** call to the wrapped function.  Typically, this
	   *    this method is used to accumulate values that the callback uses
	   *    when it finally executes.
	   *
	   * @returns {function} The throttled version of `callback`
	   *
	   * @example
	   * var throttled = geo.util.throttle( delay, [ no_trailing, ] callback );
	   * $('selector').bind( 'someevent', throttled );
	   * $('selector').unbind( 'someevent', throttled );
	   */
	  var throttle = function (delay, no_trailing,
	                                callback, accumulator, debounce_mode) {
	    // After wrapper has stopped being called, this timeout ensures that
	    // `callback` is executed at the proper times in `throttle` and `end`
	    // debounce modes.
	    var timeout_id,

	      // Keep track of the last time `callback` was executed.
	        last_exec = 0;

	    // `no_trailing` defaults to falsy.
	    if (typeof no_trailing !== 'boolean') {
	      debounce_mode = accumulator;
	      accumulator = callback;
	      callback = no_trailing;
	      no_trailing = undefined;
	    }

	    // accumulator defaults to no-op
	    if (typeof accumulator !== 'function') {
	      debounce_mode = accumulator;
	      accumulator = function () {};
	    }

	    // The `wrapper` function encapsulates all of the throttling / debouncing
	    // functionality and when executed will limit the rate at which `callback`
	    // is executed.
	    function wrapper() {
	      var that = this,
	          elapsed = +new Date() - last_exec,
	          args = arguments;

	      // Execute `callback` and update the `last_exec` timestamp.
	      function exec() {
	        last_exec = +new Date();
	        callback.apply(that, args);
	      }

	      // If `debounce_mode` is true (at_begin) this is used to clear the flag
	      // to allow future `callback` executions.
	      function clear() {
	        timeout_id = undefined;
	      }

	      // always call the accumulator first
	      accumulator.apply(that, args);

	      if (debounce_mode && !timeout_id) {
	        // Since `wrapper` is being called for the first time and
	        // `debounce_mode` is true (at_begin), execute `callback`.
	        exec();
	      }

	      // Clear any existing timeout.
	      void (
	        timeout_id && clearTimeout(timeout_id)
	      );

	      if (debounce_mode === undefined && elapsed > delay) {
	        // In throttle mode, if `delay` time has been exceeded, execute
	        // `callback`.
	        exec();

	      } else if (no_trailing !== true) {
	        // In trailing throttle mode, since `delay` time has not been
	        // exceeded, schedule `callback` to execute `delay` ms after most
	        // recent execution.
	        //
	        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
	        // after `delay` ms.
	        //
	        // If `debounce_mode` is false (at end), schedule `callback` to
	        // execute after `delay` ms.
	        timeout_id = setTimeout(
	          debounce_mode ?
	            clear :
	            exec,
	          debounce_mode === undefined ?
	            delay - elapsed :
	            delay
	        );
	      }
	    }

	    // Return the wrapper function.
	    return wrapper;
	  };

	  /**
	   * Debounce execution of a function. Debouncing, unlike throttling,
	   * guarantees that a function is only executed a single time, either at the
	   * very beginning of a series of calls, or at the very end. If you want to
	   * simply rate-limit execution of a function, see the <jQuery.throttle>
	   * method.
	   *
	   * In this visualization, | is a debounced-function call and X is the actual
	   * callback execution:
	   *
	   * ::
	   *
	   *   Debounced with `at_begin` specified as false or unspecified:
	   *   ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
	   *                            X                                 X
	   *
	   *   Debounced with `at_begin` specified as true:
	   *   ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
	   *   X                                 X
	   *
	   *
	   * @param {number} delay A zero-or-greater delay in milliseconds. For event
	   *    callbacks, values around 100 or 250 (or even higher) are most useful.
	   * @param {boolean} [at_begin=false] If at_begin is false or
	   *    unspecified, callback will only be executed `delay` milliseconds after
	   *    the last debounced-function call. If at_begin is true, callback will be
	   *    executed only at the first debounced-function call. (After the
	   *    throttled-function has not been called for `delay` milliseconds, the
	   *    internal counter is reset)
	   * @param {function} callback A function to be executed after delay milliseconds.
	   *    The `this` context and all arguments are passed through, as-is, to
	   *    `callback` when the debounced-function is executed.
	   * @param {function} [accumulator] A function to be executed (synchronously)
	   *    during **each** call to the wrapped function.  Typically, this
	   *    this method is used to accumulate values that the callback uses
	   *    when it finally executes.
	   *
	   * @returns {function} A new, debounced, function.
	   *
	   * @example
	   * var debounced = geo.util.debounce( delay, [ at_begin, ] callback );
	   * $('selector').bind( 'someevent', debounced );
	   * $('selector').unbind( 'someevent', debounced );
	   *
	   */

	  var debounce = function (delay, at_begin, callback, accumulator) {
	    if (typeof at_begin !== 'boolean') {
	      accumulator = callback;
	      callback = at_begin;
	      at_begin = false;
	    }
	    accumulator = accumulator || function () {};
	    return throttle(delay, false, callback, accumulator, !!at_begin);
	  };

	  module.exports = {
	    throttle: throttle,
	    debounce: debounce
	  };
	})(this);


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/*
	markercluster plugin:

	Copyright 2012 David Leaver

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	Leaflet utilities:

	Copyright (c) 2010-2015, Vladimir Agafonkin
	Copyright (c) 2010-2011, CloudMade
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are
	permitted provided that the following conditions are met:

	   1. Redistributions of source code must retain the above copyright notice, this list of
	      conditions and the following disclaimer.

	   2. Redistributions in binary form must reproduce the above copyright notice, this list
	      of conditions and the following disclaimer in the documentation and/or other
	      materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	/**
	 * @file
	 * Code taken from https://github.com/Leaflet/Leaflet.markercluster
	 * to support faster hierarchical clustering of features.
	 * @copyright 2012, David Leaver
	 */

	(function () {
	    "use strict";

	    var $ = __webpack_require__(1);
	    var L = {};
	    L.Util = {
	        // return unique ID of an object
	        stamp: function (obj) {
	            obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
	            return obj._leaflet_id;
	        },
	        lastId: 0
	    };

	    var DistanceGrid = function (cellSize) {
	        this._cellSize = cellSize;
	        this._sqCellSize = cellSize * cellSize;
	        this._grid = {};
	        this._objectPoint = {};
	    };

	    DistanceGrid.prototype = {

	        addObject: function (obj, point) {
	            var x = this._getCoord(point.x),
	                y = this._getCoord(point.y),
	                grid = this._grid,
	                row = grid[y] = grid[y] || {},
	                cell = row[x] = row[x] || [],
	                stamp = L.Util.stamp(obj);

	            point.obj = obj;
	            this._objectPoint[stamp] = point;

	            cell.push(obj);
	        },

	        updateObject: function (obj, point) {
	            this.removeObject(obj);
	            this.addObject(obj, point);
	        },

	        //Returns true if the object was found
	        removeObject: function (obj, point) {
	            var x = this._getCoord(point.x),
	                y = this._getCoord(point.y),
	                grid = this._grid,
	                row = grid[y] = grid[y] || {},
	                cell = row[x] = row[x] || [],
	                i, len;

	            delete this._objectPoint[L.Util.stamp(obj)];

	            for (i = 0, len = cell.length; i < len; i++) {
	                if (cell[i] === obj) {

	                    cell.splice(i, 1);

	                    if (len === 1) {
	                        delete row[x];
	                    }

	                    return true;
	                }
	            }

	        },

	        eachObject: function (fn, context) {
	            var i, j, k, len, row, cell, removed,
	                grid = this._grid;

	            for (i in grid) {
	                row = grid[i];

	                for (j in row) {
	                    cell = row[j];

	                    for (k = 0, len = cell.length; k < len; k++) {
	                        removed = fn.call(context, cell[k]);
	                        if (removed) {
	                            k--;
	                            len--;
	                        }
	                    }
	                }
	            }
	        },

	        getNearObject: function (point) {
	            var x = this._getCoord(point.x),
	                y = this._getCoord(point.y),
	                i, j, k, row, cell, len, obj, dist,
	                objectPoint = this._objectPoint,
	                closestDistSq = this._sqCellSize,
	                closest = null;

	            for (i = y - 1; i <= y + 1; i++) {
	                row = this._grid[i];
	                if (row) {

	                    for (j = x - 1; j <= x + 1; j++) {
	                        cell = row[j];
	                        if (cell) {

	                            for (k = 0, len = cell.length; k < len; k++) {
	                                obj = cell[k];
	                                dist = this._sqDist(
	                                    objectPoint[L.Util.stamp(obj)],
	                                    point
	                                );
	                                if (dist < closestDistSq) {
	                                    closestDistSq = dist;
	                                    closest = obj;
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return closest;
	        },

	        /* return the point coordinates contained in the structure */
	        contents: function () {
	            return $.map(this._objectPoint, function (val) { return val; });
	        },

	        _getCoord: function (x) {
	            return Math.floor(x / this._cellSize);
	        },

	        _sqDist: function (p, p2) {
	            var dx = p2.x - p.x,
	                dy = p2.y - p.y;
	            return dx * dx + dy * dy;
	        }
	    };

	    module.exports = DistanceGrid;
	})();


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file
	 * Using methods adapted from leaflet to cluster an array of positions
	 * hierarchically given an array of length scales (zoom levels).
	 */

	(function () {
	  'use strict';

	  var $ = __webpack_require__(1);
	  var vgl = __webpack_require__(81);

	  /**
	   * This class manages a group of nearby points that are clustered as a
	   * single object for display purposes.  The class constructor is private
	   * and only meant to be created by the ClusterGroup object.
	   *
	   * This is a tree-like data structure.  Each node in the tree is a
	   * cluster containing child clusters and unclustered points.
	   *
	   * @class
	   * @private
	   *
	   * @param {geo.util.ClusterGroup} group The source cluster group
	   * @param {number} zoom The zoom level of the current node
	   * @param {object[]} children An array of ClusterTrees or point objects
	   */
	  function ClusterTree(group, zoom, children) {
	    this._group = group;
	    this._zoom = zoom;
	    this._points = [];     // Unclustered points
	    this._clusters = [];   // Child clusters
	    this._count = 0;       // Total number of points
	    this._parent = null;
	    this._coord = null;    // The cached coordinates
	    var that = this;

	    // add the children provided in the constructor call
	    (children || []).forEach(function (c) {
	      that._add(c);
	    });
	  }

	  /**
	   * Add a point or cluster as a child to the current cluster.
	   * @param {object} pt A ClusterTree or point object
	   * @private
	   */
	  ClusterTree.prototype._add = function (pt) {
	    var inc = 1;

	    if (pt instanceof ClusterTree) {
	      // add a child cluster
	      this._clusters.push(pt);
	      inc = pt._count;
	    } else {
	      this._points.push(pt);
	    }
	    pt._parent = this;

	    // increment the counter
	    this._increment(inc);
	  };

	  /**
	   * Increment the child counter for this and the parent.
	   * @param {number} inc The value to increment by
	   * @private
	   */
	  ClusterTree.prototype._increment = function (inc) {
	    this._coord = null;
	    this._count += inc;
	    if (this._parent) {
	      this._parent._increment(inc);
	    }
	  };

	  /**
	   * Return the total number of child points contained in the cluster.
	   * @returns {number} Total points contained
	   */
	  ClusterTree.prototype.count = function () {
	    return this._count;
	  };

	  /**
	   * Recursively call a function on all points contained in the cluster.
	   * Calls the function with `this` as the current ClusterTree object, and
	   * arguments to arguments the point object and the zoom level:
	   *   func.call(this, point, zoom)
	   */
	  ClusterTree.prototype.each = function (func) {
	    var i;
	    for (i = 0; i < this._points.length; i += 1) {
	      func.call(this, this._points[i], this._zoom);
	    }
	    for (i = 0; i < this._clusters.length; i += 1) {
	      this._clusters[i].each.call(
	        this._clusters[i],
	        func
	      );
	    }
	  };

	  /**
	   * Get the coordinates of the cluster (the mean position of all the points
	   * contained).  This is lazily calculated and cached.
	   */
	  ClusterTree.prototype.coords = function () {
	    var i, center = {x: 0, y: 0};
	    if (this._coord) {
	      return this._coord;
	    }
	    // first add up the points at the node
	    for (i = 0; i < this._points.length; i += 1) {
	      center.x += this._points[i].x;
	      center.y += this._points[i].y;
	    }

	    // add up the contribution from the clusters
	    for (i = 0; i < this._clusters.length; i += 1) {
	      center.x += this._clusters[i].coords().x * this._clusters[i].count();
	      center.y += this._clusters[i].coords().y * this._clusters[i].count();
	    }

	    return {
	      x: center.x / this.count(),
	      y: center.y / this.count()
	    };
	  };

	  /**
	   * This class manages clustering of an array of positions hierarchically.
	   * The algorithm and code was adapted from the Leaflet marker cluster
	   * plugin by David Leaver: https://github.com/Leaflet/Leaflet.markercluster
	   *
	   * @class geo.util.ClusterGroup
	   * @param {object} opts An options object
	   * @param {number} width The width of the window; used for scaling.
	   * @param {number} height The height of the window; used for scaling.
	   * @param {number} maxZoom The maximimum zoom level to calculate
	   * @param {number} radius Proportional to the clustering radius in pixels
	   */
	  function C(opts, width, height) {

	    var DistanceGrid = __webpack_require__(199);

	    // store the options
	    this._opts = $.extend({
	      maxZoom: 18,
	      radius: 0.05
	    }, opts);
	    this._opts.width = this._opts.width || width || 256;
	    this._opts.height = this._opts.height || height || 256;

	    // generate the initial datastructures
	    this._clusters = {}; // clusters at each zoom level
	    this._points = {};   // unclustered points at each zoom level

	    var zoom, scl;
	    for (zoom = this._opts.maxZoom; zoom >= 0; zoom -= 1) {
	      scl = this._scaleAtLevel(zoom, this._opts.width, this._opts.height);
	      this._clusters[zoom] = new DistanceGrid(scl);
	      this._points[zoom] = new DistanceGrid(scl);
	    }
	    this._topClusterLevel = new ClusterTree(this, -1);
	  }

	  /**
	   * Returns a characteristic distance scale at a particular zoom level.  This
	   * scale is used to control the clustering radius.  When the renderer supports
	   * it, this call should be replaced by a calculation involving the view port
	   * size in point coordinates at a particular zoom level.
	   * @private
	   */
	  C.prototype._scaleAtLevel = function (zoom, width, height) {
	    return vgl.zoomToHeight(zoom, width, height) / 2 * this._opts.radius;
	  };

	  /**
	   * Add a position to the cluster group.
	   * @protected
	   */
	  C.prototype.addPoint = function (point) {
	    var zoom, closest, parent, newCluster, lastParent, z;

	    // start at the maximum zoom level and search for nearby
	    //
	    // 1.  existing clusters
	    // 2.  unclustered points
	    //
	    // otherwise add the point as a new unclustered point

	    for (zoom = this._opts.maxZoom; zoom >= 0; zoom -= 1) {

	      // find near cluster
	      closest = this._clusters[zoom].getNearObject(point);
	      if (closest) {
	        // add the point to the cluster and return
	        closest._add(point);
	        return;
	      }

	      // find near point
	      closest = this._points[zoom].getNearObject(point);
	      if (closest) {
	        parent = closest._parent;
	        if (parent) {
	          // remove the point from the parent
	          for (z = parent._points.length - 1; z >= 0; z -= 1) {
	            if (parent._points[z] === closest) {
	              parent._points.splice(z, 1);
	              parent._increment(-1);
	              break;
	            }
	          }
	        }

	        if (!parent) {
	          $.noop();
	        }
	        // create a new cluster with these two points
	        newCluster = new ClusterTree(this, zoom, [closest, point]);
	        this._clusters[zoom].addObject(newCluster, newCluster.coords());

	        // create intermediate parent clusters that don't exist
	        lastParent = newCluster;
	        for (z = zoom - 1; z > parent._zoom; z -= 1) {
	          lastParent = new ClusterTree(this, z, [lastParent]);
	          this._clusters[z].addObject(lastParent, lastParent.coords());
	        }
	        parent._add(lastParent);

	        // remove closest from this zoom level and any above (replace with newCluster)
	        for (z = zoom; z >= 0; z -= 1) {
	          if (!this._points[z].removeObject(closest, closest)) {
	            break;
	          }
	        }

	        return;
	      }

	      // add an unclustered point
	      this._points[zoom].addObject(point, point);
	    }

	    // otherwise add to the top
	    this._topClusterLevel._add(point);
	  };

	  /**
	   * Return the unclustered points contained at a given zoom level.
	   * @param {number} zoom The zoom level
	   * @return {object[]} The array of unclustered points
	   */
	  C.prototype.points = function (zoom) {
	    zoom = Math.min(Math.max(Math.floor(zoom), 0), this._opts.maxZoom - 1);
	    return this._points[Math.floor(zoom)].contents();
	  };

	  /**
	   * Return the clusters contained at a given zoom level.
	   * @param {number} zoom The zoom level
	   * @return {ClusterTree[]} The array of clusters
	   */
	  C.prototype.clusters = function (zoom) {
	    zoom = Math.min(Math.max(Math.floor(zoom), 0), this._opts.maxZoom - 1);
	    return this._clusters[Math.floor(zoom)].contents();
	  };

	  module.exports = C;
	})();


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var sceneObject = __webpack_require__(79);
	var feature = __webpack_require__(78);
	var checkRenderer = __webpack_require__(76).checkRenderer;
	var rendererForFeatures = __webpack_require__(76).rendererForFeatures;
	var rendererForAnnotations = __webpack_require__(76).rendererForAnnotations;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @class geo.layer
	 * @extends geo.sceneObject
	 * @param {Object?} arg An options argument
	 * @param {string} arg.attribution An attribution string to display
	 * @param {number} arg.zIndex The z-index to assign to the layer (defaults
	 *   to the index of the layer inside the map)
	 * @returns {geo.layer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var layer = function (arg) {
	  'use strict';

	  if (!(this instanceof layer)) {
	    return new layer(arg);
	  }
	  arg = arg || {};
	  sceneObject.call(this, arg);

	  var $ = __webpack_require__(1);
	  var timestamp = __webpack_require__(195);
	  var createRenderer = __webpack_require__(76).createRenderer;
	  var newLayerId = __webpack_require__(196).newLayerId;
	  var geo_event = __webpack_require__(5);
	  var camera = __webpack_require__(202);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_exit = this._exit,
	      m_id = arg.id === undefined ? layer.newLayerId() : arg.id,
	      m_name = '',
	      m_map = arg.map === undefined ? null : arg.map,
	      m_node = null,
	      m_canvas = null,
	      m_renderer = null,
	      m_initialized = false,
	      m_rendererName = arg.renderer !== undefined ? arg.renderer : (
	        arg.annotations ? rendererForAnnotations(arg.annotations) :
	        rendererForFeatures(arg.features)),
	      m_dataTime = timestamp(),
	      m_updateTime = timestamp(),
	      m_sticky = arg.sticky === undefined ? true : arg.sticky,
	      m_active = arg.active === undefined ? true : arg.active,
	      m_opacity = arg.opacity === undefined ? 1 : arg.opacity,
	      m_attribution = arg.attribution || null,
	      m_zIndex;

	  m_rendererName = checkRenderer(m_rendererName);

	  if (!m_map) {
	    throw new Error('Layers must be initialized on a map.');
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the name of the renderer.
	   *
	   * @returns {string}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.rendererName = function () {
	    return m_rendererName;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the z-index of the layer.  The z-index controls the display
	   * order of the layers in much the same way as the CSS z-index property.
	   *
	   * @param {number} [zIndex] The new z-index
	   * @returns {number|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.zIndex = function (zIndex) {
	    if (zIndex === undefined) {
	      return m_zIndex;
	    }
	    m_zIndex = zIndex;
	    m_node.css('z-index', m_zIndex);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bring the layer above the given number of layers.  This will rotate the
	   * current z-indices for this and the next `n` layers.
	   *
	   * @param {number} [n=1] The number of positions to move
	   * @returns {this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.moveUp = function (n) {
	    var order, i, me = null, tmp, sign;

	    // set the default
	    if (n === undefined) {
	      n = 1;
	    }

	    // set the sort direction that controls if we are moving up
	    // or down the z-index
	    sign = 1;
	    if (n < 0) {
	      sign = -1;
	      n = -n;
	    }

	    // get a sorted list of layers
	    order = m_this.map().layers().sort(
	      function (a, b) { return sign * (a.zIndex() - b.zIndex()); }
	    );

	    for (i = 0; i < order.length; i += 1) {
	      if (me === null) {
	        // loop until we get to the current layer
	        if (order[i] === m_this) {
	          me = i;
	        }
	      } else if (i - me <= n) {
	        // swap the next n layers
	        tmp = m_this.zIndex();
	        m_this.zIndex(order[i].zIndex());
	        order[i].zIndex(tmp);
	      } else {
	        // all the swaps are done now
	        break;
	      }
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bring the layer below the given number of layers.  This will rotate the
	   * current z-indices for this and the previous `n` layers.
	   *
	   * @param {number} [n=1] The number of positions to move
	   * @returns {this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.moveDown = function (n) {
	    if (n === undefined) {
	      n = 1;
	    }
	    return m_this.moveUp(-n);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bring the layer to the top of the map layers.
	   *
	   * @returns {this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.moveToTop = function () {
	    return m_this.moveUp(m_this.map().children().length - 1);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Bring the layer to the bottom of the map layers.
	   *
	   * @returns {this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.moveToBottom = function () {
	    return m_this.moveDown(m_this.map().children().length - 1);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get whether or not the layer is sticky (navigates with the map).
	   *
	   * @returns {Boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.sticky = function () {
	    return m_sticky;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get whether or not the layer is active.  An active layer will receive
	   * native mouse when the layer is on top.  Non-active layers will never
	   * receive native mouse events.
	   *
	   * @returns {Boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.active = function () {
	    return m_active;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set root node of the layer
	   *
	   * @returns {div}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.node = function () {
	    return m_node;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set id of the layer
	   *
	   * @returns {String}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.id = function (val) {
	    if (val === undefined) {
	      return m_id;
	    }
	    m_id = newLayerId();
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set name of the layer
	   *
	   * @returns {String}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.name = function (val) {
	    if (val === undefined) {
	      return m_name;
	    }
	    m_name = val;
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set map of the layer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.map = function () {
	    return m_map;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get renderer for the layer if any
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.renderer = function () {
	    return m_renderer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get canvas of the layer
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.canvas = function () {
	    return m_canvas;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return last time data got changed
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.dataTime = function () {
	    return m_dataTime;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the modified time for the last update that did something
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateTime = function () {
	    return m_updateTime;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set if the layer has been initialized
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.initialized = function (val) {
	    if (val !== undefined) {
	      m_initialized = val;
	      return m_this;
	    }
	    return m_initialized;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Transform coordinates from world coordinates into a local coordinate
	   * system specific to the underlying renderer.  This method is exposed
	   * to allow direct access the rendering context, but otherwise should
	   * not be called directly.  The default implementation is the identity
	   * operator.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.toLocal = function (input) {
	    if (m_this._toLocalMatrix) {
	      camera.applyTransform(m_this._toLocalMatrix, input);
	    }
	    return input;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Transform coordinates from a local coordinate system to world coordinates.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.fromLocal = function (input) {
	    if (m_this._fromLocalMatrix) {
	      camera.applyTransform(m_this._fromLocalMatrix, input);
	    }
	    return input;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the attribution html content that will displayed with the
	   * layer.  By default, nothing will be displayed.  Note, this content
	   * is **not** html escaped, so care should be taken when renderering
	   * user provided content.
	   * @param {string?} arg An html fragment
	   * @returns {string|this} Chainable as a setter
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.attribution = function (arg) {
	    if (arg !== undefined) {
	      m_attribution = arg;
	      m_this.map().updateAttribution();
	      return m_this;
	    }
	    return m_attribution;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Init layer
	   *
	   * @param {boolean} noEvents if a subclass of this intends to bind the
	   *    resize, pan, and zoom events itself, set this flag to true to avoid
	   *    binding them here.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (noEvents) {
	    if (m_initialized) {
	      return m_this;
	    }

	    m_map.node().append(m_node);

	    /* Pass along the arguments, but not the map reference */
	    var options = $.extend({}, arg);
	    delete options.map;

	    if (m_rendererName === null) {
	      // if given a "null" renderer, then pass the map element as the
	      // canvas
	      m_renderer = null;
	      m_canvas = m_node;
	    } else if (m_canvas) { // Share context if have valid one
	      m_renderer = createRenderer(m_rendererName, m_this, m_canvas,
	                                      options);
	    } else {
	      m_renderer = createRenderer(m_rendererName, m_this, undefined,
	                                      options);
	      m_canvas = m_renderer.canvas();
	    }

	    if (!m_this.active()) {
	      m_node.css('pointerEvents', 'none');
	    }

	    m_initialized = true;

	    if (!noEvents) {
	      /// Bind events to handlers
	      m_this.geoOn(geo_event.resize, function (event) {
	        m_this._update({event: event});
	      });

	      m_this.geoOn(geo_event.pan, function (event) {
	        m_this._update({event: event});
	      });

	      m_this.geoOn(geo_event.rotate, function (event) {
	        m_this._update({event: event});
	      });

	      m_this.geoOn(geo_event.zoom, function (event) {
	        m_this._update({event: event});
	      });
	    }

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Clean up resouces
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.geoOff();
	    if (m_renderer) {
	      m_renderer._exit();
	    }
	    m_node.off();
	    m_node.remove();
	    arg = {};
	    m_canvas = null;
	    m_renderer = null;
	    s_exit();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update layer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the width of the layer in pixels.
	   * **DEPRECIATED: use map.size instead.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.width = function () {
	    return m_this.map().size().width;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the height of the layer in pixels
	   * **DEPRECIATED: use map.size instead.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.height = function () {
	    return m_this.map().size().height;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the current layer opacity.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.opacity = function (opac) {
	    if (opac !== undefined) {
	      m_opacity = opac;
	      m_node.css('opacity', m_opacity);
	      return m_this;
	    }
	    return m_opacity;
	  };

	  if (arg.zIndex === undefined) {
	    arg.zIndex = m_map.children().length;
	  }
	  m_zIndex = arg.zIndex;

	  // Create top level div for the layer
	  m_node = $(document.createElement('div'));
	  m_node.attr('id', m_name);
	  m_node.css('position', 'absolute');
	  m_node.css('width', '100%');
	  m_node.css('height', '100%');
	  m_this.opacity(m_opacity);

	  // set the z-index
	  m_this.zIndex(m_zIndex);

	  return m_this;
	};

	/**
	 * Gets a new id number for a layer.
	 * @protected
	 * @instance
	 * @returns {number}
	 */
	layer.newLayerId = (function () {
	  'use strict';
	  var currentId = 1;
	  return function () {
	    var id = currentId;
	    currentId += 1;
	    return id;
	  };
	}());

	/**
	 * General object specification for feature types.
	 * @typedef geo.layer.spec
	 * @type {object}
	 * @property {string} [type='feature'] For feature compatibility
	 * with more than one kind of creatable layer
	 * @property {object[]} [data=[]] The default data array to
	 * apply to each feature if none exists
	 * @property {string} [renderer='vgl'] The renderer to use
	 * @property {geo.feature.spec[]} [features=[]] Features
	 * to add to the layer
	 */

	/**
	 * Create a layer from an object.  Any errors in the creation
	 * of the layer will result in returning null.
	 * @param {geo.map} map The map to add the layer to
	 * @param {geo.layer.spec} spec The object specification
	 * @returns {geo.layer|null}
	 */
	layer.create = function (map, spec) {
	  'use strict';

	  spec = spec || {};

	  // add osmLayer later
	  spec.type = 'feature';
	  if (spec.type !== 'feature') {
	    console.warn('Unsupported layer type');
	    return null;
	  }

	  spec.renderer = spec.renderer || 'vgl';
	  spec.renderer = checkRenderer(spec.renderer);

	  if (!spec.renderer) {
	    console.warn('Invalid renderer');
	    return null;
	  }

	  var layer = map.createLayer(spec.type, spec);
	  if (!layer) {
	    console.warn('Unable to create a layer');
	    return null;
	  }

	  // probably move this down to featureLayer eventually
	  spec.features.forEach(function (f) {
	    f.data = f.data || spec.data;
	    f.feature = feature.create(layer, f);
	  });

	  return layer;
	};

	inherit(layer, sceneObject);
	module.exports = layer;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	(function () {
	  'use strict';

	  var inherit = __webpack_require__(4);
	  var object = __webpack_require__(80);
	  var util = __webpack_require__(196);
	  var mat4 = __webpack_require__(83);
	  var vec4 = __webpack_require__(107);

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * This class defines the raw interface for a camera.  At a low level, the
	   * camera provides a methods for converting between a map's coordinate system
	   * to display pixel coordinates.
	   *
	   * For the moment, all camera transforms are assumed to be expressible as
	   * 4x4 matrices.  More general cameras may follow that break this assumption.
	   *
	   * The interface for the camera is relatively stable for "map-like" views,
	   * e.g. when the camera is pointing in the direction [0, 0, -1], and placed
	   * above the z=0 plane.  More general view changes and events have not yet
	   * been defined.
	   *
	   * The camera emits the following events when the view changes:
	   *
	   *   * {@link geo.event.camera.pan} when the camera is translated in the
	   *       x/y plane
	   *   * {@link geo.event.camera.zoom} when the camera is changed in a way
	   *       that modifies the current zoom level
	   *   * {@link geo.event.camera.view} when the visible bounds change for
	   *       any reason
	   *   * {@link geo.event.camera.projection} when the projection type changes
	   *   * {@link geo.event.camera.viewport} when the viewport changes
	   *
	   * By convention, protected methods do not update the internal matrix state,
	   * public methods do.  There are a few primary methods that are intended to
	   * be used by external classes to mutate the internal state:
	   *
	   *   * bounds: Set the visible bounds (for initialization and zooming)
	   *   * pan: Translate the camera in x/y by an offset (for panning)
	   *   * viewFromCenterSizeRotation: set the camera view based on a center
	   *        point, boundary size, and rotation angle.
	   *
	   * @class geo.camera
	   * @extends geo.object
	   * @param {object?} spec Options argument
	   * @param {string} spec.projection One of the supported geo.camera.projection
	   * @param {object} spec.viewport The initial camera viewport
	   * @param {object} spec.viewport.width
	   * @param {object} spec.viewport.height
	   * @returns {geo.camera}
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var camera = function (spec) {
	    if (!(this instanceof camera)) {
	      return new camera(spec);
	    }

	    var geo_event = __webpack_require__(5);

	    spec = spec || {};
	    object.call(this, spec);

	    /**
	     * The view matrix
	     * @protected
	     */
	    this._view = util.mat4AsArray();

	    /**
	     * The projection matrix
	     * @protected
	     */
	    this._proj = util.mat4AsArray();

	    /**
	     * The projection type (one of `this.constructor.projection`)
	     * @protected
	     */
	    this._projection = null;

	    /**
	     * The transform matrix (view * proj)
	     * @protected
	     */
	    this._transform = util.mat4AsArray();

	    /**
	     * The inverse transform matrix (view * proj)^-1
	     * @protected
	     */
	    this._inverse = util.mat4AsArray();

	    /**
	     * Cached bounds object recomputed on demand.
	     * @protected
	     */
	    this._bounds = null;

	    /**
	     * Cached "display" matrix recomputed on demand.
	     * @see {@link geo.camera.display}
	     * @protected
	     */
	    this._display = null;

	    /**
	     * Cached "world" matrix recomputed on demand.
	     * @see {@link geo.camera.world}
	     * @protected
	     */
	    this._world = null;

	    /**
	     * The viewport parameters size and offset.
	     * @property {number} height Viewport height in pixels
	     * @property {number} width Viewport width in pixels
	     * @protected
	     */
	    this._viewport = {width: 1, height: 1};

	    /**
	     * Set up the projection matrix for the current projection type.
	     * @protected
	     */
	    this._createProj = function () {
	      var s = this.constructor.bounds.near / this.constructor.bounds.far;

	      // call mat4.frustum or mat4.ortho here
	      if (this._projection === 'perspective') {
	        mat4.frustum(
	          this._proj,
	          this.constructor.bounds.left * s,
	          this.constructor.bounds.right * s,
	          this.constructor.bounds.bottom * s,
	          this.constructor.bounds.top * s,
	          -this.constructor.bounds.near,
	          -this.constructor.bounds.far
	        );
	      } else if (this._projection === 'parallel') {
	        mat4.ortho(
	          this._proj,
	          this.constructor.bounds.left,
	          this.constructor.bounds.right,
	          this.constructor.bounds.bottom,
	          this.constructor.bounds.top,
	          this.constructor.bounds.near,
	          this.constructor.bounds.far
	        );
	      }
	    };

	    /**
	     * Update the internal state of the camera on change to camera
	     * parameters.
	     * @protected
	     */
	    this._update = function () {
	      this._bounds = null;
	      this._display = null;
	      this._world = null;
	      this._transform = camera.combine(this._proj, this._view);
	      mat4.invert(this._inverse, this._transform);
	      this.geoTrigger(geo_event.camera.view, {
	        camera: this
	      });
	    };

	    /**
	     * Getter/setter for the view matrix.
	     * @note copies the matrix value on set.
	     */
	    Object.defineProperty(this, 'view', {
	      get: function () {
	        return this._view;
	      },
	      set: function (view) {
	        mat4.copy(this._view, view);
	        this._update();
	      }
	    });

	    /**
	     * Getter/setter for the view bounds.
	     *
	     * If not provided, near and far bounds will be set to [-1, 1] by
	     * default.  We will probably want to change this to a unit specific
	     * value initialized by the map when drawing true 3D objects or
	     * tilting the camera.
	     *
	     * Returned near/far bounds are also -1, 1 for the moment.
	     */
	    Object.defineProperty(this, 'bounds', {
	      get: function () {
	        if (this._bounds === null) {
	          this._bounds = this._getBounds();
	        }
	        return this._bounds;
	      },
	      set: function (bounds) {
	        this._setBounds(bounds);
	        this._update();
	      }
	    });

	    /**
	     * Getter for the "display" matrix.  This matrix converts from
	     * world coordinates into display coordinates.  This matrix exists to
	     * generate matrix3d css transforms that can be used in layers that
	     * render on the DOM.
	     */
	    Object.defineProperty(this, 'display', {
	      get: function () {
	        var mat;
	        if (this._display === null) {
	          mat = camera.affine(
	            {x: 1, y: 1}, // translate to: [0, 2] x [0, 2]
	            {
	              x: this.viewport.width / 2,
	              y: this.viewport.height / -2
	            }             // scale to: [0, width] x [-height, 0]
	          );

	          // applies mat to the transform (world -> normalized)
	          this._display = camera.combine(
	            mat,
	            this._transform
	          );
	        }
	        return this._display;
	      }
	    });

	    /**
	     * Getter for the "world" matrix.  This matrix converts from
	     * display coordinates into world coordinates.  This is constructed
	     * by inverting the "display" matrix.
	     */
	    Object.defineProperty(this, 'world', {
	      get: function () {
	        if (this._world === null) {
	          this._world = mat4.invert(
	            util.mat4AsArray(),
	            this.display
	          );
	        }
	        return this._world;
	      }
	    });

	    /**
	     * Getter/setter for the projection type.
	     */
	    Object.defineProperty(this, 'projection', {
	      get: function () {
	        return this._projection;
	      },
	      set: function (type) {
	        if (!this.constructor.projection[type]) {
	          throw new Error('Unsupported projection type: ' + type);
	        }
	        if (type !== this._projection) {
	          this._projection = type;
	          this._createProj();
	          this._update();
	          this.geoTrigger(geo_event.camera.projection, {
	            camera: this,
	            projection: type
	          });
	        }
	      }
	    });

	    /**
	     * Getter for the projection matrix (when applicable).
	     * This generally shouldn't be modified directly because
	     * the rest of the code assumes that the clipping bounds
	     * are [-1, -1, -1] to [1, 1, 1] in camera coordinates.
	     */
	    Object.defineProperty(this, 'projectionMatrix', {
	      get: function () {
	        return this._proj;
	      }
	    });

	    /**
	     * Getter for the transform matrix.
	     */
	    Object.defineProperty(this, 'transform', {
	      get: function () {
	        return this._transform;
	      }
	    });

	    /**
	     * Getter for the inverse transform matrix.
	     */
	    Object.defineProperty(this, 'inverse', {
	      get: function () {
	        return this._inverse;
	      }
	    });

	    /**
	     * Getter/setter for the viewport.
	     */
	    Object.defineProperty(this, 'viewport', {
	      get: function () {
	        return {width: this._viewport.width, height: this._viewport.height};
	      },
	      set: function (viewport) {
	        if (!(viewport.width > 0 &&
	              viewport.height > 0)) {
	          throw new Error('Invalid viewport dimensions');
	        }
	        if (viewport.width === this._viewport.width &&
	            viewport.height === this._viewport.height) {
	          return;
	        }

	        // apply scaling to the view matrix to account for the new aspect ratio
	        // without changing the apparent zoom level
	        if (this._viewport.width && this._viewport.height) {
	          this._scale([
	            this._viewport.width / viewport.width,
	            this._viewport.height / viewport.height,
	            1
	          ]);

	          // translate by half the difference to keep the center the same
	          this._translate([
	            (viewport.width - this._viewport.width) / 2,
	            (viewport.height - this._viewport.height) / 2,
	            0
	          ]);
	        }

	        this._viewport = {width: viewport.width, height: viewport.height};
	        this._update();
	        this.geoTrigger(geo_event.camera.viewport, {
	          camera: this,
	          viewport: this.viewport
	        });
	      }
	    });

	    /**
	     * Reset the view matrix to its initial (identity) state.
	     * @protected
	     * @returns {this} Chainable
	     */
	    this._resetView = function () {
	      mat4.identity(this._view);
	      return this;
	    };

	    /**
	     * Uses `mat4.translate` to translate the camera by the given vector amount.
	     * @protected
	     * @param {vec3|Array} offset The camera translation vector
	     * @returns {this} Chainable
	     */
	    this._translate = function (offset) {
	      mat4.translate(this._view, this._view, offset);
	    };

	    /**
	     * Uses `mat4.scale` to scale the camera by the given vector amount.
	     * @protected
	     * @param {vec3|Array} scale The scaling vector
	     * @returns {this} Chainable
	     */
	    this._scale = function (scale) {
	      mat4.scale(this._view, this._view, scale);
	    };

	    /**
	     * Project a vec4 from world space into clipped space [-1, 1] in place
	     * @protected
	     * @param {vec4} point The point in world coordinates (mutated)
	     * @returns {vec4} The point in clip space coordinates
	     */
	    this._worldToClip4 = function (point) {
	      return camera.applyTransform(this._transform, point);
	    };

	    /**
	     * Project a vec4 from clipped space into world space in place
	     * @protected
	     * @param {vec4} point The point in clipped coordinates (mutated)
	     * @returns {vec4} The point in world space coordinates
	     */
	    this._clipToWorld4 = function (point) {
	      return camera.applyTransform(this._inverse, point);
	    };

	    /**
	     * Apply the camera's projection transform to the given point.
	     * @param {vec4} pt a point in clipped coordinates
	     * @returns {vec4} the point in normalized coordinates
	     */
	    this.applyProjection = function (pt) {
	      var w;
	      if (this._projection === 'perspective') {
	        w = 1 / (pt[3] || 1);
	        pt[0] = w * pt[0];
	        pt[1] = w * pt[1];
	        pt[2] = w * pt[2];
	        pt[3] = w;
	      } else {
	        pt[3] = 1;
	      }
	      return pt;
	    };

	    /**
	     * Unapply the camera's projection transform from the given point.
	     * @param {vec4} pt a point in normalized coordinates
	     * @returns {vec4} the point in clipped coordinates
	     */
	    this.unapplyProjection = function (pt) {
	      var w;
	      if (this._projection === 'perspective') {
	        w = pt[3] || 1;
	        pt[0] = w * pt[0];
	        pt[1] = w * pt[1];
	        pt[2] = w * pt[2];
	        pt[3] = w;
	      } else {
	        pt[3] = 1;
	      }
	      return pt;
	    };

	    /**
	     * Project a vec4 from world space into viewport space.
	     * @param {vec4} point The point in world coordinates (mutated)
	     * @returns {vec4} The point in display coordinates
	     *
	     * @note For the moment, this computation assumes the following:
	     *   * point[3] > 0
	     *   * depth range [0, 1]
	     *
	     * The clip space z and w coordinates are returned with the window
	     * x/y coordinates.
	     */
	    this.worldToDisplay4 = function (point) {
	      // This is because z = 0 is the far plane exposed to the user, but
	      // internally the far plane is at -2.
	      point[2] -= 2;

	      // convert to clip space
	      this._worldToClip4(point);

	      // apply projection specific transformation
	      point = this.applyProjection(point);

	      // convert to display space
	      point[0] = this._viewport.width * (1 + point[0]) / 2.0;
	      point[1] = this._viewport.height * (1 - point[1]) / 2.0;
	      point[2] = (1 + point[2]) / 2.0;
	      return point;
	    };

	    /**
	     * Project a vec4 from display space into world space in place.
	     * @param {vec4} point The point in display coordinates (mutated)
	     * @returns {vec4} The point in world space coordinates
	     *
	     * @note For the moment, this computation assumes the following:
	     *   * point[3] > 0
	     *   * depth range [0, 1]
	     */
	    this.displayToWorld4 = function (point) {
	      // convert to clip space
	      point[0] = 2 * point[0] / this._viewport.width - 1;
	      point[1] = -2 * point[1] / this._viewport.height + 1;
	      point[2] = 2 * point[2] - 1;

	      // invert projection transform
	      point = this.unapplyProjection(point);

	      // convert to world coordinates
	      this._clipToWorld4(point);

	      // move far surface to z = 0
	      point[2] += 2;
	      return point;
	    };

	    /**
	     * Project a point object from world space into viewport space.
	     * @param {object} point The point in world coordinates
	     * @param {number} point.x
	     * @param {number} point.y
	     * @returns {object} The point in display coordinates
	     */
	    this.worldToDisplay = function (point) {
	      // define some magic numbers:
	      var z = 0, // z coordinate of the surface in world coordinates
	          w = 1; // enables perspective divide (i.e. for point conversion)
	      point = this.worldToDisplay4(
	        [point.x, point.y, z, w]
	      );
	      return {x: point[0], y: point[1], z: point[2]};
	    };

	    /**
	     * Project a point object from viewport space into world space.
	     * @param {object} point The point in display coordinates
	     * @param {number} point.x
	     * @param {number} point.y
	     * @returns {object} The point in world coordinates
	     */
	    this.displayToWorld = function (point) {
	      // define some magic numbers:
	      var z = 1, // the z coordinate of the surface
	          w = 2; // perspective divide at z = 1
	      point = this.displayToWorld4(
	        [point.x, point.y, z, w]
	      );
	      return {x: point[0], y: point[1]};
	    };

	    /**
	     * Calculate the current bounds in world coordinates from the
	     * current view matrix.  This computes a matrix vector multiplication
	     * so the result is cached for public facing methods.
	     *
	     * @protected
	     * @returns {object} bounds object
	     */
	    this._getBounds = function () {
	      var ul, ur, ll, lr, bds = {};

	      // get corners
	      ul = this.displayToWorld({x: 0, y: 0});
	      ur = this.displayToWorld({x: this._viewport.width, y: 0});
	      ll = this.displayToWorld({x: 0, y: this._viewport.height});
	      lr = this.displayToWorld({
	        x: this._viewport.width,
	        y: this._viewport.height
	      });

	      bds.left = Math.min(ul.x, ur.x, ll.x, lr.x);
	      bds.bottom = Math.min(ul.y, ur.y, ll.y, lr.y);
	      bds.right = Math.max(ul.x, ur.x, ll.x, lr.x);
	      bds.top = Math.max(ul.y, ur.y, ll.y, lr.y);

	      return bds;
	    };

	    /**
	     * Sets the view matrix so that the given world bounds
	     * are in view.  To account for the viewport aspect ratio,
	     * the resulting bounds may be larger in width or height than
	     * the requested bound, but should be centered in the frame.
	     *
	     * @protected
	     * @param {object} bounds
	     * @param {number} bounds.left
	     * @param {number} bounds.right
	     * @param {number} bounds.bottom
	     * @param {number} bounds.top
	     * @param {number?} bounds.near Currently ignored
	     * @param {number?} bounds.far Currently ignored
	     * @return {this} Chainable
	     */
	    this._setBounds = function (bounds) {
	      var size = {
	        width: bounds.right - bounds.left,
	        height: bounds.top - bounds.bottom
	      };
	      var center = {
	        x: (bounds.left + bounds.right) / 2,
	        y: (bounds.bottom + bounds.top) / 2
	      };

	      this._viewFromCenterSizeRotation(center, size, 0);
	      return this;
	    };

	    /**
	     * Sets the view matrix so that the given world center is centered, at
	     * least a certain width and height are visible, and a rotation is applied.
	     * The resulting bounds may be larger in width or height than the values if
	     * the viewport is a different aspect ratio.
	     *
	     * @protected
	     * @param {object} center
	     * @param {number} center.x
	     * @param {number} center.y
	     * @param {object} size
	     * @param {number} size.width
	     * @param {number} size.height
	     * @param {number} rotation in clockwise radians.  Optional
	     * @return {this} Chainable
	     */
	    this._viewFromCenterSizeRotation = function (center, size, rotation) {
	      var translate = util.vec3AsArray(),
	          scale = util.vec3AsArray(),
	          c_ar, v_ar, w, h;

	      // reset view to the identity
	      this._resetView();

	      w = Math.abs(size.width);
	      h = Math.abs(size.height);
	      c_ar = w / h;
	      v_ar = this._viewport.width / this._viewport.height;

	      if (c_ar >= v_ar) {
	        // grow camera bounds vertically
	        h = w / v_ar;
	        scale[0] = 2 / w;
	        scale[1] = 2 / h;
	      } else {
	        // grow bounds horizontally
	        w = h * v_ar;
	        scale[0] = 2 / w;
	        scale[1] = 2 / h;
	      }

	      scale[2] = 1;
	      this._scale(scale);

	      if (rotation) {
	        this._rotate(rotation);
	      }

	      // translate to the new center.
	      translate[0] = -center.x;
	      translate[1] = -center.y;
	      translate[2] = 0;

	      this._translate(translate);

	      return this;
	    };

	    /**
	     * Public exposure of the viewFromCenterSizeRotation function.
	     */
	    this.viewFromCenterSizeRotation = function (center, size, rotation) {
	      this._viewFromCenterSizeRotation(center, size, rotation);
	      this._update();
	      return this;
	    };

	    /**
	     * Pans the view matrix by the given amount.
	     *
	     * @param {object} offset The delta in world space coordinates.
	     * @param {number} offset.x
	     * @param {number} offset.y
	     * @param {number} [offset.z=0]
	     */
	    this.pan = function (offset) {
	      if (!offset.x && !offset.y && !offset.z) {
	        return;
	      }
	      this._translate([
	        offset.x,
	        offset.y,
	        offset.z || 0
	      ]);
	      this._update();
	    };

	    /**
	     * Zooms the view matrix by the given amount.
	     *
	     * @param {number} zoom The zoom scale to apply
	     */
	    this.zoom = function (zoom) {
	      if (zoom === 1) {
	        return;
	      }
	      mat4.scale(this._view, this._view, [
	        zoom,
	        zoom,
	        zoom
	      ]);
	      this._update();
	    };

	    /**
	     * Rotate the view matrix by the given amount.
	     *
	     * @param {number} rotation Counter-clockwise rotation angle in radians.
	     * @param {object} center Center of rotation in world space coordinates.
	     * @param {vec3} axis acis of rotation.  Defaults to [0, 0, -1]
	     */
	    this._rotate = function (rotation, center, axis) {
	      if (!rotation) {
	        return;
	      }
	      axis = axis || [0, 0, -1];
	      if (!center) {
	        center = [0, 0, 0];
	      } else if (center.x !== undefined) {
	        center = [center.x || 0, center.y || 0, center.z || 0];
	      }
	      var invcenter = [-center[0], -center[1], -center[2]];
	      mat4.translate(this._view, this._view, center);
	      mat4.rotate(this._view, this._view, rotation, axis);
	      mat4.translate(this._view, this._view, invcenter);
	    };

	    /**
	     * Returns a CSS transform that converts (by default) from world coordinates
	     * into display coordinates.  This allows users of this module to
	     * position elements using world coordinates directly inside DOM
	     * elements.
	     *
	     * @note This transform will not take into account projection specific
	     * transforms.  For perspective projections, one can use the properties
	     * `perspective` and `perspective-origin` to apply the projection
	     * in css directly.
	     *
	     * @param {string} transform The transform to return
	     *   * display
	     *   * world
	     * @returns {string} The css transform string
	     */
	    this.css = function (transform) {
	      var m;
	      switch ((transform || '').toLowerCase()) {
	        case 'display':
	        case '':
	          m = this.display;
	          break;
	        case 'world':
	          m = this.world;
	          break;
	        default:
	          throw new Error('Unknown transform ' + transform);
	      }
	      return camera.css(m);
	    };

	    /**
	     * Represent a glmatrix as a pretty-printed string.
	     * @param {mat4} mat A 4 x 4 matrix
	     * @param {number} prec The number of decimal places
	     * @returns {string}
	     */
	    this.ppMatrix = function (mat, prec) {
	      var t = mat;
	      prec = prec || 2;
	      function f(i) {
	        var d = t[i], s = d.toExponential(prec);
	        if (d >= 0) {
	          s = ' ' + s;
	        }
	        return s;
	      }
	      return [
	        [f(0), f(4), f(8), f(12)].join(' '),
	        [f(1), f(5), f(9), f(13)].join(' '),
	        [f(2), f(6), f(10), f(14)].join(' '),
	        [f(3), f(7), f(11), f(15)].join(' ')
	      ].join('\n');
	    };

	    /**
	     * Pretty print the transform matrix.
	     */
	    this.toString = function () {
	      return this.ppMatrix(this._transform);
	    };

	    /**
	     * Return a debugging string of the current camera state.
	     */
	    this.debug = function () {
	      return [
	        'bounds',
	        JSON.stringify(this.bounds),
	        'view:',
	        this.ppMatrix(this._view),
	        'projection:',
	        this.ppMatrix(this._proj),
	        'transform:',
	        this.ppMatrix(this._transform)
	      ].join('\n');
	    };

	    /**
	     * Represent the value of the camera as its transform matrix.
	     */
	    this.valueOf = function () {
	      return this._transform;
	    };

	    // initialize the view matrix
	    this._resetView();

	    // set up the projection matrix
	    this.projection = spec.projection || 'parallel';

	    // initialize the viewport
	    if (spec.viewport) {
	      this.viewport = spec.viewport;
	    }

	    // trigger an initial update to set up the camera state
	    this._update();

	    return this;
	  };

	  /**
	   * Supported projection types.
	   */
	  camera.projection = {
	    perspective: true,
	    parallel: true
	  };

	  /**
	   * Camera clipping bounds, probably shouldn't be modified.
	   */
	  camera.bounds = {
	    left: -1,
	    right: 1,
	    top: 1,
	    bottom: -1,
	    far: -2,
	    near: -1
	  };

	  /**
	   * Output a mat4 as a css transform.
	   * @param {mat4} t A matrix transform
	   * @returns {string} A css transform string
	   */
	  camera.css = function (t) {
	    return (
	      'matrix3d(' +
	        [
	          t[0].toFixed(20),
	          t[1].toFixed(20),
	          t[2].toFixed(20),
	          t[3].toFixed(20),
	          t[4].toFixed(20),
	          t[5].toFixed(20),
	          t[6].toFixed(20),
	          t[7].toFixed(20),
	          t[8].toFixed(20),
	          t[9].toFixed(20),
	          t[10].toFixed(20),
	          t[11].toFixed(20),
	          t[12].toFixed(20),
	          t[13].toFixed(20),
	          t[14].toFixed(20),
	          t[15].toFixed(20)
	        ].join(',') +
	      ')'
	    );
	  };

	  /**
	   * Generate a mat4 representing an affine coordinate transformation.
	   *
	   * For the following affine transform:
	   *
	   *    x |-> m * (x + a) + b
	   *
	   * applies the css transform:
	   *
	   *    translate(b) scale(m) translate(a)
	   *
	   * @param {object?} pre Coordinate offset **before** scaling
	   * @param {object?} scale Coordinate scaling
	   * @param {object?} post Coordinate offset **after** scaling
	   * @returns {mat4} The new transform matrix
	   */
	  camera.affine = function (pre, scale, post) {
	    var mat = util.mat4AsArray();

	    // Note: mat4 operations are applied to the right side of the current
	    // transform, so the first applied here is the last applied to the
	    // coordinate.
	    if (post) {
	      mat4.translate(mat, mat, [post.x || 0, post.y || 0, post.z || 0]);
	    }
	    if (scale) {
	      mat4.scale(mat, mat, [scale.x || 1, scale.y || 1, scale.z || 1]);
	    }
	    if (pre) {
	      mat4.translate(mat, mat, [pre.x || 0, pre.y || 0, pre.z || 0]);
	    }
	    return mat;
	  };

	  /**
	   * Apply the given transform matrix to a point in place.
	   * @param {mat4} t
	   * @param {vec4} pt
	   * @returns {vec4}
	   */
	  camera.applyTransform = function (t, pt) {
	    return vec4.transformMat4(pt, pt, t);
	  };

	  /**
	   * Combine two transforms by multiplying their matrix representations.
	   * @note The second transform provided will be the first applied in the
	   * coordinate transform.
	   * @param {mat4} A
	   * @param {mat4} B
	   * @returns {mat4} A * B
	   */
	  camera.combine = function (A, B) {
	    return mat4.multiply(util.mat4AsArray(), A, B);
	  };

	  inherit(camera, object);
	  module.exports = camera;
	})();


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class pointFeature
	 *
	 * @class geo.pointFeature
	 * @param {object} arg Options object
	 * @param {boolean} arg.clustering Enable point clustering
	 * @extends geo.feature
	 * @returns {geo.pointFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var pointFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof pointFeature)) {
	    return new pointFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  var $ = __webpack_require__(1);
	  var timestamp = __webpack_require__(195);
	  var ClusterGroup = __webpack_require__(200);
	  var geo_event = __webpack_require__(5);
	  var util = __webpack_require__(196);
	  var wigglemaps = __webpack_require__(204);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      m_rangeTree = null,
	      m_rangeTreeTime = timestamp(),
	      s_data = this.data,
	      m_maxRadius = 0,
	      m_clustering = arg.clustering,
	      m_clusterTree = null,
	      m_allData = [],
	      m_lastZoom = null,
	      m_ignoreData = false; // flag to ignore data() calls made locally

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set clustering option
	   *
	   * @returns {geo.pointFeature|boolean}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clustering = function (val) {
	    if (val === undefined) {
	      return m_clustering;
	    }
	    if (m_clustering && !val) {
	      // Throw out the cluster tree and reset the data
	      m_clusterTree = null;
	      m_clustering = false;
	      s_data(m_allData);
	      m_allData = null;
	    } else if (!m_clustering && val) {
	      // Generate the cluster tree
	      m_clustering = true;
	      m_this._clusterData();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Generate the clustering tree from positions.  This might be async in the
	   * future.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._clusterData = function () {
	    if (!m_clustering) {
	      // clustering is not enabled, so this is a no-op
	      return;
	    }

	    // set clustering options to default if an options argument wasn't supplied
	    var opts = m_clustering === true ? {radius: 0.01} : m_clustering;

	    // generate the cluster tree from the raw data
	    var position = m_this.position();
	    m_clusterTree = new ClusterGroup(
	        opts, m_this.layer().width(), m_this.layer().height());

	    m_allData.forEach(function (d, i) {

	      // for each point in the data set normalize the coordinate
	      // representation and add the point to the cluster treee
	      var pt = util.normalizeCoordinates(position(d, i));
	      pt.index = i;
	      m_clusterTree.addPoint(pt);
	    });

	    // reset the last zoom state and trigger a redraw at the current zoom level
	    m_lastZoom = null;
	    m_this._handleZoom(m_this.layer().map().zoom());
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle zoom events for clustering.  This keeps track of the last
	   * clustering level, and only regenerates the displayed points when the
	   * zoom level changes.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleZoom = function (zoom) {
	    // get the current zoom level rounded down
	    var z = Math.floor(zoom);

	    if (!m_clustering || z === m_lastZoom) {
	      // short cut when there is nothing to do
	      return;
	    }

	    // store the current zoom level privately
	    m_lastZoom = z;

	    // get the raw data elements for the points at the current level
	    var data = m_clusterTree.points(z).map(function (d) {
	      return m_allData[d.index];
	    });

	    // append the clusters at the current level
	    m_clusterTree.clusters(z).forEach(function (d) {
	      // mark the datum as a cluster for accessor methods
	      d.__cluster = true;

	      // store all of the data objects for each point in the cluster as __data
	      d.__data = [];
	      d.obj.each(function (e) {
	        d.__data.push(m_allData[e.index]);
	      });
	      data.push(d);
	    });

	    // prevent recomputing the clustering and set the new data array
	    m_ignoreData = true;
	    m_this.data(data);
	    m_this.draw();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set position
	   *
	   * @returns {geo.pointFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_this.style('position');
	    } else {
	      val = util.ensureFunction(val);
	      m_this.style('position', function (d, i) {
	        if (d.__cluster) {
	          return d;
	        } else {
	          return val(d, i);
	        }
	      });
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the current range tree object.  Should be called whenever the
	   * data changes.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._updateRangeTree = function () {
	    if (m_rangeTreeTime.getMTime() >= m_this.dataTime().getMTime()) {
	      return;
	    }
	    var pts, position,
	        radius = m_this.style.get('radius'),
	        stroke = m_this.style.get('stroke'),
	        strokeWidth = m_this.style.get('strokeWidth');

	    position = m_this.position();

	    m_maxRadius = 0;

	    // create an array of positions in geo coordinates
	    pts = m_this.data().map(function (d, i) {
	      var pt = position(d);
	      pt.idx = i;

	      // store the maximum point radius
	      m_maxRadius = Math.max(
	        m_maxRadius,
	        radius(d, i) + (stroke(d, i) ? strokeWidth(d, i) : 0)
	      );

	      return pt;
	    });

	    m_rangeTree = new wigglemaps.RangeTree(pts);
	    m_rangeTreeTime.modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns an array of datum indices that contain the given point.
	   * Largely adapted from wigglemaps pointQuerier:
	   *
	   * https://github.com/dotskapes/wigglemaps/blob/cf5bed3fbfe2c3e48d31799462a80c564be1fb60/src/query/PointQuerier.js
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pointSearch = function (p) {
	    var min, max, data, idx = [], box, found = [], ifound = [], map, pt,
	        corners,
	        stroke = m_this.style.get('stroke'),
	        strokeWidth = m_this.style.get('strokeWidth'),
	        radius = m_this.style.get('radius');

	    if (!m_this.selectionAPI()) {
	      return [];
	    }

	    data = m_this.data();
	    if (!data || !data.length) {
	      return {
	        found: [],
	        index: []
	      };
	    }

	    map = m_this.layer().map();
	    pt = map.gcsToDisplay(p);
	    // check all corners to make sure we handle rotations
	    corners = [
	      map.displayToGcs({x: pt.x - m_maxRadius, y: pt.y - m_maxRadius}),
	      map.displayToGcs({x: pt.x + m_maxRadius, y: pt.y - m_maxRadius}),
	      map.displayToGcs({x: pt.x - m_maxRadius, y: pt.y + m_maxRadius}),
	      map.displayToGcs({x: pt.x + m_maxRadius, y: pt.y + m_maxRadius})
	    ];
	    min = {
	      x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
	      y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
	    };
	    max = {
	      x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
	      y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
	    };

	    // Find points inside the bounding box
	    box = new wigglemaps.Box(
	      wigglemaps.vect(min.x, min.y),
	      wigglemaps.vect(max.x, max.y)
	    );
	    m_this._updateRangeTree();
	    m_rangeTree.search(box).forEach(function (q) {
	      idx.push(q.idx);
	    });

	    // Filter by circular region
	    idx.forEach(function (i) {
	      var d = data[i],
	          p = m_this.position()(d, i),
	          dx, dy, rad, rad2;

	      rad = radius(data[i], i);
	      rad += stroke(data[i], i) ? strokeWidth(data[i], i) : 0;
	      rad2 = rad * rad;
	      p = map.gcsToDisplay(p);
	      dx = p.x - pt.x;
	      dy = p.y - pt.y;
	      if (dx * dx + dy * dy <= rad2) {
	        found.push(d);
	        ifound.push(i);
	      }
	    });

	    return {
	      found: found,
	      index: ifound
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns an array of datum indices that are contained in the given box.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.boxSearch = function (lowerLeft, upperRight) {
	    var pos = m_this.position(),
	        idx = [];
	    // TODO: use the range tree
	    m_this.data().forEach(function (d, i) {
	      var p = pos(d);
	      if (p.x >= lowerLeft.x &&
	          p.x <= upperRight.x &&
	          p.y >= lowerLeft.y &&
	          p.y <= upperRight.y
	      ) {
	        idx.push(i);
	      }
	    });
	    return idx;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Overloaded data method that updates the internal range tree on write.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.data = function (data) {
	    if (data === undefined) {
	      return s_data();
	    }
	    if (m_clustering && !m_ignoreData) {
	      m_allData = data;
	      m_this._clusterData();
	    } else {
	      s_data(data);
	    }
	    m_ignoreData = false;
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns the bounding box for a given datum in screen coordinates as an
	   * object: ::
	   *
	   *   {
	   *     min: {
	   *       x: value,
	   *       y: value
	   *     },
	   *     max: {
	   *       x: value,
	   *       y: value
	   *     }
	   *   }
	   *
	   * @returns {object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._boundingBox = function (d) {
	    var pt, radius;

	    // get the position in geo coordinates
	    pt = m_this.position()(d);

	    // convert to screen coordinates
	    pt = m_this.layer().map().gcsToDisplay(pt);

	    // get the radius of the points (should we add stroke width?)
	    radius = m_this.style().radius(d);

	    return {
	      min: {
	        x: pt.x - radius,
	        y: pt.y - radius
	      },
	      max: {
	        x: pt.x + radius,
	        y: pt.y + radius
	      }
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(
	      {},
	      {
	        radius: 5.0,
	        stroke: true,
	        strokeColor: { r: 0.851, g: 0.604, b: 0.0 },
	        strokeWidth: 1.25,
	        strokeOpacity: 1.0,
	        fillColor: { r: 1.0, g: 0.839, b: 0.439 },
	        fill: true,
	        fillOpacity: 0.8,
	        sprites: false,
	        sprites_image: null,
	        position: function (d) { return d; }
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    if (arg.position !== undefined) {
	      defaultStyle.position = arg.position;
	    }

	    m_this.style(defaultStyle);
	    m_this.dataTime().modified();

	    // bind to the zoom handler for point clustering
	    m_this.geoOn(geo_event.zoom, function (evt) {
	      m_this._handleZoom(evt.zoomLevel);
	    });
	  };

	  return m_this;
	};

	/**
	 * Object specification for a point feature.
	 *
	 * @extends geo.feature.spec // need to make a jsdoc plugin for this to work
	 * @typedef geo.pointFeature.spec
	 * @type {object}
	 */

	/**
	 * Create a pointFeature from an object.
	 * @see {@link geo.feature.create}
	 * @param {geo.layer} layer The layer to add the feature to
	 * @param {geo.pointFeature.spec} spec The object specification
	 * @returns {geo.pointFeature|null}
	 */
	pointFeature.create = function (layer, renderer, spec) {
	  'use strict';

	  spec.type = 'point';
	  return feature.create(layer, spec);
	};

	pointFeature.capabilities = {
	  /* core feature name -- support in any manner */
	  feature: 'point'
	};

	inherit(pointFeature, feature);
	module.exports = pointFeature;


/***/ },
/* 204 */
/***/ function(module, exports) {

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * @license
	 * Includes several support classes adapted from wigglemaps.
	 *
	 * https://github.com/dotskapes/wigglemaps
	 *
	 * Copyright 2013 Preston and Krejci (dotSkapes Virtual Lab)
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	//////////////////////////////////////////////////////////////////////////////

	(function () {
	    'use strict';

	    var RangeNode = function (elem, start, end, current) {
	        this.data = elem[current];
	        this.left = null;
	        this.right = null;
	        if (start !== current)
	            this.left = new RangeNode(elem, start, current - 1, parseInt((start + (current - 1)) / 2, 10));
	        if (end !== current)
	            this.right = new RangeNode(elem, current + 1, end, parseInt((end + (current + 1)) / 2, 10));
	        this.elem = elem;
	        this.start = start;
	        this.end = end;
	        this.subtree = null; /* This is populated as needed */
	        this.search = rangeNodeSearch;
	    };

	    var rangeNodeSearch = function (result, box) {
	        var m_this = this;

	        var xrange = function (b) {
	            return (b.x_in(m_this.elem[m_this.start]) &&
	                    b.x_in(m_this.elem[m_this.end]));
	        };

	        var yrange = function (b, start, end) {
	            return (b.y_in(m_this.subtree[start]) &&
	                    b.y_in(m_this.subtree[end]));
	        };

	        var subquery = function (result, box, start, end, current) {
	            if (yrange(box, start, end)) {
	                for (var i = start; i <= end; i ++) {
	                    result.push(m_this.subtree[i]);
	                }
	                return;
	            }
	            if (box.y_in(m_this.subtree[current]))
	                result.push(m_this.subtree[current]);
	            if (box.y_left(m_this.subtree[current])){
	                if (current !== end)
	                    subquery(result, box, current + 1, end, parseInt((end + (current + 1)) / 2, 10));
	            } else if (box.x_right(m_this.subtree[current])) {
	                if (current !== start)
	                    subquery(result, box, start, current - 1, parseInt((start + (current - 1)) / 2, 10));
	            } else {
	                if (current !== end)
	                    subquery(result, box, current + 1, end, parseInt((end + (current + 1)) / 2, 10));
	                if (current !== start)
	                    subquery(result, box, start, current - 1, parseInt((start + (current - 1)) / 2, 10));
	            }
	        };

	        if (xrange(box)) {
	            if (!this.subtree) {
	                this.subtree = this.elem.slice(this.start, this.end + 1);
	                this.subtree.sort(function (a, b) {
	                    return a.y - b.y;
	                });
	            }
	            subquery(result, box, 0, this.subtree.length - 1, parseInt((this.subtree.length - 1) / 2, 10));
	            return;
	        } else {
	            if (box.contains(this.data))
	                result.push(this.data);
	            if (box.x_left(this.data)) {
	                if (this.right)
	                    this.right.search(result, box);
	            } else if (box.x_right(this.data)) {
	                if (this.left)
	                    this.left.search(result, box);
	            } else {
	                if (this.left)
	                    this.left.search(result, box);
	                if (this.right)
	                    this.right.search(result, box);
	            }
	        }
	    };

	    var RangeTree = function (elem) {
	        elem.sort(function (a, b) {
	            return a.x - b.x;
	        });
	        if (elem.length > 0)
	            this.root = new RangeNode(elem, 0, elem.length - 1, parseInt((elem.length - 1) / 2, 10));
	        else
	            this.root = null;

	        this.search = function (_box) {
	            if (!this.root)
	                return [];
	            //var box = new Box (min, max);
	            var box = _box.clone ();
	            var result = [];
	            this.root.search (result, box);
	            return result;
	        };
	    };

	    var Box = function (v1, v2) {
	        this.min = v1.clone ();
	        this.max = v2.clone ();
	        this.contains = function (p) {
	            return (v1.x <= p.x) && (v2.x >= p.x) && (v1.y <= p.y) && (v2.y >= p.y);
	        };

	        this.x_in = function (p) {
	            return (v1.x <= p.x) && (v2.x >= p.x);
	        };

	        this.x_left = function (p) {
	            return (v1.x >= p.x);
	        };

	        this.x_right = function (p) {
	            return (v2.x <= p.x);
	        };

	        this.y_in = function (p) {
	            return (v1.y <= p.y) && (v2.y >= p.y);
	        };

	        this.y_left = function (p) {
	            return (v1.y >= p.y);
	        };

	        this.y_right = function (p) {
	            return (v2.y <= p.y);
	        };

	        this.area = function () {
	            return (this.max.x - this.min.x) * (this.max.y - this.min.y);
	        };

	        this.height = function () {
	            return this.max.y - this.min.y;
	        };

	        this.width = function () {
	            return this.max.x - this.min.x;
	        };

	        this.vertex = function (index) {
	            switch (index) {
	            case 0:
	                return this.min.clone ();
	            case 1:
	                return new vect (this.max.x, this.min.y);
	            case 2:
	                return this.max.clone ();
	            case 3:
	                return new vect (this.min.x, this.max.y);
	            default:
	                throw "Index out of bounds: " + index ;
	            }
	        };

	        this.intersects = function (box) {
	            for (var i = 0; i < 4; i ++) {
	                for (var j = 0; j < 4; j ++) {
	                    if (vect.intersects (this.vertex (i), this.vertex ((i + 1) % 4),
	                                         box.vertex (j), box.vertex ((j + 1) % 4)))
	                        return true;
	                }
	            }
	            if (this.contains (box.min) &&
	                this.contains (box.max) &&
	                this.contains (new vect (box.min.x, box.max.y)) &&
	                this.contains (new vect (box.max.x, box.min.y)))
	                return true;
	            if (box.contains (this.min) &&
	                box.contains (this.max) &&
	                box.contains (new vect (this.min.x, this.max.y)) &&
	                box.contains (new vect (this.max.x, this.min.y)))
	                return true;
	            return false;
	        };

	        this.union = function (b) {
	            this.min.x = Math.min (this.min.x, b.min.x);
	            this.min.y = Math.min (this.min.y, b.min.y);

	            this.max.x = Math.max (this.max.x, b.max.x);
	            this.max.y = Math.max (this.max.y, b.max.y);
	        };

	        this.centroid = function () {
	            return new vect ((this.max.x + this.min.x) / 2, (this.max.y + this.min.y) / 2);
	        };

	        this.clone = function () {
	            return new Box (v1, v2);
	        };
	    };

	    // A basic vector type. Supports standard 2D vector operations
	    var Vector2D = function (x, y) {
	        this.x = x;
	        this.y = y;

	        this.add = function (v) {
	            this.x += v.x;
	            this.y += v.y;
	            return this;
	        };
	        this.sub = function (v) {
	            this.x -= v.x;
	            this.y -= v.y;
	            return this;
	        };
	        this.scale = function (s) {
	            this.x *= s;
	            this.y *= s;
	            return this;
	        };
	        this.length = function () {
	            return Math.sqrt (this.x * this.x + this.y * this.y);
	        };
	        this.normalize = function () {
	            var scale = this.length ();
	            if (scale === 0)
	                return this;
	            this.x /= scale;
	            this.y /= scale;
	            return this;
	        };
	        this.div = function (v) {
	            this.x /= v.x;
	            this.y /= v.y;
	            return this;
	        };
	        this.floor = function () {
	            this.x = Math.floor (this.x);
	            this.y = Math.floor (this.y);
	            return this;
	        };
	        this.zero = function (tol) {
	            tol = tol || 0;
	            return (this.length() <= tol);
	        };
	        this.dot = function (v) {
	            return (this.x * v.x) + (this.y * v.y);
	        };
	        this.cross = function (v) {
	            return (this.x * v.y) - (this.y * v.x);
	        };
	        this.rotate = function (omega) {
	            var cos = Math.cos (omega);
	            var sin = Math.sin (omega);
	            xp = cos * this.x - sin * this.y;
	            yp = sin * this.x + cos * this.y;
	            this.x = xp;
	            this.y = yp;
	            return this;
	        };
	        this.clone = function () {
	            return new Vector2D (this.x, this.y);
	        };

	        this.array = function () {
	            return [this.x, this.y];
	        };
	    };

	    // A shortcut for the vector constructor
	    function vect (x, y) {
	        return new Vector2D (x, y);
	    }

	    // Shorthand operations for vectors for operations that make new vectors

	    vect.scale = function (v, s) {
	        return v.clone ().scale (s);
	    };

	    vect.add = function (v1, v2) {
	        return v1.clone ().add (v2);
	    };

	    vect.sub = function (v1, v2) {
	        return v1.clone ().sub (v2);
	    };

	    vect.dist = function (v1, v2) {
	        return v1.clone ().sub (v2).length ();
	    };

	    vect.dir = function (v1, v2) {
	        return v1.clone ().sub (v2).normalize ();
	    };

	    vect.dot = function (v1, v2) {
	        return (v1.x * v2.x) + (v1.y * v2.y);
	    };

	    vect.cross = function (v1, v2) {
	        return (v1.x * v2.y) - (v1.y * v2.x);
	    };

	    vect.left = function (a, b, c, tol) {
	        if (!tol)
	            tol = 0;
	        var v1 = vect.sub (b, a);
	        var v2 = vect.sub (c, a);
	        return (vect.cross (v1, v2) >= -tol);
	    };

	    vect.intersects = function (a, b, c, d, tol) {
	        if (!tol)
	            tol = 0;
	        return (vect.left (a, b, c, tol) != vect.left (a, b, d, tol) &&
	                vect.left (c, d, b, tol) != vect.left (c, d, a, tol));
	    };

	    vect.intersect2dt = function (a, b, c, d) {
	        var denom = a.x * (d.y - c.y) +
	            b.x * (c.y - d.y) +
	            d.x * (b.y - a.y) +
	            c.x * (a.y - b.y);

	        if (denom === 0)
	            return Infinity;

	        var num_s = a.x * (d.y - c.y) +
	            c.x * (a.y - d.y) +
	            d.x * (c.y - a.y);
	        var s = num_s / denom;

	        var num_t = -(a.x * (c.y - b.y) +
	                      b.x * (a.y - c.y) +
	                      c.x * (b.y - a.y));
	        var t = num_t / denom;

	        return t;
	    };

	    vect.intersect2dpos = function (a, b, c, d) {
	        var denom = a.x * (d.y - c.y) +
	            b.x * (c.y - d.y) +
	            d.x * (b.y - a.y) +
	            c.x * (a.y - b.y);

	        if (denom === 0)
	            return Infinity;

	        var num_s = a.x * (d.y - c.y) +
	            c.x * (a.y - d.y) +
	            d.x * (c.y - a.y);
	        var s = num_s / denom;

	        /*var num_t = -(a.x * (c.y - b.y) +
	                      b.x * (a.y - c.y) +
	                      c.x * (b.y - a.y));
	        var t = num_t / denom;*/

	        var dir = vect.sub (b, a);
	        dir.scale (s);
	        return vect.add (a, dir);
	    };

	    vect.rotate = function (v, omega) {
	        var cos = Math.cos (omega);
	        var sin = Math.sin (omega);
	        xp = cos * v.x - sin * v.y;
	        yp = sin * v.x + cos * v.y;
	        var c = new vect (xp, yp);
	        return c;
	    };

	    vect.normalize = function (v) {
	        return v.clone ().normalize ();
	    };

	    module.exports = {
	        Box: Box,
	        vect: vect,
	        RangeTree: RangeTree
	    };
	}());


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class polygonFeature
	 *
	 * @class geo.polygonFeature
	 * @extends geo.feature
	 * @param {Object} arg Options object
	 * @param {Object|Function} [arg.position] Position of the data.  Default is
	 *   (data).
	 * @param {Object|Function} [arg.polygon] Polygons from the data.  Default is
	 *   (data).  Typically, the data is an array of polygons, each of which is
	 *   of the form {outer: [(coordinates)], inner: [[(coordinates of first
	 *   hole)], [(coordinates of second hole)], ...]}.  The inner record is
	 *   optional.  Alternately, if there are no holes, a polygon can just be an
	 *   array of coordinates.  Coordinates are in the form {x: (x), y: (y),
	 *   z: (z)}, with z being optional.  The first and last point of each polygon
	 *   must be the same.
	 * @param {Object} [arg.style] Style object with default style options.
	 * @param {boolean|Function} [arg.style.fill] True to fill polygon.  Defaults
	 *   to true.
	 * @param {Object|Function} [arg.style.fillColor] Color to fill each polygon.
	 *   The color can vary by vertex.  Colors can be css names or hex values, or
	 *   an object with r, g, b on a [0-1] scale.
	 * @param {number|Function} [arg.style.fillOpacity] Opacity for each polygon.
	 *   The opacity can vary by vertex.  Opacity is on a [0-1] scale.
	 * @param {boolean|Function} [arg.style.stroke] True to stroke polygon.
	 *   Defaults to false.
	 * @param {Object|Function} [arg.style.strokeColor] Color to stroke each
	 *   polygon.  The color can vary by vertex.  Colors can be css names or hex
	 *   values, or an object with r, g, b on a [0-1] scale.
	 * @param {number|Function} [arg.style.strokeOpacity] Opacity for each polygon
	 *   stroke.  The opacity can vary by vertex.  Opacity is on a [0-1] scale.
	 * @param {number|Function} [arg.style.strokeWidth] The weight of the polygon
	 *   stroke in pixels.  The width can vary by vertex.
	 * @param {boolean|Function} [arg.style.uniformPolygon] Boolean indicating if
	 *   each polygon has a uniform style (uniform fill color, fill opacity, stroke
	 *   color, and stroke opacity).   Defaults to false.  Can vary by polygon.
	 * @returns {geo.polygonFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var polygonFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof polygonFeature)) {
	    return new polygonFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  var util = __webpack_require__(196);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_lineFeature,
	      s_init = this._init,
	      s_exit = this._exit,
	      s_data = this.data,
	      s_draw = this.draw,
	      s_modified = this.modified,
	      s_style = this.style,
	      m_coordinates = [];

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set data.
	   *
	   * @memberof geo.polygonFeature
	   * @param {Object} [data] if specified, use this for the data and return the
	   *    feature.  If not specified, return the current data.
	   * @returns {geo.polygonFeature|Object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.data = function (arg) {
	    var ret = s_data(arg);
	    if (arg !== undefined) {
	      getCoordinates();
	      this._checkForStroke();
	    }
	    return ret;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the internal coordinates whenever the data changes.  For now, we do
	   * the computation in world coordinates, but we will need to work in GCS
	   * for other projections.  Also compute the extents of the outside of each
	   * polygon for faster checking if points are in the polygon.
	   * @memberof geo.polygonFeature
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function getCoordinates() {
	    var posFunc = m_this.style.get('position'),
	        polyFunc = m_this.style.get('polygon');
	    m_coordinates = m_this.data().map(function (d, i) {
	      var poly = polyFunc(d);
	      if (!poly) {
	        return;
	      }
	      var outer, inner, range, coord, j, x, y;

	      coord = poly.outer || (poly instanceof Array ? poly : []);
	      outer = new Array(coord.length);
	      for (j = 0; j < coord.length; j += 1) {
	        outer[j] = posFunc.call(m_this, coord[j], j, d, i);
	        x = outer[j].x || outer[j][0] || 0;
	        y = outer[j].y || outer[j][1] || 0;
	        if (!j) {
	          range = {min: {x: x, y: y}, max: {x: x, y: y}};
	        } else {
	          if (x < range.min.x) { range.min.x = x; }
	          if (y < range.min.y) { range.min.y = y; }
	          if (x > range.max.x) { range.max.x = x; }
	          if (y > range.max.y) { range.max.y = y; }
	        }
	      }
	      inner = (poly.inner || []).map(function (hole) {
	        coord = hole || [];
	        var trans = new Array(coord.length);
	        for (j = 0; j < coord.length; j += 1) {
	          trans[j] = posFunc.call(m_this, coord[j], j, d, i);
	        }
	        return trans;
	      });
	      return {
	        outer: outer,
	        inner: inner,
	        range: range
	      };
	    });
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set polygon accessor.
	   *
	   * @memberof geo.polygonFeature
	   * @param {Object} [polygon] if specified, use this for the polygon accessor
	   *    and return the feature.  If not specified, return the current polygon.
	   * @returns {geo.polygonFeature|Object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.polygon = function (val) {
	    if (val === undefined) {
	      return m_this.style('polygon');
	    } else {
	      m_this.style('polygon', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	      getCoordinates();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set position accessor.
	   *
	   * @memberof geo.polygonFeature
	   * @param {Object} [position] if specified, use this for the position
	   *    accessor and return the feature.  If not specified, return the current
	   *    position.
	   * @returns {geo.polygonFeature|Object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_this.style('position');
	    } else {
	      m_this.style('position', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	      getCoordinates();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Point search method for selection api.  Returns markers containing the
	   * given point.
	   *
	   * @memberof geo.polygonFeature
	   * @argument {object} coordinate
	   * @returns {object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pointSearch = function (coordinate) {
	    var found = [], indices = [], data = m_this.data();
	    m_coordinates.forEach(function (coord, i) {
	      var inside = util.pointInPolygon(
	        coordinate,
	        coord.outer,
	        coord.inner,
	        coord.range
	      );
	      if (inside) {
	        indices.push(i);
	        found.push(data[i]);
	      }
	    });
	    return {
	      index: indices,
	      found: found
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set style used by the feature.  This calls the super function, then
	   * checks if strokes are required.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.style = function (arg1, arg2) {
	    var result = s_style.apply(this, arguments);
	    if (arg1 !== undefined && (typeof arg1 !== 'string' || arg2 !== undefined)) {
	      this._checkForStroke();
	    }
	    return result;
	  };

	  this.style.get = s_style.get;

	  /**
	   * Get an outer or inner loop of a polygon and return the necessary data to
	   * use it for a closed polyline.
	   *
	   * @param {object} item: the polygon.
	   * @param {number} itemIndex: the index of the polygon
	   * @param {Array} loop: the inner or outer loop.
	   * @returns {Array} the loop with the data necessary to send to the position
	   *    function for each vertex.
	   */
	  this._getLoopData = function (item, itemIndex, loop) {
	    var line = [], i;

	    for (i = 0; i < loop.length; i += 1) {
	      line.push([loop[i], i, item, itemIndex]);
	    }
	    return line;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Check if we need to add a line feature to the layer, and update it as
	   * necessary.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._checkForStroke = function () {
	    if (s_style('stroke') === false) {
	      if (m_lineFeature && m_this.layer()) {
	        m_this.layer().deleteFeature(m_lineFeature);
	        m_lineFeature = null;
	      }
	      return;
	    }
	    if (!m_this.layer()) {
	      return;
	    }
	    if (!m_lineFeature) {
	      m_lineFeature = m_this.layer().createFeature(
	        'line', {selectionAPI: false, gcs: this.gcs()});
	    }
	    var polyStyle = m_this.style();
	    m_lineFeature.style({
	      closed: true,
	      strokeWidth: polyStyle.strokeWidth,
	      strokeStyle: polyStyle.strokeStyle,
	      strokeColor: polyStyle.strokeColor,
	      strokeOpacity: function (d) {
	        return m_this.style.get('stroke')(d[2], d[3]) ? m_this.style.get('strokeOpacity')(d[0], d[1], d[2], d[3]) : 0;
	      }
	    });
	    var data = this.data(),
	        posFunc = this.style.get('position'),
	        polyFunc = this.style.get('polygon');
	    if (data !== m_lineFeature._lastData || posFunc !== m_lineFeature._posFunc) {
	      var lineData = [], i, polygon, loop;

	      for (i = 0; i < data.length; i += 1) {
	        polygon = polyFunc(data[i], i);
	        if (!polygon) {
	          continue;
	        }
	        loop = polygon.outer || (polygon instanceof Array ? polygon : []);
	        lineData.push(m_this._getLoopData(data[i], i, loop));
	        if (polygon.inner) {
	          polygon.inner.forEach(function (loop) {
	            lineData.push(m_this._getLoopData(data[i], i, loop));
	          });
	        }
	      }
	      m_lineFeature.position(function (d, i, item, itemIndex) {
	        return posFunc(d[0], d[1], d[2], d[3]);
	      });
	      m_lineFeature.data(lineData);
	      m_lineFeature._lastData = data;
	      m_lineFeature._lastPosFunc = posFunc;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  * Redraw the object.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	    var result = s_draw();
	    if (m_lineFeature) {
	      m_lineFeature.draw();
	    }
	    return result;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  * When the feature is marked as modified, mark our sub-feature as modified,
	  * too.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.modified = function () {
	    var result = s_modified();
	    if (m_lineFeature) {
	      m_lineFeature.modified();
	    }
	    return result;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   * @memberof geo.polygonFeature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    if (m_lineFeature && m_this.layer()) {
	      m_this.layer().deleteFeature(m_lineFeature);
	      m_lineFeature = null;
	    }
	    s_exit();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   * @memberof geo.polygonFeature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    arg = arg || {};
	    s_init.call(m_this, arg);

	    var style = $.extend(
	      {},
	      {
	        // default style
	        fill: true,
	        fillColor: {r: 0.0, g: 0.5, b: 0.5},
	        fillOpacity: 1.0,
	        stroke: false,
	        strokeWidth: 1.0,
	        strokeStyle: 'solid',
	        strokeColor: {r: 0.0, g: 1.0, b: 1.0},
	        strokeOpacity: 1.0,
	        polygon: function (d) { return d; },
	        position: function (d) { return d; }
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    if (arg.polygon !== undefined) {
	      style.polygon = arg.polygon;
	    }
	    if (arg.position !== undefined) {
	      style.position = arg.position;
	    }
	    m_this.style(style);

	    this._checkForStroke();
	  };

	  /* Don't call _init here -- let subclasses call it */
	  return this;
	};

	/**
	 * Create a polygonFeature from an object.
	 *
	 * @see {@link geo.feature.create}
	 * @param {geo.layer} layer The layer to add the feature to
	 * @param {geo.polygonFeature.spec} spec The object specification
	 * @returns {geo.polygonFeature|null}
	 */
	polygonFeature.create = function (layer, spec) {
	  'use strict';

	  spec = spec || {};
	  spec.type = 'polygon';
	  return feature.create(layer, spec);
	};

	polygonFeature.capabilities = {
	  /* core feature name -- support in any manner */
	  feature: 'polygon'
	};

	inherit(polygonFeature, feature);
	module.exports = polygonFeature;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var featureLayer = __webpack_require__(207);
	var geo_action = __webpack_require__(208);
	var geo_annotation = __webpack_require__(3);
	var geo_event = __webpack_require__(5);
	var registry = __webpack_require__(76);
	var $ = __webpack_require__(1);
	var Mousetrap = __webpack_require__(209);

	/////////////////////////////////////////////////////////////////////////////
	/**
	 * Layer to handle direct interactions with different features.  Annotations
	 * (features) can be created by calling mode(<name of feature>) or cancelled
	 * with mode(null).
	 *
	 * @class geo.annotationLayer
	 * @extends geo.featureLayer
	 * @param {object?} options
	 * @param {number} [options.dblClickTime=300]  The delay in milliseconds that
	 *    is treated as a double-click when working with annotations.
	 * @param {number} [options.adjacentPointProximity=5]  The minimum distance in
	 *    display coordinates (pixels) between two adjacent points when creating a
	 *    polygon.  A value of 0 requires an exact match.
	 * @param {number} [options.finalPointProximity=10]  The maximum distance in
	 *    display coordinates (pixels) between the starting point and the mouse
	 *    coordinates to signal closing a polygon.  A value of 0 requires an exact
	 *    match.  A negative value disables closing a polygon by clicking on the
	 *    start point.
	 * @returns {geo.annotationLayer}
	 */
	/////////////////////////////////////////////////////////////////////////////
	var annotationLayer = function (args) {
	  'use strict';
	  if (!(this instanceof annotationLayer)) {
	    return new annotationLayer(args);
	  }
	  featureLayer.call(this, args);

	  var mapInteractor = __webpack_require__(210);
	  var timestamp = __webpack_require__(195);
	  var util = __webpack_require__(196);

	  var m_this = this,
	      s_init = this._init,
	      s_exit = this._exit,
	      s_update = this._update,
	      m_buildTime = timestamp(),
	      m_options,
	      m_actions,
	      m_mode = null,
	      m_annotations = [],
	      m_features = [];

	  m_options = $.extend(true, {}, {
	    dblClickTime: 300,
	    adjacentPointProximity: 5,  // in pixels, 0 is exact
	    finalPointProximity: 10  // in pixels, 0 is exact
	  }, args);

	  m_actions = {
	    rectangle: {
	      action: geo_action.annotation_rectangle,
	      owner: 'annotationLayer',
	      input: 'left',
	      modifiers: {shift: false, ctrl: false},
	      selectionRectangle: true
	    }
	  };

	  /**
	   * Process a selection event.  If we are in rectangle-creation mode, this
	   * creates a rectangle.
	   *
	   * @param {geo.event} evt the selection event.
	   */
	  this._processSelection = function (evt) {
	    if (m_this.mode() === 'rectangle') {
	      m_this.mode(null);
	      if (evt.state.action === geo_action.annotation_rectangle) {
	        var map = m_this.map();
	        var params = {
	          corners: [
	            /* Keep in map gcs, not interface gcs to avoid wrapping issues */
	            map.displayToGcs({x: evt.lowerLeft.x, y: evt.lowerLeft.y}, null),
	            map.displayToGcs({x: evt.lowerLeft.x, y: evt.upperRight.y}, null),
	            map.displayToGcs({x: evt.upperRight.x, y: evt.upperRight.y}, null),
	            map.displayToGcs({x: evt.upperRight.x, y: evt.lowerLeft.y}, null)
	          ],
	          layer: this
	        };
	        this.addAnnotation(geo_annotation.rectangleAnnotation(params));
	      }
	    }
	  };

	  /**
	   * Handle mouse movement.  If there is a current annotation, the movement
	   * event is sent to it.
	   *
	   * @param {geo.event} evt the mouse move event.
	   */
	  this._handleMouseMove = function (evt) {
	    if (this.mode() && this.currentAnnotation) {
	      var update = this.currentAnnotation.mouseMove(evt);
	      if (update) {
	        m_this.modified();
	        m_this._update();
	        m_this.draw();
	      }
	    }
	  };

	  /**
	   * Handle mouse clicks.  If there is a current annotation, the click event is
	   * sent to it.
	   *
	   * @param {geo.event} evt the mouse click event.
	   */
	  this._handleMouseClick = function (evt) {
	    if (this.mode() && this.currentAnnotation) {
	      var update = this.currentAnnotation.mouseClick(evt);
	      switch (update) {
	        case 'remove':
	          m_this.removeAnnotation(m_this.currentAnnotation, false);
	          m_this.mode(null);
	          break;
	        case 'done':
	          m_this.mode(null);
	          break;
	      }
	      if (update) {
	        m_this.modified();
	        m_this._update();
	        m_this.draw();
	      }
	    }
	  };

	  /**
	   * Set or get options.
	   *
	   * @param {string|object} arg1 if undefined, return the options object.  If
	   *    a string, either set or return the option of that name.  If an object,
	   *    update the options with the object's values.
	   * @param {object} arg2 if arg1 is a string and this is defined, set the
	   *    option to this value.
	   * @returns {object|this} if options are set, return the layer, otherwise
	   *    return the requested option or the set of options.
	   */
	  this.options = function (arg1, arg2) {
	    if (arg1 === undefined) {
	      return m_options;
	    }
	    if (typeof arg1 === 'string' && arg2 === undefined) {
	      return m_options[arg1];
	    }
	    if (arg2 === undefined) {
	      m_options = $.extend(true, m_options, arg1);
	    } else {
	      m_options[arg1] = arg2;
	    }
	    this.modified();
	    return this;
	  };

	  /**
	   * Calculate the display distance for two coordinate in the current map.
	   *
	   * @param {object} coord1 the first coordinates.
	   * @param {string|geo.transform} [gcs1] undefined to use the interface gcs,
	   *    null to use the map gcs, 'display' if the coordinates are already in
	   *    display coordinates, or any other transform.
	   * @param {object} coord2 the second coordinates.
	   * @param {string|geo.transform} [gcs2] undefined to use the interface gcs,
	   *    null to use the map gcs, 'display' if the coordinates are already in
	   *    display coordinates, or any other transform.
	   * @returns {number} the Euclidian distance between the two coordinates.
	   */
	  this.displayDistance = function (coord1, gcs1, coord2, gcs2) {
	    var map = this.map();
	    if (gcs1 !== 'display') {
	      gcs1 = (gcs1 === null ? map.gcs() : (
	              gcs1 === undefined ? map.ingcs() : gcs1));
	      coord1 = map.gcsToDisplay(coord1, gcs1);
	    }
	    if (gcs2 !== 'display') {
	      gcs2 = (gcs2 === null ? map.gcs() : (
	              gcs2 === undefined ? map.ingcs() : gcs2));
	      coord2 = map.gcsToDisplay(coord2, gcs2);
	    }
	    var dist = Math.sqrt(Math.pow(coord1.x - coord2.x, 2) +
	                         Math.pow(coord1.y - coord2.y, 2));
	    return dist;
	  };

	  /**
	   * Add an annotation to the layer.  The annotation could be in any state.
	   *
	   * @param {object} annotation the annotation to add.
	   */
	  this.addAnnotation = function (annotation) {
	    var pos = $.inArray(annotation, m_annotations);
	    if (pos < 0) {
	      m_this.geoTrigger(geo_event.annotation.add_before, {
	        annotation: annotation
	      });
	      m_annotations.push(annotation);
	      this.modified();
	      this._update();
	      this.draw();
	      m_this.geoTrigger(geo_event.annotation.add, {
	        annotation: annotation
	      });
	    }
	    return this;
	  };

	  /**
	   * Remove an annotation from the layer.
	   *
	   * @param {object} annotation the annotation to remove.
	   * @param {boolean} update if false, don't update the layer after removing
	   *    the annotation.
	   * @returns {boolean} true if an annotation was removed.
	   */
	  this.removeAnnotation = function (annotation, update) {
	    var pos = $.inArray(annotation, m_annotations);
	    if (pos >= 0) {
	      if (annotation === this.currentAnnotation) {
	        this.currentAnnotation = null;
	      }
	      annotation._exit();
	      m_annotations.splice(pos, 1);
	      if (update !== false) {
	        this.modified();
	        this._update();
	        this.draw();
	      }
	      m_this.geoTrigger(geo_event.annotation.remove, {
	        annotation: annotation
	      });
	    }
	    return pos >= 0;
	  };

	  /**
	   * Remove all annotations from the layer.
	   *
	   * @param {boolean} skipCreating: if true, don't remove annotations that are
	   *    in the create state.
	   * @returns {number} the number of annotations that were removed.
	   */
	  this.removeAllAnnotations = function (skipCreating) {
	    var removed = 0, annotation, pos = 0;
	    while (pos < m_annotations.length) {
	      annotation = m_annotations[pos];
	      if (skipCreating && annotation.state() === geo_annotation.state.create) {
	        pos += 1;
	        continue;
	      }
	      this.removeAnnotation(annotation, false);
	      removed += 1;
	    }
	    if (removed) {
	      this.modified();
	      this._update();
	      this.draw();
	    }
	    return removed;
	  };

	  /**
	   * Get the list of annotations on the layer.
	   *
	   * @returns {array} An array of annotations.
	   */
	  this.annotations = function () {
	    return m_annotations.slice();
	  };

	  /**
	   * Get an annotation by its id.
	   *
	   * @returns {geo.annotation} The selected annotation or undefined.
	   */
	  this.annotationById = function (id) {
	    if (id !== undefined && id !== null) {
	      id = +id;  /* Cast to int */
	    }
	    var annotations = m_annotations.filter(function (annotation) {
	      return annotation.id() === id;
	    });
	    if (annotations.length) {
	      return annotations[0];
	    }
	  };

	  /**
	   * Get or set the current mode.  The mode is either null for nothing being
	   * created, or the name of the type of annotation that is being created.
	   *
	   * @param {string|null} arg the new mode or undefined to get the current
	   *    mode.
	   * @returns {string|null|this} The current mode or the layer.
	   */
	  this.mode = function (arg) {
	    if (arg === undefined) {
	      return m_mode;
	    }
	    if (arg !== m_mode) {
	      var createAnnotation, mapNode = m_this.map().node(), oldMode = m_mode;
	      m_mode = arg;
	      mapNode.css('cursor', m_mode ? 'crosshair' : '');
	      if (m_mode) {
	        Mousetrap(mapNode[0]).bind('esc', function () { m_this.mode(null); });
	      } else {
	        Mousetrap(mapNode[0]).unbind('esc');
	      }
	      if (this.currentAnnotation) {
	        switch (this.currentAnnotation.state()) {
	          case geo_annotation.state.create:
	            this.removeAnnotation(this.currentAnnotation);
	            break;
	        }
	        this.currentAnnotation = null;
	      }
	      switch (m_mode) {
	        case 'point':
	          createAnnotation = geo_annotation.pointAnnotation;
	          break;
	        case 'polygon':
	          createAnnotation = geo_annotation.polygonAnnotation;
	          break;
	        case 'rectangle':
	          m_this.map().interactor().addAction(m_actions.rectangle);
	          break;
	      }
	      if (createAnnotation) {
	        this.currentAnnotation = createAnnotation({
	          state: geo_annotation.state.create,
	          layer: this
	        });
	        this.addAnnotation(m_this.currentAnnotation);
	      }
	      if (m_mode !== 'rectangle') {
	        m_this.map().interactor().removeAction(m_actions.rectangle);
	      }
	      m_this.geoTrigger(geo_event.annotation.mode, {
	        mode: m_mode, oldMode: oldMode});
	    }
	    return this;
	  };

	  ///////////////////////////////////////////////////////////////////////////
	  /**
	   * Update layer
	   */
	  ///////////////////////////////////////////////////////////////////////////
	  this._update = function (request) {
	    if (m_this.getMTime() > m_buildTime.getMTime()) {
	      /* Interally, we have a set of feature levels (to provide z-index
	       * support), each of which can have data from multiple annotations.  We
	       * clear the data on each of these features, then build it up from each
	       * annotation.  Eventually, it may be necessary to optimize this and
	       * only update the features that are changed.
	       */
	      $.each(m_features, function (idx, featureLevel) {
	        $.each(featureLevel, function (type, feature) {
	          feature.data = [];
	        });
	      });
	      $.each(m_annotations, function (annotation_idx, annotation) {
	        var features = annotation.features();
	        $.each(features, function (idx, featureLevel) {
	          if (m_features[idx] === undefined) {
	            m_features[idx] = {};
	          }
	          $.each(featureLevel, function (type, featureSpec) {
	            /* Create features as needed */
	            if (!m_features[idx][type]) {
	              try {
	                var feature = m_this.createFeature(type, {
	                  gcs: m_this.map().gcs()
	                });
	              } catch (err) {
	                /* We can't create the desired feature, porbably because of the
	                 * selected renderer.  Issue one warning only. */
	                var key = 'error_feature_' + type;
	                if (!m_this[key]) {
	                  console.warn('Cannot create a ' + type + ' feature for ' +
	                               'annotations.');
	                  m_this[key] = true;
	                }
	                return;
	              }
	              /* Since each annotation can have separate styles, the styles are
	               * combined together with a meta-style function.  Any style that
	               * could be used should be in this list.  Color styles may be
	               * restricted to {r, g, b} objects for efficiency, but this
	               * hasn't been tested.
	               */
	              var style = {};
	              $.each(['fill', 'fillColor', 'fillOpacity', 'line', 'polygon',
	                      'position', 'radius', 'stroke', 'strokeColor',
	                      'strokeOpacity', 'strokeWidth', 'uniformPolygon'
	                  ], function (keyidx, key) {
	                var origFunc;
	                if (feature.style()[key] !== undefined) {
	                  origFunc = feature.style.get(key);
	                }
	                style[key] = function (d, i, d2, i2) {
	                  var style = (
	                    (d && d.style) ? d.style : (d && d[2] && d[2].style) ?
	                    d[2].style : d2.style);
	                  var result = style ? style[key] : d;
	                  if (util.isFunction(result)) {
	                    result = result(d, i, d2, i2);
	                  }
	                  if (result === undefined && origFunc) {
	                    result = origFunc(d, i, d2, i2);
	                  }
	                  return result;
	                };
	              });
	              feature.style(style);
	              m_features[idx][type] = {
	                feature: feature,
	                style: style,
	                data: []
	              };
	            }
	            /* Collect the data for each feature */
	            m_features[idx][type].data.push(featureSpec.data || featureSpec);
	          });
	        });
	      });
	      /* Update the data for each feature */
	      $.each(m_features, function (idx, featureLevel) {
	        $.each(featureLevel, function (type, feature) {
	          feature.feature.data(feature.data);
	        });
	      });
	      m_buildTime.modified();
	    }
	    s_update.call(m_this, request);
	  };

	  ///////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ///////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    /// Call super class init
	    s_init.call(m_this);

	    if (!m_this.map().interactor()) {
	      m_this.map().interactor(mapInteractor({actions: []}));
	    }
	    m_this.geoOn(geo_event.actionselection, m_this._processSelection);

	    m_this.geoOn(geo_event.mouseclick, m_this._handleMouseClick);
	    m_this.geoOn(geo_event.mousemove, m_this._handleMouseMove);

	    return m_this;
	  };

	  ///////////////////////////////////////////////////////////////////////////
	  /**
	   * Free all resources
	   */
	  ///////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    /// Call super class exit
	    s_exit.call(m_this);
	    m_annotations = [];
	    m_features = [];
	    return m_this;
	  };

	  return m_this;
	};

	inherit(annotationLayer, featureLayer);
	registry.registerLayer('annotation', annotationLayer);
	module.exports = annotationLayer;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var layer = __webpack_require__(201);
	var geo_event = __webpack_require__(5);
	var registry = __webpack_require__(76);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Layer to draw points, lines, and polygons on the map The polydata layer
	 * provide mechanisms to create and draw geometrical shapes such as points,
	 * lines, and polygons.
	 * @class geo.featureLayer
	 * @extends geo.layer
	 * @returns {geo.featureLayer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var featureLayer = function (arg) {
	  'use strict';
	  if (!(this instanceof featureLayer)) {
	    return new featureLayer(arg);
	  }
	  layer.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_features = [],
	      s_init = this._init,
	      s_exit = this._exit,
	      s_update = this._update,
	      s_draw = this.draw;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create feature give a name
	   *
	   * @returns {geo.Feature} Will return a new feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createFeature = function (featureName, arg) {

	    var newFeature = registry.createFeature(
	      featureName, m_this, m_this.renderer(), arg);

	    m_this.addChild(newFeature);
	    m_features.push(newFeature);
	    m_this.features(m_features);
	    m_this.modified();
	    return newFeature;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete feature
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.deleteFeature = function (feature) {
	    var i;

	    for (i = 0; i < m_features.length; i += 1) {
	      if (m_features[i] === feature) {
	        m_features[i]._exit();
	        m_this.dataTime().modified();
	        m_this.modified();
	      }
	    }

	    // Loop through a second to time actually remove
	    // the given feature from the array because the
	    // `_exit` call above may mutate it.
	    for (i = 0; i < m_features.length; i += 1) {
	      if (m_features[i] === feature) {
	        m_features.splice(i, 1);
	      }
	    }
	    m_this.removeChild(feature);

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set drawables
	   *
	   * @returns {Array}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.features = function (val) {
	    if (val === undefined) {
	      return m_features;
	    } else {
	      m_features = val.slice(0);
	      m_this.dataTime().modified();
	      m_this.modified();
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    if (m_this.initialized()) {
	      return m_this;
	    }

	    /// Call super class init
	    s_init.call(m_this, true);

	    /// Bind events to handlers
	    m_this.geoOn(geo_event.resize, function (event) {
	      if (m_this.renderer()) {
	        m_this.renderer()._resize(event.x, event.y, event.width, event.height);
	        m_this._update({event: event});
	        m_this.renderer()._render();
	      } else {
	        m_this._update({event: event});
	      }
	    });

	    m_this.geoOn(geo_event.pan, function (event) {
	      m_this._update({event: event});
	      if (m_this.renderer()) {
	        m_this.renderer()._render();
	      }
	    });

	    m_this.geoOn(geo_event.rotate, function (event) {
	      m_this._update({event: event});
	      if (m_this.renderer()) {
	        m_this.renderer()._render();
	      }
	    });

	    m_this.geoOn(geo_event.zoom, function (event) {
	      m_this._update({event: event});
	      if (m_this.renderer()) {
	        m_this.renderer()._render();
	      }
	    });

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update layer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function (request) {
	    var i;

	    if (!m_features.length) {
	      return m_this;
	    }

	    /// Call base class update
	    s_update.call(m_this, request);

	    if (m_features && m_features.length === 0) {
	      console.log('[info] No valid data source found.');
	      return;
	    }

	    if (m_this.dataTime().getMTime() > m_this.updateTime().getMTime()) {
	      for (i = 0; i < m_features.length; i += 1) {
	        m_features[i].renderer(m_this.renderer());
	      }
	    }

	    for (i = 0; i < m_features.length; i += 1) {
	      m_features[i]._update();
	    }

	    m_this.updateTime().modified();

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Free all resources
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.clear();
	    s_exit();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Draw
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	    // Call sceneObject.draw, which calls draw on all child objects.
	    s_draw();

	    // Now call render on the renderer. In certain cases it may not do
	    // anything if the if the child objects are drawn on the screen already.
	    if (m_this.renderer()) {
	      m_this.renderer()._render();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Clear all features in layer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clear = function () {
	    var i;

	    if (!m_features.length) {
	      return m_this;
	    }

	    for (i = 0; i < m_features.length; i += 1) {
	      m_features[i]._exit();
	      m_this.removeChild(m_features[i]);
	    }

	    m_this.dataTime().modified();
	    m_this.modified();
	    m_features = [];

	    return m_this;
	  };

	  return m_this;
	};

	inherit(featureLayer, layer);
	registry.registerLayer('feature', featureLayer);
	module.exports = featureLayer;


/***/ },
/* 208 */
/***/ function(module, exports) {

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Common object containing all action types that are provided by the GeoJS
	 * API.
	 */
	//////////////////////////////////////////////////////////////////////////////
	var geo_action = {
	  momentum: 'geo_action_momentum',
	  pan: 'geo_action_pan',
	  rotate: 'geo_action_rotate',
	  select: 'geo_action_select',
	  unzoomselect: 'geo_action_unzoomselect',
	  zoom: 'geo_action_zoom',
	  zoomselect: 'geo_action_zoomselect',

	  // annotation actions
	  annotation_polygon: 'geo_annotation_polygon',
	  annotation_rectangle: 'geo_annotation_rectangle'
	};

	module.exports = geo_action;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
	/**
	 * Copyright 2016 Craig Campbell
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * Mousetrap is a simple keyboard shortcut library for Javascript with
	 * no external dependencies
	 *
	 * @version 1.6.0
	 * @url craig.is/killing/mice
	 */
	(function(window, document, undefined) {

	    // Check if mousetrap is used inside browser, if not, return
	    if (!window) {
	        return;
	    }

	    /**
	     * mapping of special keycodes to their corresponding keys
	     *
	     * everything in this dictionary cannot use keypress events
	     * so it has to be here to map to the correct keycodes for
	     * keyup/keydown events
	     *
	     * @type {Object}
	     */
	    var _MAP = {
	        8: 'backspace',
	        9: 'tab',
	        13: 'enter',
	        16: 'shift',
	        17: 'ctrl',
	        18: 'alt',
	        20: 'capslock',
	        27: 'esc',
	        32: 'space',
	        33: 'pageup',
	        34: 'pagedown',
	        35: 'end',
	        36: 'home',
	        37: 'left',
	        38: 'up',
	        39: 'right',
	        40: 'down',
	        45: 'ins',
	        46: 'del',
	        91: 'meta',
	        93: 'meta',
	        224: 'meta'
	    };

	    /**
	     * mapping for special characters so they can support
	     *
	     * this dictionary is only used incase you want to bind a
	     * keyup or keydown event to one of these keys
	     *
	     * @type {Object}
	     */
	    var _KEYCODE_MAP = {
	        106: '*',
	        107: '+',
	        109: '-',
	        110: '.',
	        111 : '/',
	        186: ';',
	        187: '=',
	        188: ',',
	        189: '-',
	        190: '.',
	        191: '/',
	        192: '`',
	        219: '[',
	        220: '\\',
	        221: ']',
	        222: '\''
	    };

	    /**
	     * this is a mapping of keys that require shift on a US keypad
	     * back to the non shift equivelents
	     *
	     * this is so you can use keyup events with these keys
	     *
	     * note that this will only work reliably on US keyboards
	     *
	     * @type {Object}
	     */
	    var _SHIFT_MAP = {
	        '~': '`',
	        '!': '1',
	        '@': '2',
	        '#': '3',
	        '$': '4',
	        '%': '5',
	        '^': '6',
	        '&': '7',
	        '*': '8',
	        '(': '9',
	        ')': '0',
	        '_': '-',
	        '+': '=',
	        ':': ';',
	        '\"': '\'',
	        '<': ',',
	        '>': '.',
	        '?': '/',
	        '|': '\\'
	    };

	    /**
	     * this is a list of special strings you can use to map
	     * to modifier keys when you specify your keyboard shortcuts
	     *
	     * @type {Object}
	     */
	    var _SPECIAL_ALIASES = {
	        'option': 'alt',
	        'command': 'meta',
	        'return': 'enter',
	        'escape': 'esc',
	        'plus': '+',
	        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
	    };

	    /**
	     * variable to store the flipped version of _MAP from above
	     * needed to check if we should use keypress or not when no action
	     * is specified
	     *
	     * @type {Object|undefined}
	     */
	    var _REVERSE_MAP;

	    /**
	     * loop through the f keys, f1 to f19 and add them to the map
	     * programatically
	     */
	    for (var i = 1; i < 20; ++i) {
	        _MAP[111 + i] = 'f' + i;
	    }

	    /**
	     * loop through to map numbers on the numeric keypad
	     */
	    for (i = 0; i <= 9; ++i) {
	        _MAP[i + 96] = i;
	    }

	    /**
	     * cross browser add event method
	     *
	     * @param {Element|HTMLDocument} object
	     * @param {string} type
	     * @param {Function} callback
	     * @returns void
	     */
	    function _addEvent(object, type, callback) {
	        if (object.addEventListener) {
	            object.addEventListener(type, callback, false);
	            return;
	        }

	        object.attachEvent('on' + type, callback);
	    }

	    /**
	     * takes the event and returns the key character
	     *
	     * @param {Event} e
	     * @return {string}
	     */
	    function _characterFromEvent(e) {

	        // for keypress events we should return the character as is
	        if (e.type == 'keypress') {
	            var character = String.fromCharCode(e.which);

	            // if the shift key is not pressed then it is safe to assume
	            // that we want the character to be lowercase.  this means if
	            // you accidentally have caps lock on then your key bindings
	            // will continue to work
	            //
	            // the only side effect that might not be desired is if you
	            // bind something like 'A' cause you want to trigger an
	            // event when capital A is pressed caps lock will no longer
	            // trigger the event.  shift+a will though.
	            if (!e.shiftKey) {
	                character = character.toLowerCase();
	            }

	            return character;
	        }

	        // for non keypress events the special maps are needed
	        if (_MAP[e.which]) {
	            return _MAP[e.which];
	        }

	        if (_KEYCODE_MAP[e.which]) {
	            return _KEYCODE_MAP[e.which];
	        }

	        // if it is not in the special map

	        // with keydown and keyup events the character seems to always
	        // come in as an uppercase character whether you are pressing shift
	        // or not.  we should make sure it is always lowercase for comparisons
	        return String.fromCharCode(e.which).toLowerCase();
	    }

	    /**
	     * checks if two arrays are equal
	     *
	     * @param {Array} modifiers1
	     * @param {Array} modifiers2
	     * @returns {boolean}
	     */
	    function _modifiersMatch(modifiers1, modifiers2) {
	        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
	    }

	    /**
	     * takes a key event and figures out what the modifiers are
	     *
	     * @param {Event} e
	     * @returns {Array}
	     */
	    function _eventModifiers(e) {
	        var modifiers = [];

	        if (e.shiftKey) {
	            modifiers.push('shift');
	        }

	        if (e.altKey) {
	            modifiers.push('alt');
	        }

	        if (e.ctrlKey) {
	            modifiers.push('ctrl');
	        }

	        if (e.metaKey) {
	            modifiers.push('meta');
	        }

	        return modifiers;
	    }

	    /**
	     * prevents default for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _preventDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	            return;
	        }

	        e.returnValue = false;
	    }

	    /**
	     * stops propogation for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _stopPropagation(e) {
	        if (e.stopPropagation) {
	            e.stopPropagation();
	            return;
	        }

	        e.cancelBubble = true;
	    }

	    /**
	     * determines if the keycode specified is a modifier key or not
	     *
	     * @param {string} key
	     * @returns {boolean}
	     */
	    function _isModifier(key) {
	        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
	    }

	    /**
	     * reverses the map lookup so that we can look for specific keys
	     * to see what can and can't use keypress
	     *
	     * @return {Object}
	     */
	    function _getReverseMap() {
	        if (!_REVERSE_MAP) {
	            _REVERSE_MAP = {};
	            for (var key in _MAP) {

	                // pull out the numeric keypad from here cause keypress should
	                // be able to detect the keys from the character
	                if (key > 95 && key < 112) {
	                    continue;
	                }

	                if (_MAP.hasOwnProperty(key)) {
	                    _REVERSE_MAP[_MAP[key]] = key;
	                }
	            }
	        }
	        return _REVERSE_MAP;
	    }

	    /**
	     * picks the best action based on the key combination
	     *
	     * @param {string} key - character for key
	     * @param {Array} modifiers
	     * @param {string=} action passed in
	     */
	    function _pickBestAction(key, modifiers, action) {

	        // if no action was picked in we should try to pick the one
	        // that we think would work best for this key
	        if (!action) {
	            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
	        }

	        // modifier keys don't work as expected with keypress,
	        // switch to keydown
	        if (action == 'keypress' && modifiers.length) {
	            action = 'keydown';
	        }

	        return action;
	    }

	    /**
	     * Converts from a string key combination to an array
	     *
	     * @param  {string} combination like "command+shift+l"
	     * @return {Array}
	     */
	    function _keysFromString(combination) {
	        if (combination === '+') {
	            return ['+'];
	        }

	        combination = combination.replace(/\+{2}/g, '+plus');
	        return combination.split('+');
	    }

	    /**
	     * Gets info for a specific key combination
	     *
	     * @param  {string} combination key combination ("command+s" or "a" or "*")
	     * @param  {string=} action
	     * @returns {Object}
	     */
	    function _getKeyInfo(combination, action) {
	        var keys;
	        var key;
	        var i;
	        var modifiers = [];

	        // take the keys from this pattern and figure out what the actual
	        // pattern is all about
	        keys = _keysFromString(combination);

	        for (i = 0; i < keys.length; ++i) {
	            key = keys[i];

	            // normalize key names
	            if (_SPECIAL_ALIASES[key]) {
	                key = _SPECIAL_ALIASES[key];
	            }

	            // if this is not a keypress event then we should
	            // be smart about using shift keys
	            // this will only work for US keyboards however
	            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
	                key = _SHIFT_MAP[key];
	                modifiers.push('shift');
	            }

	            // if this key is a modifier then add it to the list of modifiers
	            if (_isModifier(key)) {
	                modifiers.push(key);
	            }
	        }

	        // depending on what the key combination is
	        // we will try to pick the best event for it
	        action = _pickBestAction(key, modifiers, action);

	        return {
	            key: key,
	            modifiers: modifiers,
	            action: action
	        };
	    }

	    function _belongsTo(element, ancestor) {
	        if (element === null || element === document) {
	            return false;
	        }

	        if (element === ancestor) {
	            return true;
	        }

	        return _belongsTo(element.parentNode, ancestor);
	    }

	    function Mousetrap(targetElement) {
	        var self = this;

	        targetElement = targetElement || document;

	        if (!(self instanceof Mousetrap)) {
	            return new Mousetrap(targetElement);
	        }

	        /**
	         * element to attach key events to
	         *
	         * @type {Element}
	         */
	        self.target = targetElement;

	        /**
	         * a list of all the callbacks setup via Mousetrap.bind()
	         *
	         * @type {Object}
	         */
	        self._callbacks = {};

	        /**
	         * direct map of string combinations to callbacks used for trigger()
	         *
	         * @type {Object}
	         */
	        self._directMap = {};

	        /**
	         * keeps track of what level each sequence is at since multiple
	         * sequences can start out with the same sequence
	         *
	         * @type {Object}
	         */
	        var _sequenceLevels = {};

	        /**
	         * variable to store the setTimeout call
	         *
	         * @type {null|number}
	         */
	        var _resetTimer;

	        /**
	         * temporary state where we will ignore the next keyup
	         *
	         * @type {boolean|string}
	         */
	        var _ignoreNextKeyup = false;

	        /**
	         * temporary state where we will ignore the next keypress
	         *
	         * @type {boolean}
	         */
	        var _ignoreNextKeypress = false;

	        /**
	         * are we currently inside of a sequence?
	         * type of action ("keyup" or "keydown" or "keypress") or false
	         *
	         * @type {boolean|string}
	         */
	        var _nextExpectedAction = false;

	        /**
	         * resets all sequence counters except for the ones passed in
	         *
	         * @param {Object} doNotReset
	         * @returns void
	         */
	        function _resetSequences(doNotReset) {
	            doNotReset = doNotReset || {};

	            var activeSequences = false,
	                key;

	            for (key in _sequenceLevels) {
	                if (doNotReset[key]) {
	                    activeSequences = true;
	                    continue;
	                }
	                _sequenceLevels[key] = 0;
	            }

	            if (!activeSequences) {
	                _nextExpectedAction = false;
	            }
	        }

	        /**
	         * finds all callbacks that match based on the keycode, modifiers,
	         * and action
	         *
	         * @param {string} character
	         * @param {Array} modifiers
	         * @param {Event|Object} e
	         * @param {string=} sequenceName - name of the sequence we are looking for
	         * @param {string=} combination
	         * @param {number=} level
	         * @returns {Array}
	         */
	        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
	            var i;
	            var callback;
	            var matches = [];
	            var action = e.type;

	            // if there are no events related to this keycode
	            if (!self._callbacks[character]) {
	                return [];
	            }

	            // if a modifier key is coming up on its own we should allow it
	            if (action == 'keyup' && _isModifier(character)) {
	                modifiers = [character];
	            }

	            // loop through all callbacks for the key that was pressed
	            // and see if any of them match
	            for (i = 0; i < self._callbacks[character].length; ++i) {
	                callback = self._callbacks[character][i];

	                // if a sequence name is not specified, but this is a sequence at
	                // the wrong level then move onto the next match
	                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
	                    continue;
	                }

	                // if the action we are looking for doesn't match the action we got
	                // then we should keep going
	                if (action != callback.action) {
	                    continue;
	                }

	                // if this is a keypress event and the meta key and control key
	                // are not pressed that means that we need to only look at the
	                // character, otherwise check the modifiers as well
	                //
	                // chrome will not fire a keypress if meta or control is down
	                // safari will fire a keypress if meta or meta+shift is down
	                // firefox will fire a keypress if meta or control is down
	                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

	                    // when you bind a combination or sequence a second time it
	                    // should overwrite the first one.  if a sequenceName or
	                    // combination is specified in this call it does just that
	                    //
	                    // @todo make deleting its own method?
	                    var deleteCombo = !sequenceName && callback.combo == combination;
	                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
	                    if (deleteCombo || deleteSequence) {
	                        self._callbacks[character].splice(i, 1);
	                    }

	                    matches.push(callback);
	                }
	            }

	            return matches;
	        }

	        /**
	         * actually calls the callback function
	         *
	         * if your callback function returns false this will use the jquery
	         * convention - prevent default and stop propogation on the event
	         *
	         * @param {Function} callback
	         * @param {Event} e
	         * @returns void
	         */
	        function _fireCallback(callback, e, combo, sequence) {

	            // if this event should not happen stop here
	            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
	                return;
	            }

	            if (callback(e, combo) === false) {
	                _preventDefault(e);
	                _stopPropagation(e);
	            }
	        }

	        /**
	         * handles a character key event
	         *
	         * @param {string} character
	         * @param {Array} modifiers
	         * @param {Event} e
	         * @returns void
	         */
	        self._handleKey = function(character, modifiers, e) {
	            var callbacks = _getMatches(character, modifiers, e);
	            var i;
	            var doNotReset = {};
	            var maxLevel = 0;
	            var processedSequenceCallback = false;

	            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
	            for (i = 0; i < callbacks.length; ++i) {
	                if (callbacks[i].seq) {
	                    maxLevel = Math.max(maxLevel, callbacks[i].level);
	                }
	            }

	            // loop through matching callbacks for this key event
	            for (i = 0; i < callbacks.length; ++i) {

	                // fire for all sequence callbacks
	                // this is because if for example you have multiple sequences
	                // bound such as "g i" and "g t" they both need to fire the
	                // callback for matching g cause otherwise you can only ever
	                // match the first one
	                if (callbacks[i].seq) {

	                    // only fire callbacks for the maxLevel to prevent
	                    // subsequences from also firing
	                    //
	                    // for example 'a option b' should not cause 'option b' to fire
	                    // even though 'option b' is part of the other sequence
	                    //
	                    // any sequences that do not match here will be discarded
	                    // below by the _resetSequences call
	                    if (callbacks[i].level != maxLevel) {
	                        continue;
	                    }

	                    processedSequenceCallback = true;

	                    // keep a list of which sequences were matches for later
	                    doNotReset[callbacks[i].seq] = 1;
	                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
	                    continue;
	                }

	                // if there were no sequence matches but we are still here
	                // that means this is a regular match so we should fire that
	                if (!processedSequenceCallback) {
	                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
	                }
	            }

	            // if the key you pressed matches the type of sequence without
	            // being a modifier (ie "keyup" or "keypress") then we should
	            // reset all sequences that were not matched by this event
	            //
	            // this is so, for example, if you have the sequence "h a t" and you
	            // type "h e a r t" it does not match.  in this case the "e" will
	            // cause the sequence to reset
	            //
	            // modifier keys are ignored because you can have a sequence
	            // that contains modifiers such as "enter ctrl+space" and in most
	            // cases the modifier key will be pressed before the next key
	            //
	            // also if you have a sequence such as "ctrl+b a" then pressing the
	            // "b" key will trigger a "keypress" and a "keydown"
	            //
	            // the "keydown" is expected when there is a modifier, but the
	            // "keypress" ends up matching the _nextExpectedAction since it occurs
	            // after and that causes the sequence to reset
	            //
	            // we ignore keypresses in a sequence that directly follow a keydown
	            // for the same character
	            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
	            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
	                _resetSequences(doNotReset);
	            }

	            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
	        };

	        /**
	         * handles a keydown event
	         *
	         * @param {Event} e
	         * @returns void
	         */
	        function _handleKeyEvent(e) {

	            // normalize e.which for key events
	            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
	            if (typeof e.which !== 'number') {
	                e.which = e.keyCode;
	            }

	            var character = _characterFromEvent(e);

	            // no character found then stop
	            if (!character) {
	                return;
	            }

	            // need to use === for the character check because the character can be 0
	            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
	                _ignoreNextKeyup = false;
	                return;
	            }

	            self.handleKey(character, _eventModifiers(e), e);
	        }

	        /**
	         * called to set a 1 second timeout on the specified sequence
	         *
	         * this is so after each key press in the sequence you have 1 second
	         * to press the next key before you have to start over
	         *
	         * @returns void
	         */
	        function _resetSequenceTimer() {
	            clearTimeout(_resetTimer);
	            _resetTimer = setTimeout(_resetSequences, 1000);
	        }

	        /**
	         * binds a key sequence to an event
	         *
	         * @param {string} combo - combo specified in bind call
	         * @param {Array} keys
	         * @param {Function} callback
	         * @param {string=} action
	         * @returns void
	         */
	        function _bindSequence(combo, keys, callback, action) {

	            // start off by adding a sequence level record for this combination
	            // and setting the level to 0
	            _sequenceLevels[combo] = 0;

	            /**
	             * callback to increase the sequence level for this sequence and reset
	             * all other sequences that were active
	             *
	             * @param {string} nextAction
	             * @returns {Function}
	             */
	            function _increaseSequence(nextAction) {
	                return function() {
	                    _nextExpectedAction = nextAction;
	                    ++_sequenceLevels[combo];
	                    _resetSequenceTimer();
	                };
	            }

	            /**
	             * wraps the specified callback inside of another function in order
	             * to reset all sequence counters as soon as this sequence is done
	             *
	             * @param {Event} e
	             * @returns void
	             */
	            function _callbackAndReset(e) {
	                _fireCallback(callback, e, combo);

	                // we should ignore the next key up if the action is key down
	                // or keypress.  this is so if you finish a sequence and
	                // release the key the final key will not trigger a keyup
	                if (action !== 'keyup') {
	                    _ignoreNextKeyup = _characterFromEvent(e);
	                }

	                // weird race condition if a sequence ends with the key
	                // another sequence begins with
	                setTimeout(_resetSequences, 10);
	            }

	            // loop through keys one at a time and bind the appropriate callback
	            // function.  for any key leading up to the final one it should
	            // increase the sequence. after the final, it should reset all sequences
	            //
	            // if an action is specified in the original bind call then that will
	            // be used throughout.  otherwise we will pass the action that the
	            // next key in the sequence should match.  this allows a sequence
	            // to mix and match keypress and keydown events depending on which
	            // ones are better suited to the key provided
	            for (var i = 0; i < keys.length; ++i) {
	                var isFinal = i + 1 === keys.length;
	                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
	                _bindSingle(keys[i], wrappedCallback, action, combo, i);
	            }
	        }

	        /**
	         * binds a single keyboard combination
	         *
	         * @param {string} combination
	         * @param {Function} callback
	         * @param {string=} action
	         * @param {string=} sequenceName - name of sequence if part of sequence
	         * @param {number=} level - what part of the sequence the command is
	         * @returns void
	         */
	        function _bindSingle(combination, callback, action, sequenceName, level) {

	            // store a direct mapped reference for use with Mousetrap.trigger
	            self._directMap[combination + ':' + action] = callback;

	            // make sure multiple spaces in a row become a single space
	            combination = combination.replace(/\s+/g, ' ');

	            var sequence = combination.split(' ');
	            var info;

	            // if this pattern is a sequence of keys then run through this method
	            // to reprocess each pattern one key at a time
	            if (sequence.length > 1) {
	                _bindSequence(combination, sequence, callback, action);
	                return;
	            }

	            info = _getKeyInfo(combination, action);

	            // make sure to initialize array if this is the first time
	            // a callback is added for this key
	            self._callbacks[info.key] = self._callbacks[info.key] || [];

	            // remove an existing match if there is one
	            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

	            // add this call back to the array
	            // if it is a sequence put it at the beginning
	            // if not put it at the end
	            //
	            // this is important because the way these are processed expects
	            // the sequence ones to come first
	            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
	                callback: callback,
	                modifiers: info.modifiers,
	                action: info.action,
	                seq: sequenceName,
	                level: level,
	                combo: combination
	            });
	        }

	        /**
	         * binds multiple combinations to the same callback
	         *
	         * @param {Array} combinations
	         * @param {Function} callback
	         * @param {string|undefined} action
	         * @returns void
	         */
	        self._bindMultiple = function(combinations, callback, action) {
	            for (var i = 0; i < combinations.length; ++i) {
	                _bindSingle(combinations[i], callback, action);
	            }
	        };

	        // start!
	        _addEvent(targetElement, 'keypress', _handleKeyEvent);
	        _addEvent(targetElement, 'keydown', _handleKeyEvent);
	        _addEvent(targetElement, 'keyup', _handleKeyEvent);
	    }

	    /**
	     * binds an event to mousetrap
	     *
	     * can be a single key, a combination of keys separated with +,
	     * an array of keys, or a sequence of keys separated by spaces
	     *
	     * be sure to list the modifier keys first to make sure that the
	     * correct key ends up getting bound (the last key in the pattern)
	     *
	     * @param {string|Array} keys
	     * @param {Function} callback
	     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
	     * @returns void
	     */
	    Mousetrap.prototype.bind = function(keys, callback, action) {
	        var self = this;
	        keys = keys instanceof Array ? keys : [keys];
	        self._bindMultiple.call(self, keys, callback, action);
	        return self;
	    };

	    /**
	     * unbinds an event to mousetrap
	     *
	     * the unbinding sets the callback function of the specified key combo
	     * to an empty function and deletes the corresponding key in the
	     * _directMap dict.
	     *
	     * TODO: actually remove this from the _callbacks dictionary instead
	     * of binding an empty function
	     *
	     * the keycombo+action has to be exactly the same as
	     * it was defined in the bind method
	     *
	     * @param {string|Array} keys
	     * @param {string} action
	     * @returns void
	     */
	    Mousetrap.prototype.unbind = function(keys, action) {
	        var self = this;
	        return self.bind.call(self, keys, function() {}, action);
	    };

	    /**
	     * triggers an event that has already been bound
	     *
	     * @param {string} keys
	     * @param {string=} action
	     * @returns void
	     */
	    Mousetrap.prototype.trigger = function(keys, action) {
	        var self = this;
	        if (self._directMap[keys + ':' + action]) {
	            self._directMap[keys + ':' + action]({}, keys);
	        }
	        return self;
	    };

	    /**
	     * resets the library back to its initial state.  this is useful
	     * if you want to clear out the current keyboard shortcuts and bind
	     * new ones - for example if you switch to another page
	     *
	     * @returns void
	     */
	    Mousetrap.prototype.reset = function() {
	        var self = this;
	        self._callbacks = {};
	        self._directMap = {};
	        return self;
	    };

	    /**
	     * should we stop this event before firing off callbacks
	     *
	     * @param {Event} e
	     * @param {Element} element
	     * @return {boolean}
	     */
	    Mousetrap.prototype.stopCallback = function(e, element) {
	        var self = this;

	        // if the element has the class "mousetrap" then no need to stop
	        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
	            return false;
	        }

	        if (_belongsTo(element, self.target)) {
	            return false;
	        }

	        // stop for input, select, and textarea
	        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
	    };

	    /**
	     * exposes _handleKey publicly so it can be overwritten by extensions
	     */
	    Mousetrap.prototype.handleKey = function() {
	        var self = this;
	        return self._handleKey.apply(self, arguments);
	    };

	    /**
	     * allow custom key mappings
	     */
	    Mousetrap.addKeycodes = function(object) {
	        for (var key in object) {
	            if (object.hasOwnProperty(key)) {
	                _MAP[key] = object[key];
	            }
	        }
	        _REVERSE_MAP = null;
	    };

	    /**
	     * Init the global mousetrap functions
	     *
	     * This method is needed to allow the global mousetrap functions to work
	     * now that mousetrap is a constructor function.
	     */
	    Mousetrap.init = function() {
	        var documentMousetrap = Mousetrap(document);
	        for (var method in documentMousetrap) {
	            if (method.charAt(0) !== '_') {
	                Mousetrap[method] = (function(method) {
	                    return function() {
	                        return documentMousetrap[method].apply(documentMousetrap, arguments);
	                    };
	                } (method));
	            }
	        }
	    };

	    Mousetrap.init();

	    // expose mousetrap to the global object
	    window.Mousetrap = Mousetrap;

	    // expose as a common js module
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = Mousetrap;
	    }

	    // expose mousetrap as an AMD module
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return Mousetrap;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var object = __webpack_require__(80);
	var util = __webpack_require__(196);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * The mapInteractor class is responsible for handling raw events from the
	 * browser and interpreting them as map navigation interactions.  This class
	 * will call the navigation methods on the connected map, which will make
	 * modifications to the camera directly.
	 *
	 * @class geo.mapInteractor
	 * @extends geo.object
	 * @returns {geo.mapInteractor}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var mapInteractor = function (args) {
	  'use strict';
	  if (!(this instanceof mapInteractor)) {
	    return new mapInteractor(args);
	  }
	  object.call(this);

	  var $ = __webpack_require__(1);
	  var geo_event = __webpack_require__(5);
	  var geo_action = __webpack_require__(208);
	  var throttle = __webpack_require__(196).throttle;
	  var debounce = __webpack_require__(196).debounce;
	  var actionMatch = __webpack_require__(196).actionMatch;
	  var quadFeature = __webpack_require__(211);

	  var m_options = args || {},
	      m_this = this,
	      m_mouse,
	      m_keyboard,
	      m_state,
	      m_queue,
	      $node,
	      m_selectionLayer = null,
	      m_selectionQuad,
	      m_paused = false,
	      // if m_clickMaybe is not false, it contains the x, y, and buttons that
	      // were present when the mouse down event occurred.
	      m_clickMaybe = false,
	      m_clickMaybeTimeout,
	      m_callZoom = function () {};

	  // Helper method to calculate the speed from a velocity
	  function calcSpeed(v) {
	    var x = v.x, y = v.y;
	    return Math.sqrt(x * x + y * y);
	  }

	  // copy the options object with defaults
	  m_options = $.extend(
	    true,
	    {},
	    {
	      throttle: 30,
	      discreteZoom: false,

	      /* There should only be one action with any specific combination of event
	       * and modifiers.  When that event and modifiers occur, the specified
	       * action is triggered.  The event and modifiers fields can either be a
	       * simple string or an object with multiple entries with each entry set
	       * to true, false, or undefined.  If an object, all values that are
	       * truthy must match, all values that are false must not match, and all
	       * other values that are falsy are ignored.
	       *   Available actions:
	       * see geo_action list
	       *   Available events:
	       * left, right, middle, wheel
	       *   Available modifiers:
	       * shift, ctrl, alt, meta
	       *   Useful fields:
	       * action: the name of the action.  Multiple events may trigger the same
	       *    action.
	       * input: the name of the input or an object with input names for keys
	       *    and boolean values that indicates the combination of events that
	       *    trigger this action.
	       * modifiers: the name of a modifier or an object with modifier names for
	       *    keys and boolean values that indicates the combination of modifiers
	       *    that trigger this action.
	       * selectionRectangle: truthy if a selection rectangle should be shown
	       *    during the action.  This can be the name of an event that will be
	       *    triggered when the selection is complete.
	       * name: a string that can be used to reference this action.
	       * owner: a string that can be used to reference this action.
	       */
	      actions: [{
	        action: geo_action.pan,
	        input: 'left',
	        modifiers: {shift: false, ctrl: false}
	      }, {
	        action: geo_action.zoom,
	        input: 'right',
	        modifiers: {shift: false, ctrl: false}
	      }, {
	        action: geo_action.zoom,
	        input: 'wheel',
	        modifiers: {shift: false, ctrl: false}
	      }, {
	        action: geo_action.rotate,
	        input: 'left',
	        modifiers: {shift: false, ctrl: true}
	      }, {
	        action: geo_action.rotate,
	        input: 'wheel',
	        modifiers: {shift: false, ctrl: true}
	      }, {
	        action: geo_action.select,
	        input: 'left',
	        modifiers: {shift: true, ctrl: true},
	        selectionRectangle: geo_event.select
	      }, {
	        action: geo_action.zoomselect,
	        input: 'left',
	        modifiers: {shift: true, ctrl: false},
	        selectionRectangle: geo_event.zoomselect
	      }, {
	        action: geo_action.unzoomselect,
	        input: 'right',
	        modifiers: {shift: true, ctrl: false},
	        selectionRectangle: geo_event.unzoomselect
	      }],

	      click: {
	        enabled: true,
	        buttons: {left: true, right: true, middle: true},
	        duration: 0,
	        cancelOnMove: true
	      },

	      wheelScaleX: 1,
	      wheelScaleY: 1,
	      zoomScale: 1,
	      rotateWheelScale: 6 * Math.PI / 180,
	      momentum: {
	        enabled: true,
	        maxSpeed: 2.5,
	        minSpeed: 0.01,
	        stopTime: 250,
	        drag: 0.01,
	        actions: [geo_action.pan, geo_action.zoom]
	      },
	      spring: {
	        enabled: false,
	        springConstant: 0.00005
	      },
	      zoomAnimation: {
	        enabled: true,
	        duration: 500,
	        ease: function (t) { return (2 - t) * t; }
	      }
	    },
	    m_options
	  );

	  // options supported:
	  // {
	  //   // throttle mouse events to at most this many milliseconds each (default 30)
	  //   throttle: number
	  //
	  //   // Clamp zoom events to discrete (integer) zoom levels.  If a number is
	  //   // provided then zoom events will be debounced (and accumulated)
	  //   // with the given delay.  The default debounce interval is 400 ms.
	  //   discreteZoom: boolean | number > 0
	  //
	  //   // A list of available actions.  See above
	  //   actions: []
	  //
	  //   // wheel scale factor to change the magnitude of wheel interactions
	  //   wheelScaleX: 1
	  //   wheelScaleY: 1
	  //
	  //   // zoom scale factor to change the magnitude of zoom move interactions
	  //   zoomScale: 1
	  //
	  //   // scale factor to change the magnitude of wheel rotation interactions
	  //   rotateWheelScale: 1
	  //
	  //   // enable momentum when panning
	  //   momentum: {
	  //     enabled: true | false,
	  //     maxSpeed: number, // don't allow animation to pan faster than this
	  //     minSpeed: number, // stop animations if the speed is less than this
	  //     stopTime: number, // if the mouse hasn't moved for this many
	  //                       // milliseconds, don't apply momentum
	  //     drag: number, // drag coefficient
	  //     actions: [geo_action.pan, geo_action.zoom]
	  //                                      // actions on which to apply momentum
	  //   }
	  //
	  //   // enable spring clamping to screen edges to enforce clamping
	  //   spring: {
	  //     enabled: true | false,
	  //     springConstant: number,
	  //   }
	  //
	  //   // enable animation for both discrete and continuous zoom
	  //   zoomAnimation: {
	  //     enabled: true | false,
	  //     duration: number,  // milliseconds
	  //     ease: function     // easing function
	  //   }
	  //
	  //   // enable the "click" event
	  //   // A click will be registered when a mouse down is followed
	  //   // by a mouse up in less than the given number of milliseconds
	  //   // and the standard handler will *not* be called
	  //   // If the duration is <= 0, then clicks will only be canceled by
	  //   // a mousemove.
	  //   click: {
	  //     enabled: true | false,
	  //     buttons: {left: true, right: true, middle: true}
	  //     duration: 0,
	  //     cancelOnMove: true // cancels click if the mouse is moved before release
	  //   }
	  // }

	  // A bunch of type definitions for api documentation:
	  /**
	   * General representation of rectangular bounds in world coordinates
	   * @typedef geo.geoBounds
	   * @type {object}
	   * @property {geo.geoPosition} upperLeft Upper left corner
	   * @property {geo.geoPosition} upperRight Upper right corner
	   * @property {geo.geoPosition} lowerLeft Lower left corner
	   * @property {geo.geoPosition} lowerRight Lower right corner
	   */

	  /**
	   * General representation of rectangular bounds in pixel coordinates
	   * @typedef geo.screenBounds
	   * @type {object}
	   * @property {geo.screenPosition} upperLeft Upper left corner
	   * @property {geo.screenPosition} upperRight Upper right corner
	   * @property {geo.screenPosition} lowerLeft Lower left corner
	   * @property {geo.screenPosition} lowerRight Lower right corner
	   */

	  /**
	   * General representation of a point on the screen.
	   * @typedef geo.screenPosition
	   * @type {object}
	   * @property {Number} x Horizontal coordinate in pixels
	   * @property {Number} y Vertical coordinate in pixels
	   */

	  /**
	   * General represention of a point on the earth.
	   * @typedef geo.geoPosition
	   * @type {object}
	   * @property {Number} x Horizontal coordinate in degrees longitude
	   * @property {Number} y Vertical coordinate in degrees latitude
	   */

	  /**
	   * The status of all mouse buttons.
	   * @typedef geo.mouseButtons
	   * @type {object}
	   * @property {true|false} left The left mouse button
	   * @property {true|false} right The right mouse button
	   * @property {true|false} middle The middle mouse button
	   */

	  /**
	   * The status of all modifier keys these are copied from the
	   * standard DOM events.
	   * @typedef geo.modifierKeys
	   * @type {object}
	   * @property {true|false} alt <code>Event.alt</code>
	   * @property {true|false} ctrl <code>Event.ctrl</code>
	   * @property {true|false} shift <code>Event.shift</code>
	   * @property {true|false} meta <code>Event.meta</code>
	   */

	  /**
	   * Provides information about the state of the mouse
	   * @typedef geo.mouseState
	   * @type {object}
	   * @property {geo.screenPosition} page Mouse location in pixel space
	   * @property {geo.geoPosition} map Mouse location in world space
	   * @property {geo.mouseButtons} buttons The current state of the mouse buttons
	   * @property {geo.modifierKeys} modifiers The current state of all modifier keys
	   * @property {Date} time The timestamp the event took place
	   * @property {Number} deltaTime The time in milliseconds since the last mouse event
	   * @property {geo.screenPosition} velocity The velocity of the mouse pointer
	   * in pixels per second
	   */

	  /**
	   * @typedef geo.brushSelection
	   * @type {object}
	   * @property {geo.screenBounds} display The selection bounds in pixel space
	   * @property {geo.geoBounds} gcs The selection bounds in world space
	   * @property {geo.mouseState} mouse The current mouse state
	   * @property {geo.mouseState} origin The mouse state at the start of the
	   * brush action
	   */

	  // default mouse object
	  m_mouse = {
	    page: { // mouse position relative to the page
	      x: 0,
	      y: 0
	    },
	    map: { // mouse position relative to the map
	      x: 0,
	      y: 0
	    },
	    // mouse button status
	    buttons: {
	      left: false,
	      right: false,
	      middle: false
	    },
	    // keyboard modifier status
	    modifiers: {
	      alt: false,
	      ctrl: false,
	      shift: false,
	      meta: false
	    },
	    // time the event was captured
	    time: new Date(),
	    // time elapsed since the last mouse event
	    deltaTime: 1,
	    // pixels/ms
	    velocity: {
	      x: 0,
	      y: 0
	    }
	  };

	  // default keyboard object
	  // (keyboard events not implemented yet)
	  m_keyboard = {
	  };

	  // The interactor state determines what actions are taken in response to
	  // core browser events.
	  //
	  // i.e.
	  //  {
	  //    'action': geo_action.pan,   // an ongoing pan event
	  //    'origin': {...},      // mouse object at the start of the action
	  //    'delta': {x: *, y: *} // mouse movement since action start
	  //                          // not including the current event
	  //  }
	  //
	  //  {
	  //    'action': geo_action.zoom,  // an ongoing zoom event
	  //    ...
	  //  }
	  //
	  //  {
	  //    'action': geo_action.rotate,  // an ongoing rotate event
	  //    'origin': {...},      // mouse object at the start of the action
	  //    'delta': {x: *, y: *} // mouse movement since action start
	  //                          // not including the current event
	  //  }
	  //
	  //  {
	  //    'acton': geo_action.select,
	  //    'origin': {...},
	  //    'delta': {x: *, y: *}
	  //  }
	  //
	  //  {
	  //    'action': geo_action.momentum,
	  //    'origin': {...},
	  //    'handler': function () { }, // called in animation loop
	  //    'timer': animate loop timer
	  //  }
	  m_state = {};

	  /**
	   * Store queued map navigation commands (due to throttling) here
	   * {
	   *   kind: 'move' | 'wheel',  // what kind of mouse action triggered this
	   *   method: function () {},  // the throttled method
	   *   scroll: {x: ..., y: ...} // accumulated scroll wheel deltas
	   * }
	   */
	  m_queue = {};

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Connects events to a map.  If the map is not set, then this does nothing.
	   * @returns {geo.mapInteractor}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._connectEvents = function () {
	    if (!m_options.map) {
	      return m_this;
	    }

	    // prevent double binding to dom elements
	    m_this._disconnectEvents();

	    // store the connected element
	    $node = $(m_options.map.node());

	    // set methods related to asyncronous event handling
	    m_this._handleMouseWheel = throttled_wheel();
	    m_callZoom = debounced_zoom();

	    // add event handlers
	    $node.on('wheel.geojs', m_this._handleMouseWheel);
	    $node.on('mousemove.geojs', m_this._handleMouseMove);
	    $node.on('mousedown.geojs', m_this._handleMouseDown);
	    $node.on('mouseup.geojs', m_this._handleMouseUp);
	    // Disable dragging images and such
	    $node.on('dragstart', function () { return false; });
	    util.adjustActions(m_options.actions);
	    if (m_options.actions.some(function (action) {
	      return action.input.right;
	    })) {
	      $node.on('contextmenu.geojs', function () { return false; });
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Disonnects events to a map.  If the map is not set, then this does nothing.
	   * @returns {geo.mapInteractor}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._disconnectEvents = function () {
	    if ($node) {
	      $node.off('.geojs');
	      $node = null;
	    }
	    m_this._handleMouseWheel = function () {};
	    m_callZoom = function () {};
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Sets or gets map for this interactor, adds draw region layer if needed
	   *
	   * @param {geo.map} newMap optional
	   * @returns {geo.interactorStyle|geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.map = function (val) {
	    if (val !== undefined) {
	      m_options.map = val;
	      m_this._connectEvents();
	      return m_this;
	    }
	    return m_options.map;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Gets/sets the options object for the interactor.
	   *
	   * @param {object} opts optional
	   * @returns {geo.interactorStyle|object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.options = function (opts) {
	    if (opts === undefined) {
	      return $.extend({}, m_options);
	    }
	    $.extend(m_options, opts);

	    // reset event handlers for new options
	    this._connectEvents();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Stores the current mouse position from an event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._getMousePosition = function (evt) {
	    var offset = $node.offset(), dt, t;

	    t = (new Date()).valueOf();
	    dt = t - m_mouse.time;
	    m_mouse.time = t;
	    m_mouse.deltaTime = dt;
	    m_mouse.velocity = {
	      x: (evt.pageX - m_mouse.page.x) / dt,
	      y: (evt.pageY - m_mouse.page.y) / dt
	    };
	    m_mouse.page = {
	      x: evt.pageX,
	      y: evt.pageY
	    };
	    m_mouse.map = {
	      x: evt.pageX - offset.left,
	      y: evt.pageY - offset.top
	    };
	    try {
	      m_mouse.geo = m_this.map().displayToGcs(m_mouse.map);
	      m_mouse.mapgcs = m_this.map().displayToGcs(m_mouse.map, null);
	    } catch (e) {
	      // catch georeferencing problems and move on
	      // needed for handling the map before the base layer
	      // is attached
	      m_mouse.geo = m_mouse.mapgcs = null;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Stores the current mouse button
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._getMouseButton = function (evt) {
	    if (evt.which === 1) {
	      m_mouse.buttons.left = evt.type !== 'mouseup';
	    } else if (evt.which === 3) {
	      m_mouse.buttons.right = evt.type !== 'mouseup';
	    } else if (evt.which === 2) {
	      m_mouse.buttons.middle = evt.type !== 'mouseup';
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Stores the current keyboard modifiers
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._getMouseModifiers = function (evt) {
	    m_mouse.modifiers.alt = evt.altKey;
	    m_mouse.modifiers.ctrl = evt.ctrlKey;
	    m_mouse.modifiers.meta = evt.metaKey;
	    m_mouse.modifiers.shift = evt.shiftKey;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute a selection information object.
	   * @private
	   * @returns {object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._getSelection = function () {
	    var origin = m_state.origin,
	        mouse = m_this.mouse(),
	        map = m_this.map(),
	        display = {}, gcs = {};

	    // TODO: clamp to map bounds
	    // Get the display coordinates
	    display.upperLeft = {
	      x: Math.min(origin.map.x, mouse.map.x),
	      y: Math.min(origin.map.y, mouse.map.y)
	    };

	    display.lowerRight = {
	      x: Math.max(origin.map.x, mouse.map.x),
	      y: Math.max(origin.map.y, mouse.map.y)
	    };

	    display.upperRight = {
	      x: display.lowerRight.x,
	      y: display.upperLeft.y
	    };

	    display.lowerLeft = {
	      x: display.upperLeft.x,
	      y: display.lowerRight.y
	    };

	    // Get the gcs coordinates
	    gcs.upperLeft = map.displayToGcs(display.upperLeft, null);
	    gcs.lowerRight = map.displayToGcs(display.lowerRight, null);
	    gcs.upperRight = map.displayToGcs(display.upperRight, null);
	    gcs.lowerLeft = map.displayToGcs(display.lowerLeft, null);

	    m_selectionQuad.data([{
	      ul: gcs.upperLeft,
	      ur: gcs.upperRight,
	      ll: gcs.lowerLeft,
	      lr: gcs.lowerRight
	    }]);
	    m_selectionQuad.draw();

	    return {
	      display: display,
	      gcs: gcs,
	      mouse: mouse,
	      origin: $.extend({}, m_state.origin)
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Immediately cancel an ongoing action.
	   *
	   * @param {string?} action The action type, if null cancel any action
	   * @param {bool} keepQueue If truthy, keep the queue event if an action is
	   *                         canceled.
	   * @returns {bool} If an action was canceled
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.cancel = function (action, keepQueue) {
	    var out;
	    if (!action) {
	      out = !!m_state.action;
	    } else {
	      out = m_state.action === action;
	    }
	    if (out) {
	      // cancel any queued interaction events
	      if (!keepQueue) {
	        m_queue = {};
	      }
	      clearState();
	    }
	    return out;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set the value of whether a click is possible.  Cancel any outstanding
	   * timer for this process.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._setClickMaybe = function (value) {
	    m_clickMaybe = value;
	    if (m_clickMaybeTimeout) {
	      window.clearTimeout(m_clickMaybeTimeout);
	      m_clickMaybeTimeout = null;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle event when a mouse button is pressed
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseDown = function (evt) {
	    var action, actionRecord;

	    if (m_paused) {
	      return;
	    }

	    m_this._getMousePosition(evt);
	    m_this._getMouseButton(evt);
	    m_this._getMouseModifiers(evt);

	    if (m_options.click.enabled &&
	        (!m_mouse.buttons.left || m_options.click.buttons.left) &&
	        (!m_mouse.buttons.right || m_options.click.buttons.right) &&
	        (!m_mouse.buttons.middle || m_options.click.buttons.middle)) {
	      m_this._setClickMaybe({
	        x: m_mouse.page.x,
	        y: m_mouse.page.y,
	        buttons: $.extend({}, m_mouse.buttons)
	      });
	      if (m_options.click.duration > 0) {
	        m_clickMaybeTimeout = window.setTimeout(function () {
	          m_clickMaybe = false;
	          m_clickMaybeTimeout = null;
	        }, m_options.click.duration);
	      }
	    }
	    actionRecord = actionMatch(m_mouse.buttons, m_mouse.modifiers,
	                              m_options.actions);
	    action = (actionRecord || {}).action;

	    // cancel transitions and momentum on click
	    m_this.map().transitionCancel(
	        '_handleMouseDown' + (action ? '.' + action : ''));
	    m_this.cancel(geo_action.momentum);

	    m_mouse.velocity = {
	      x: 0,
	      y: 0
	    };

	    if (action) {
	      // cancel any ongoing interaction queue
	      m_queue = {
	        kind: 'move'
	      };

	      // store the state object
	      m_state = {
	        action: action,
	        actionRecord: actionRecord,
	        origin: $.extend(true, {}, m_mouse),
	        delta: {x: 0, y: 0}
	      };

	      if (actionRecord.selectionRectangle) {
	        // Make sure the old selection layer is gone.
	        if (m_selectionLayer) {
	          m_selectionLayer.clear();
	          m_this.map().deleteLayer(m_selectionLayer);
	          m_selectionLayer = null;
	        }
	        m_selectionLayer = m_this.map().createLayer(
	          'feature', {features: [quadFeature.capabilities.color]});
	        m_selectionQuad = m_selectionLayer.createFeature(
	          'quad', {gcs: m_this.map().gcs()});
	        m_selectionQuad.style({
	          opacity: 0.25,
	          color: {r: 0.3, g: 0.3, b: 0.3}
	        });
	        m_this.map().geoTrigger(geo_event.brushstart, m_this._getSelection());
	      }
	      m_this.map().geoTrigger(geo_event.actiondown, {
	        state: m_this.state(), mouse: m_this.mouse(), event: evt});

	      // bind temporary handlers to document
	      if (m_options.throttle > 0) {
	        $(document).on(
	          'mousemove.geojs',
	          throttle(
	            m_options.throttle,
	            m_this._handleMouseMoveDocument
	          )
	        );
	      } else {
	        $(document).on('mousemove.geojs', m_this._handleMouseMoveDocument);
	      }
	      $(document).on('mouseup.geojs', m_this._handleMouseUpDocument);
	      m_state.boundDocumentHandlers = true;
	    }

	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseMove = function (evt) {

	    if (m_paused) {
	      return;
	    }

	    if (m_state.boundDocumentHandlers) {
	      // If currently performing a navigation action, the mouse
	      // coordinates will be captured by the document handler.
	      return;
	    }

	    if (m_options.click.cancelOnMove && m_clickMaybe) {
	      m_this._setClickMaybe(false);
	    }

	    m_this._getMousePosition(evt);
	    m_this._getMouseButton(evt);
	    m_this._getMouseModifiers(evt);

	    if (m_clickMaybe) {
	      return;
	    }

	    m_this.map().geoTrigger(geo_event.mousemove, m_this.mouse());
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse move event on the document (temporary bindings)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseMoveDocument = function (evt) {
	    var dx, dy, selectionObj;

	    // If the map has been disconnected, we do nothing.
	    if (!m_this.map()) {
	      return;
	    }

	    if (m_paused || m_queue.kind !== 'move') {
	      return;
	    }

	    m_this._getMousePosition(evt);
	    m_this._getMouseButton(evt);
	    m_this._getMouseModifiers(evt);

	    /* Only cancel possible clicks on move if we actually moved */
	    if (m_options.click.cancelOnMove && (m_clickMaybe.x === undefined ||
	        m_mouse.page.x !== m_clickMaybe.x ||
	        m_mouse.page.y !== m_clickMaybe.y)) {
	      m_this._setClickMaybe(false);
	    }
	    if (m_clickMaybe) {
	      return;
	    }

	    if (!m_state.action) {
	      // This shouldn't happen
	      console.log('WARNING: Invalid state in mapInteractor.');
	      return;
	    }

	    // calculate the delta from the origin point to avoid
	    // accumulation of floating point errors
	    dx = m_mouse.map.x - m_state.origin.map.x - m_state.delta.x;
	    dy = m_mouse.map.y - m_state.origin.map.y - m_state.delta.y;
	    m_state.delta.x += dx;
	    m_state.delta.y += dy;

	    if (m_state.action === geo_action.pan) {
	      m_this.map().pan({x: dx, y: dy}, undefined, 'limited');
	    } else if (m_state.action === geo_action.zoom) {
	      m_callZoom(-dy * m_options.zoomScale / 120, m_state);
	    } else if (m_state.action === geo_action.rotate) {
	      var cx, cy;
	      if (m_state.origin.rotation === undefined) {
	        cx = m_state.origin.map.x - m_this.map().size().width / 2;
	        cy = m_state.origin.map.y - m_this.map().size().height / 2;
	        m_state.origin.rotation = m_this.map().rotation() - Math.atan2(cy, cx);
	      }
	      cx = m_mouse.map.x - m_this.map().size().width / 2;
	      cy = m_mouse.map.y - m_this.map().size().height / 2;
	      m_this.map().rotation(m_state.origin.rotation + Math.atan2(cy, cx));
	    } else if (m_state.actionRecord.selectionRectangle) {
	      // Get the bounds of the current selection
	      selectionObj = m_this._getSelection();
	      m_this.map().geoTrigger(geo_event.brush, selectionObj);
	    }
	    m_this.map().geoTrigger(geo_event.actionmove, {
	      state: m_this.state(), mouse: m_this.mouse(), event: evt});

	    // Prevent default to stop text selection in particular
	    evt.preventDefault();
	  };

	  /**
	   * Clear the action state, but remember if we have bound document handlers.
	   * @private
	   */
	  function clearState() {
	    m_state = {boundDocumentHandlers: m_state.boundDocumentHandlers};
	  }

	  /**
	   * Use interactor options to modify the mouse velocity by momentum
	   * or spring equations depending on the current map state.
	   * @private
	   * @param {object} v Current velocity in pixels / ms
	   * @param {number} deltaT The time delta
	   * @returns {object} New velocity
	   */
	  function modifyVelocity(v, deltaT) {
	    deltaT = deltaT <= 0 ? 30 : deltaT;
	    var sf = springForce();
	    var speed = calcSpeed(v);
	    var vx = v.x / speed;
	    var vy = v.y / speed;

	    speed = speed * Math.exp(-m_options.momentum.drag * deltaT);

	    // |force| + |velocity| < c <- stopping condition
	    if (calcSpeed(sf) * deltaT + speed < m_options.momentum.minSpeed) {
	      return null;
	    }

	    if (speed > 0) {
	      vx = vx * speed;
	      vy = vy * speed;
	    } else {
	      vx = 0;
	      vy = 0;
	    }

	    return {
	      x: vx - sf.x * deltaT,
	      y: vy - sf.y * deltaT
	    };
	  }

	  /**
	   * Get the spring force for the current map bounds
	   * @private
	   * @returns {object} The spring force
	   */
	  function springForce() {
	    var xplus,  // force to the right
	        xminus, // force to the left
	        yplus,  // force to the top
	        yminus; // force to the bottom

	    if (!m_options.spring.enabled) {
	      return {x: 0, y: 0};
	    }
	    // get screen coordinates of corners
	    var maxBounds = m_this.map().maxBounds(undefined, null);
	    var ul = m_this.map().gcsToDisplay({
	      x: maxBounds.left,
	      y: maxBounds.top
	    }, null);
	    var lr = m_this.map().gcsToDisplay({
	      x: maxBounds.right,
	      y: maxBounds.bottom
	    }, null);

	    var c = m_options.spring.springConstant;
	    // Arg... map needs to expose the canvas size
	    var width = m_this.map().node().width();
	    var height = m_this.map().node().height();

	    xplus = c * Math.max(0, ul.x);
	    xminus = c * Math.max(0, width - lr.x);
	    yplus = c * Math.max(0, ul.y) / 2;
	    yminus = c * Math.max(0, height - lr.y) / 2;

	    return {
	      x: xplus - xminus,
	      y: yplus - yminus
	    };
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Based on the screen coodinates of a selection, zoom or unzoom and
	   * recenter.
	   *
	   * @private
	   * @param {string} action Either geo_action.zoomselect or
	   *    geo_action.unzoomselect.
	   * @param {object} lowerLeft the x and y coordinates of the lower left corner
	   *    of the zoom rectangle.
	   * @param {object} upperRight the x and y coordinates of the upper right
	   *    corner of the zoom rectangle.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._zoomFromSelection = function (action, lowerLeft, upperRight) {
	    if (action !== geo_action.zoomselect && action !== geo_action.unzoomselect) {
	      return;
	    }
	    if (lowerLeft.x === upperRight.x || lowerLeft.y === upperRight.y) {
	      return;
	    }
	    var zoom, center,
	        map = m_this.map(),
	        mapsize = map.size();
	    /* To arbitrarily handle rotation and projection, we center the map at the
	     * central coordinate of the selection and set the zoom level such that the
	     * four corners are just barely on the map.  When unzooming (zooming out),
	     * we ensure that the previous view is centered in the selection but use
	     * the maximal size for the zoom factor. */
	    var scaling = {
	      x: Math.abs((upperRight.x - lowerLeft.x) / mapsize.width),
	      y: Math.abs((upperRight.y - lowerLeft.y) / mapsize.height)
	    };
	    if (action === geo_action.zoomselect) {
	      center = map.displayToGcs({
	        x: (lowerLeft.x + upperRight.x) / 2,
	        y: (lowerLeft.y + upperRight.y) / 2
	      }, null);
	      zoom = map.zoom() - Math.log2(Math.max(scaling.x, scaling.y));
	    } else {  /* unzoom */
	      /* To make the existing visible map entirely within the selection
	       * rectangle, this would be changed to Math.min instead of Math.max of
	       * the scaling factors.  This felt wrong, though. */
	      zoom = map.zoom() + Math.log2(Math.max(scaling.x, scaling.y));
	      /* Record the current center.  Later, this is panned to the center of the
	       * selection rectangle. */
	      center = map.center(undefined, null);
	    }
	    /* When discrete zoom is enable, always round down.  We have to do this
	     * explicitly, as otherwise we may zoom too far and the selection will not
	     * be completely visible. */
	    if (map.discreteZoom()) {
	      zoom = Math.floor(zoom);
	    }
	    map.zoom(zoom);
	    if (action === geo_action.zoomselect) {
	      map.center(center, null);
	    } else {
	      var newcenter = map.gcsToDisplay(center, null);
	      map.pan({
	        x: (lowerLeft.x + upperRight.x) / 2 - newcenter.x,
	        y: (lowerLeft.y + upperRight.y) / 2 - newcenter.y
	      });
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle event when a mouse button is unpressed on the document.
	   * Removes temporary bindings.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseUpDocument = function (evt) {
	    var selectionObj, oldAction;

	    if (m_paused) {
	      return;
	    }

	    // cancel queued interactions
	    m_queue = {};

	    m_this._setClickMaybe(false);
	    m_this._getMouseButton(evt);
	    m_this._getMouseModifiers(evt);

	    // unbind temporary handlers on document
	    $(document).off('.geojs');
	    m_state.boundDocumentHandlers = false;

	    if (m_mouse.buttons.right) {
	      evt.preventDefault();
	    }

	    if (m_state.actionRecord && m_state.actionRecord.selectionRectangle) {
	      m_this._getMousePosition(evt);
	      selectionObj = m_this._getSelection();

	      m_selectionLayer.clear();
	      m_this.map().deleteLayer(m_selectionLayer);
	      m_selectionLayer = null;
	      m_selectionQuad = null;

	      m_this.map().geoTrigger(geo_event.brushend, selectionObj);
	      if (m_state.actionRecord.selectionRectangle !== true) {
	        m_this.map().geoTrigger(m_state.actionRecord.selectionRectangle,
	                                selectionObj);
	      }
	      m_this._zoomFromSelection(m_state.action, selectionObj.display.lowerLeft,
	                                selectionObj.display.upperRight);
	      m_this.map().geoTrigger(geo_event.actionselection, {
	        state: m_this.state(), mouse: m_this.mouse(), event: evt,
	        lowerLeft: selectionObj.display.lowerLeft,
	        upperRight: selectionObj.display.upperRight});
	    }
	    m_this.map().geoTrigger(geo_event.actionup, {
	      state: m_this.state(), mouse: m_this.mouse(), event: evt});

	    // reset the interactor state
	    oldAction = m_state.action;
	    clearState();

	    // if momentum is enabled, start the action here
	    if (m_options.momentum.enabled &&
	            $.inArray(oldAction, m_options.momentum.actions) >= 0) {
	      var t = (new Date()).valueOf();
	      var dt = t - m_mouse.time + m_mouse.deltaTime;
	      if (t - m_mouse.time < m_options.momentum.stopTime) {
	        m_mouse.velocity.x *= m_mouse.deltaTime / dt;
	        m_mouse.velocity.y *= m_mouse.deltaTime / dt;
	        m_mouse.deltaTime = dt;
	      } else {
	        m_mouse.velocity.x = m_mouse.velocity.y = 0;
	      }
	      m_this.springBack(true, oldAction);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle event when a mouse button is unpressed
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseUp = function (evt) {
	    if (m_paused) {
	      return;
	    }

	    m_this._getMouseButton(evt);

	    if (m_clickMaybe) {
	      m_this._handleMouseClick(evt);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle event when a mouse click is detected.  A mouse click is a simulated
	   * event that occurs when the time between a mouse down and mouse up
	   * is less than the configured duration and (optionally) if no mousemove
	   * events were triggered in the interim.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseClick = function (evt) {

	    /* Cancel a selection if it is occurring */
	    if (m_state.actionRecord && m_state.actionRecord.selectionRectangle) {
	      m_selectionLayer.clear();
	      m_this.map().deleteLayer(m_selectionLayer);
	      m_selectionLayer = null;
	      m_selectionQuad = null;
	      m_state.action = m_state.actionRecord = null;
	    }
	    m_this._getMouseButton(evt);
	    m_this._getMouseModifiers(evt);

	    // cancel any ongoing pan action
	    m_this.cancel(geo_action.pan);

	    // unbind temporary handlers on document
	    $(document).off('.geojs');
	    m_state.boundDocumentHandlers = false;
	    // add information about the button state to the event information
	    var details = m_this.mouse();
	    details.buttonsDown = m_clickMaybe.buttons;

	    // reset click detector variable
	    m_this._setClickMaybe(false);
	    // fire a click event
	    m_this.map().geoTrigger(geo_event.mouseclick, details);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private wrapper around the map zoom method that is debounced to support
	   * discrete zoom interactions.
	   * @param {number} deltaZ The zoom increment
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function debounced_zoom() {
	    var deltaZ = 0, delay = 400, origin, startZoom, targetZoom;

	    function accum(dz, org) {
	      var map = m_this.map(), zoom;

	      origin = $.extend(true, {}, org);
	      deltaZ += dz;
	      if (targetZoom === undefined) {
	        startZoom = targetZoom = map.zoom();
	      }
	      targetZoom += dz;

	      // Respond to debounced events when they add up to a change in the
	      // discrete zoom level.
	      if (map && Math.abs(deltaZ) >= 1 && m_options.discreteZoom &&
	            !m_options.zoomAnimation.enabled) {

	        zoom = Math.round(deltaZ + map.zoom());

	        // delta is what is left over from the zoom delta after the new zoom
	        // value
	        deltaZ = deltaZ + map.zoom() - zoom;

	        map.zoom(zoom, origin);
	      }

	    }

	    function apply() {
	      var map = m_this.map(), zoom;
	      if (map) {
	        if (m_options.zoomAnimation.enabled) {
	          zoom = targetZoom;
	          if (m_options.discreteZoom) {
	            zoom = Math.round(zoom);
	            if (zoom === startZoom && targetZoom !== startZoom) {
	              zoom = startZoom + (targetZoom > startZoom ? 1 : -1);
	            }
	          }
	          map.transitionCancel('debounced_zoom.' + geo_action.zoom);
	          map.transition({
	            zoom: zoom,
	            zoomOrigin: origin,
	            duration: m_options.zoomAnimation.duration,
	            ease: m_options.zoomAnimation.ease,
	            done: function (status) {
	              status = status || {};
	              var zoomRE = new RegExp('\\.' + geo_action.zoom + '$');
	              if (!status.next && (!status.cancel ||
	                  ('' + status.source).search(zoomRE) < 0)) {
	                targetZoom = undefined;
	              }
	              /* If we were animating the zoom, if the zoom is continuous, just
	               * stop where we are.  If using discrete zoom, we need to make
	               * sure we end up discrete.  However, we don't want to do that if
	               * the next action is further zooming. */
	              if (m_options.discreteZoom && status.cancel &&
	                  status.transition && status.transition.end &&
	                  ('' + status.source).search(zoomRE) < 0) {
	                map.zoom(status.transition.end.zoom,
	                         status.transition.end.zoomOrigin);
	              }
	            }
	          });
	        } else {
	          zoom = deltaZ + map.zoom();
	          if (m_options.discreteZoom) {
	            // round off the zoom to an integer and throw away the rest
	            zoom = Math.round(zoom);
	          }
	          map.zoom(zoom, origin);
	        }
	      }
	      deltaZ = 0;
	    }

	    if (m_options.discreteZoom !== true && m_options.discreteZoom > 0) {
	      delay = m_options.discreteZoom;
	    }
	    if ((m_options.discreteZoom === true || m_options.discreteZoom > 0) &&
	            !m_options.zoomAnimation.enabled) {
	      return debounce(delay, false, apply, accum);
	    } else {
	      return function (dz, org) {
	        if (!dz && targetZoom === undefined) {
	          return;
	        }
	        accum(dz, org);
	        apply(dz, org);
	      };
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Attaches wrapped methods for accumulating fast mouse wheel events and
	   * throttling map interactions.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function throttled_wheel() {
	    var my_queue = {};

	    function accum(evt) {
	      var dx, dy;

	      if (m_paused) {
	        return;
	      }

	      if (my_queue !== m_queue) {
	        my_queue = {
	          kind: 'wheel',
	          scroll: {x: 0, y: 0}
	        };
	        m_queue = my_queue;
	      }

	      evt.preventDefault();

	      // try to normalize deltas using the wheel event standard:
	      //   https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
	      evt.deltaFactor = 1;
	      if (evt.originalEvent.deltaMode === 1) {
	        // DOM_DELTA_LINE -- estimate line height
	        evt.deltaFactor = 40;
	      } else if (evt.originalEvent.deltaMode === 2) {
	        // DOM_DELTA_PAGE -- get window height
	        evt.deltaFactor = $(window).height();
	      }

	      // prevent NaN's on legacy browsers
	      dx = evt.originalEvent.deltaX || 0;
	      dy = evt.originalEvent.deltaY || 0;

	      // scale according to the options
	      dx = dx * m_options.wheelScaleX * evt.deltaFactor / 120;
	      dy = dy * m_options.wheelScaleY * evt.deltaFactor / 120;

	      my_queue.scroll.x += dx;
	      my_queue.scroll.y += dy;
	    }

	    function wheel(evt) {
	      var zoomFactor, action, actionRecord;

	      // If the current queue doesn't match the queue passed in as an argument,
	      // assume it was cancelled and do nothing.
	      if (my_queue !== m_queue) {
	        return;
	      }

	      // perform the map navigation event
	      m_this._getMouseModifiers(evt);

	      actionRecord = actionMatch({wheel: true}, m_mouse.modifiers,
	                                m_options.actions);
	      action = (actionRecord || {}).action;

	      if (action) {
	        // if we were moving because of momentum or a transition, cancel it and
	        // recompute where the mouse action is occuring.
	        var recompute = m_this.map().transitionCancel('wheel.' + action);
	        recompute |= m_this.cancel(geo_action.momentum, true);
	        if (recompute) {
	          m_mouse.geo = m_this.map().displayToGcs(m_mouse.map);
	          m_mouse.mapgcs = m_this.map().displayToGcs(m_mouse.map, null);
	        }
	        switch (action) {
	          case geo_action.pan:
	            m_this.map().pan({
	              x: m_queue.scroll.x,
	              y: m_queue.scroll.y
	            }, undefined, 'limited');
	            break;
	          case geo_action.zoom:
	            zoomFactor = -m_queue.scroll.y;
	            m_callZoom(zoomFactor, m_mouse);
	            break;
	          case geo_action.rotate:
	            m_this.map().rotation(
	                m_this.map().rotation() +
	                m_queue.scroll.y * m_options.rotateWheelScale,
	                m_mouse);
	            break;
	        }
	        m_this.map().geoTrigger(geo_event.actionwheel, {
	          state: m_this.state(), mouse: m_this.mouse(), event: evt});
	      }

	      // reset the queue
	      m_queue = {};
	    }

	    if (m_options.throttle > 0) {
	      return throttle(m_options.throttle, false, wheel, accum);
	    } else {
	      return function (evt) {
	        accum(evt);
	        wheel(evt);
	      };
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle mouse wheel event.  (Defined inside _connectEvents).
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleMouseWheel = function () {};

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Start up a spring back action when the map bounds are out of range.
	   * Not to be user callable.
	   * @todo Move this and momentum handling to the map class
	   * @protected
	   *
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.springBack = function (initialVelocity, origAction) {
	    if (m_state.action === geo_action.momentum) {
	      return;
	    }
	    if (!initialVelocity) {
	      m_mouse.velocity = {
	        x: 0,
	        y: 0
	      };
	    }
	    m_state.origAction = origAction;
	    m_state.action = geo_action.momentum;
	    m_state.origin = m_this.mouse();
	    m_state.momentum = m_this.mouse();
	    m_state.start = new Date();
	    m_state.handler = function () {
	      var v, s, last, dt;

	      if (m_state.action !== geo_action.momentum ||
	          !m_this.map() ||
	          m_this.map().transition()) {
	        // cancel if a new action was performed
	        return;
	      }
	      // Not sure the correct way to do this.  We need the delta t for the
	      // next time step...  Maybe use a better interpolator and the time
	      // parameter from requestAnimationFrame.
	      dt = Math.min(m_state.momentum.deltaTime, 30);

	      last = m_state.start.valueOf();
	      m_state.start = new Date();

	      v = modifyVelocity(m_state.momentum.velocity, m_state.start - last);

	      // stop panning when the speed is below the threshold
	      if (!v) {
	        clearState();
	        return;
	      }

	      s = calcSpeed(v);
	      if (s > m_options.momentum.maxSpeed) {
	        s = m_options.momentum.maxSpeed / s;
	        v.x = v.x * s;
	        v.y = v.y * s;
	      }

	      if (!isFinite(v.x) || !isFinite(v.y)) {
	        v.x = 0;
	        v.y = 0;
	      }
	      m_state.momentum.velocity.x = v.x;
	      m_state.momentum.velocity.y = v.y;

	      switch (m_state.origAction) {
	        case geo_action.zoom:
	          var dy = m_state.momentum.velocity.y * dt;
	          m_callZoom(-dy * m_options.zoomScale / 120, m_state);
	          break;
	        default:
	          m_this.map().pan({
	            x: m_state.momentum.velocity.x * dt,
	            y: m_state.momentum.velocity.y * dt
	          }, undefined, 'limited');
	          break;
	      }

	      if (m_state.handler) {
	        window.requestAnimationFrame(m_state.handler);
	      }
	    };
	    if (m_state.handler) {
	      window.requestAnimationFrame(m_state.handler);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle double click event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._handleDoubleClick = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Public method that unbinds all events
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.destroy = function () {
	    m_this._disconnectEvents();
	    m_this.map(null);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get current mouse information
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.mouse = function () {
	    return $.extend(true, {}, m_mouse);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get current keyboard information
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.keyboard = function () {
	    return $.extend(true, {}, m_keyboard);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the current interactor state
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.state = function () {
	    return $.extend(true, {}, m_state);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the pause state of the interactor, which
	   * ignores all native mouse and keyboard events.
	   *
	   * @param {bool} [value] The pause state to set or undefined to return the
	   *                        current state.
	   * @returns {bool|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pause = function (value) {
	    if (value === undefined) {
	      return m_paused;
	    }
	    m_paused = !!value;
	    return m_this;
	  };

	  /**
	   * Add an action to the list of handled actions.
	   *
	   * @param {object} action: an object defining the action.  This must have
	   *    action and input properties, and may have modifiers, name, and owner.
	   *    Use action, name, and owner to make this entry distinct if it will need
	   *    to be removed later.
	   * @param {boolean} toEnd: the action is added at the beginning of the
	   *    actions list unless toEnd is true.  Earlier actions prevent later
	   *    actions with the similar input and modifiers.
	   */
	  this.addAction = function (action, toEnd) {
	    if (!action || !action.action || !action.input) {
	      return;
	    }
	    util.addAction(m_options.actions, action, toEnd);
	    if (m_options.map && m_options.actions.some(function (action) {
	      return action.input.right;
	    })) {
	      $node.off('contextmenu.geojs');
	      $node.on('contextmenu.geojs', function () { return false; });
	    }
	  };

	  /**
	   * Check if an action is in the actions list.  An action matches if the
	   * action, name, and owner match.  A null or undefined value will match all
	   * actions.  If using an action object, this is the same as passing
	   * (action.action, action.name, action.owner).
	   *
	   * @param {object|string} action Either an action object or the name of an
	   *    action.
	   * @param {string} name Optional name associated with the action.
	   * @param {string} owner Optional owner associated with the action.
	   * @return action the first matching action or null.
	   */
	  this.hasAction = function (action, name, owner) {
	    return util.hasAction(m_options.actions, action, name, owner);
	  };

	  /**
	   * Remove all matching actions.  Actions are matched as with hasAction.
	   *
	   * @param {object|string} action Either an action object or the name of an
	   *    action.
	   * @param {string} name Optional name associated with the action.
	   * @param {string} owner Optional owner associated with the action.
	   * @return numRemoved the number of actions that were removed.
	   */
	  this.removeAction = function (action, name, owner) {
	    var removed = util.removeAction(
	        m_options.actions, action, name, owner);
	    if (m_options.map && !m_options.actions.some(function (action) {
	      return action.input.right;
	    })) {
	      $node.off('contextmenu.geojs');
	    }
	    return removed;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Simulate a DOM mouse event on connected map.
	   *
	   * The options for creating the events are as follows, not all
	   * options are required for every event type. ::
	   *
	   *   options = {
	   *     page: {x, y} // position on the page
	   *     map: {x, y}  // position on the map (overrides page)
	   *     button: 'left' | 'right' | 'middle'
	   *     modifiers: [ 'alt' | 'ctrl' | 'meta' | 'shift' ]
	   *     wheelDelta: {x, y}
	   *   }
	   *
	   * @param {string} type Event type 'mousemove', 'mousedown', 'mouseup', ...
	   * @param {object} options
	   * @returns {mapInteractor}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.simulateEvent = function (type, options) {
	    var evt, page, offset, which;

	    if (!m_this.map()) {
	      return m_this;
	    }

	    page = options.page || {};

	    if (options.map) {
	      offset = $node.offset();
	      page.x = options.map.x + offset.left;
	      page.y = options.map.y + offset.top;
	    }

	    if (options.button === 'left') {
	      which = 1;
	    } else if (options.button === 'right') {
	      which = 3;
	    } else if (options.button === 'middle') {
	      which = 2;
	    }

	    options.modifiers = options.modifiers || [];
	    options.wheelDelta = options.wheelDelta || {};

	    evt = $.Event(
	      type,
	      {
	        pageX: page.x,
	        pageY: page.y,
	        which: which,
	        altKey: options.modifiers.indexOf('alt') >= 0,
	        ctrlKey: options.modifiers.indexOf('ctrl') >= 0,
	        metaKey: options.modifiers.indexOf('meta') >= 0,
	        shiftKey: options.modifiers.indexOf('shift') >= 0,
	        originalEvent: {
	          deltaX: options.wheelDelta.x,
	          deltaY: options.wheelDelta.y,
	          deltaMode: options.wheelMode,
	          preventDefault: function () {},
	          stopPropagation: function () {},
	          stopImmediatePropagation: function () {}
	        }
	      }
	    );
	    $node.trigger(evt);
	    if (type.indexOf('.geojs') >= 0) {
	      $(document).trigger(evt);
	    }
	  };
	  this._connectEvents();
	  return this;
	};

	inherit(mapInteractor, object);
	module.exports = mapInteractor;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class quadFeature
	 *
	 * @class geo.quadFeature
	 * @param {Object} arg Options object
	 * @extends geo.feature
	 * @param {Object|string|Function} [color] Color for quads without images.
	 *   Default is white ({r: 1, g: 1, b: 1}).
	 * @param {number|Function} [opacity=1] Opacity for quad
	 * @param {number|Function} [depth=0] Default z-coordinate for positions that
	 *   don't explicitly specify one.
	 * @param {boolean|Function} [drawOnAsyncResourceLoaded=true] Redraw quads
	 *   when images are loaded after initial render.
	 * @param {Image|string|Function} [image] Image for each data item.  If
	 *   undefined or null, the quad is a solid color.  Default is (data).image.
	 * @param {Object|string|Function} [previewColor=null] If specified, a color to
	 *   show on image quads while waiting for the image to load.
	 * @param {Image|string|Function} [previewImage=null] If specified, an image to
	 *   show on image quads while waiting for the quad-specific image to load.
	 *   This will only be shown if it is already loaded.
	 * @param {Object|Function} [position] Position of the quad.  Default is
	 *   (data).  The position is an Object which specifies the corners of the
	 *   quad: ll, lr, ur, ul.  At least two opposite corners must be specified.
	 *   The corners do not have to physically correspond to the order specified,
	 *   but rather correspond to that part of an image (if there is one).  If a
	 *   corner is unspecified, it will use the x coordinate from one adjacent
	 *   corner, the y coordinate from the other adjacent corner, and the average
	 *   z value of those two corners.  For instance, if ul is unspecified, it is
	 *   {x: ll.x, y: ur.y}.  Note that each quad is rendered as a pair of
	 *   triangles: (ll, lr, ul) and (ur, ul, lr).  Nothing special is done for
	 *   quads that are not convex or quads that have substantially different
	 *   transformations for those two triangles.
	 * @param {boolean} [cacheQuads=true] If true, a set of internal information is
	 *   stored on each data item in the _cachedQuad attribute.  If this is false,
	 *   the data item is not altered.  If the data (positions, opacity, etc,) of
	 *   individual quads will change, set this to false or delete the _cachedQuad
	 *   attribute of the data item.
	 * @returns {geo.quadFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var quadFeature = function (arg) {
	  'use strict';

	  var transform = __webpack_require__(6);
	  var util = __webpack_require__(196);

	  if (!(this instanceof quadFeature)) {
	    return new quadFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      m_cacheQuads,
	      m_nextQuadId = 0,
	      m_images = [],
	      m_quads;

	  /**
	   * Track a list of object->object mappings.  The mappings are kept in a list.
	   * This marks all known mappings as unused.  If they are not marked used
	   * before _objectListEnd is called, that function will remove them.
	   *
	   * @param {array} list the list of mappings.
	   */
	  this._objectListStart = function (list) {
	    $.each(list, function (idx, item) {
	      item.used = false;
	    });
	  };

	  /**
	   * Get the value from a list of object->object mappings.  If the key object
	   * is not present, return undefined.  If found, the entry is marked as being
	   * in use.
	   *
	   * @param {array} list the list of mappings.
	   * @param {object} entry the key to search for.
	   * @returns {object} the associated object or undefined.
	   */
	  this._objectListGet = function (list, entry) {
	    for (var i = 0; i < list.length; i += 1) {
	      if (list[i].entry === entry) {
	        list[i].used = true;
	        return list[i].value;
	      }
	    }
	    return undefined;
	  };

	  /**
	   * Add a new object to a list of object->object mappings.  The key object
	   * should not exist, or this will create a duplicate.  The new entry is
	   * marked as being in use.
	   *
	   * @param {array} list the list of mappings.
	   * @param {object} entry the key to add.
	   * @param {object} value the value to store with the entry.
	   */
	  this._objectListAdd = function (list, entry, value) {
	    list.push({entry: entry, value: value, used: true});
	  };

	  /**
	   * Remove all unused entries from a list of object->object mappings.
	   *
	   * @param {array} list the list of mappings.
	   */
	  this._objectListEnd = function (list) {
	    for (var i = list.length - 1; i >= 0; i -= 1) {
	      if (!list[i].used) {
	        list.splice(i, 1);
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Point search method for selection api.  Returns markers containing the
	   * given point.
	   *
	   * @memberof geo.quadFeature
	   * @param {Object} coordinate coordinate in input gcs to check if it is
	   *    located in any quad.
	   * @returns {Object} an object with 'index': a list of quad indices, and
	   *    'found': a list of quads that contain the specified coordinate.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pointSearch = function (coordinate) {
	    var found = [], indices = [], data = m_this.data(), i,
	        poly1 = [{}, {}, {}, {}], poly2 = [{}, {}, {}, {}],
	        map = m_this.layer().map(),
	        order1 = [0, 1, 2, 0], order2 = [1, 2, 3, 1];
	    coordinate = transform.transformCoordinates(
	        map.ingcs(), map.gcs(), coordinate);
	    if (!m_quads) {
	      this._generateQuads();
	    }
	    $.each([m_quads.clrQuads, m_quads.imgQuads], function (idx, quadList) {
	      quadList.forEach(function (quad, idx) {
	        for (i = 0; i < order1.length; i += 1) {
	          poly1[i].x = quad.pos[order1[i] * 3];
	          poly1[i].y = quad.pos[order1[i] * 3 + 1];
	          poly1[i].z = quad.pos[order1[i] * 3 + 2];
	          poly2[i].x = quad.pos[order2[i] * 3];
	          poly2[i].y = quad.pos[order2[i] * 3 + 1];
	          poly2[i].z = quad.pos[order2[i] * 3 + 2];
	        }
	        if (util.pointInPolygon(coordinate, poly1) ||
	            util.pointInPolygon(coordinate, poly2)) {
	          indices.push(quad.idx);
	          found.push(data[quad.idx]);
	        }
	      });
	    });
	    return {
	      index: indices,
	      found: found
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set position
	   *
	   * @memberof geo.quadFeature
	   * @param {object|function} [position] object or function that returns the
	   *    position of each quad.
	   * @returns {geo.quadFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_this.style('position');
	    } else {
	      m_this.style('position', util.ensureFunction(val));
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  /**
	   * Given a data item and its index, fetch its position and ensure we have
	   * complete information for the quad.  This generates missing corners and z
	   * values.
	   *
	   * @param {function} posFunc a function to call to get the position of a data
	   *   item.  It is passed (d, i).
	   * @param {function} depthFunc a function to call to get the z-value of a
	   *   data item.  It is passed (d, i).
	   * @param d a data item.  Used to fetch position and possibly depth.
	   * @param i the index within the data.  Used to fetch position and possibly
	   *   depth.
	   * @returns {Object|undefined} either an object with all four corners, or
	   *   undefined if no such object can be generated.  The coordinates have been
	   *   converted to map coordinates.
	   */
	  this._positionToQuad = function (posFunc, depthFunc, d, i) {
	    var initPos = posFunc.call(m_this, d, i);
	    if ((!initPos.ll || !initPos.ur) && (!initPos.ul || !initPos.lr)) {
	      return;
	    }
	    var gcs = m_this.gcs(),
	        map_gcs = m_this.layer().map().gcs(),
	        pos = {};
	    $.each(['ll', 'lr', 'ul', 'ur'], function (idx, key) {
	      if (initPos[key] !== undefined) {
	        pos[key] = {};
	        if (initPos[key].x === undefined) {
	          pos[key] = [initPos[key][0], initPos[key][1], initPos[key][2]];
	        } else {
	          pos[key] = [initPos[key].x, initPos[key].y, initPos[key].z];
	        }
	        if (pos[key][2] === undefined) {
	          pos[key][2] = depthFunc.call(m_this, d, i);
	        }
	        if (gcs !== map_gcs && gcs !== false) {
	          pos[key] = transform.transformCoordinates(
	              gcs, map_gcs, pos[key]);
	        }
	      }
	    });
	    pos.ll = pos.ll || [pos.ul[0], pos.lr[1], (pos.ul[2] + pos.lr[2]) / 2];
	    pos.lr = pos.lr || [pos.ur[0], pos.ll[1], (pos.ur[2] + pos.ll[2]) / 2];
	    pos.ur = pos.ur || [pos.lr[0], pos.ul[1], (pos.lr[2] + pos.ul[2]) / 2];
	    pos.ul = pos.ul || [pos.ll[0], pos.ur[1], (pos.ll[2] + pos.ur[2]) / 2];
	    return pos;
	  };

	  /**
	   * Convert the current data set to a pair of arrays, one of quads that are
	   * solid color and one of qudas that have an image.  All quads are objects
	   * with pos (a 12 value array containing 4 three-dimensional position
	   * coordinates), and opacity.  Color quads also have a color.  Image quads
	   * may have an image element, if the image is loaded.  If it isn't, this
	   * element will be missing.  For preview images, the image quad will have a
	   * reference to the preview element that may later be removed.  If a preview
	   * color is used, the quad will be in both lists, but may be removed from the
	   * color quad list once the image is loaded.
	   *
	   * The value for origin is one of an ll corner from one of the quads with the
	   * smallest sum of diagonals.  The assumption is that, if using the origin to
	   * improve precision, the smallest quads are the ones most in need of this
	   * benefit.
	   *
	   * @returns {Object} An object with clrQuads and imgQuads, each of which is
	   *   an array, and origin, which is a triplet that is guaranteed to be one of
	   *   the quads corners for a quad with the smallest sum of diagonal lengths.
	   */
	  this._generateQuads = function () {
	    var posFunc = m_this.position(),
	        imgFunc = util.ensureFunction(m_this.style('image')),
	        colorFunc = util.ensureFunction(m_this.style('color')),
	        depthFunc = util.ensureFunction(m_this.style('depth')),
	        opacityFunc = util.ensureFunction(m_this.style('opacity')),
	        loadedFunc = util.ensureFunction(m_this.style(
	            'drawOnAsyncResourceLoaded')),
	        previewColorFunc = util.ensureFunction(m_this.style(
	            'previewColor')),
	        previewImageFunc = util.ensureFunction(m_this.style(
	            'previewImage')),
	        data = m_this.data(),
	        clrQuads = [], imgQuads = [],
	        origin = [0, 0, 0], origindiag2, diag2;
	    /* Keep track of images that we are using.  This prevents creating
	     * additional Image elemnts for repeated urls. */
	    m_this._objectListStart(m_images);
	    $.each(data, function (i, d) {
	      if (d._cachedQuad) {
	        diag2 = d._cachedQuad.diag2;
	        if (origindiag2 === undefined || (d._cachedQuad.diag2 &&
	            d._cachedQuad.diag2 < origindiag2)) {
	          origin = d._cachedQuad.ll;
	          origindiag2 = d._cachedQuad.diag2;
	        }
	        if (d._cachedQuad.clrquad) {
	          clrQuads.push(d._cachedQuad.clrquad);
	        }
	        if (d._cachedQuad.imgquad) {
	          imgQuads.push(d._cachedQuad.imgquad);
	        }
	        return;
	      }
	      var quad, reload, image, prev_onload,
	          pos, img, opacity, previewColor, previewImage, quadinfo = {};

	      pos = m_this._positionToQuad(posFunc, depthFunc, d, i);
	      opacity = opacityFunc.call(m_this, d, i);
	      if (pos === undefined || !opacity) {
	        return;
	      }
	      diag2 = Math.pow(pos.ll[0] - pos.ur[0], 2) + Math.pow(pos.ll[1] -
	          pos.ur[1], 2) + Math.pow(pos.ll[2] - pos.ur[0], 2) + Math.pow(
	          pos.lr[0] - pos.ur[0], 2) + Math.pow(pos.lr[1] - pos.ur[1], 2) +
	          Math.pow(pos.lr[2] - pos.ur[0], 2);
	      quadinfo.diag2 = diag2;
	      quadinfo.ll = pos.ll;
	      if (origindiag2 === undefined || (diag2 && diag2 < origindiag2)) {
	        origin = pos.ll;
	        origindiag2 = diag2;
	      }
	      pos = [pos.ll[0], pos.ll[1], pos.ll[2],
	             pos.lr[0], pos.lr[1], pos.lr[2],
	             pos.ul[0], pos.ul[1], pos.ul[2],
	             pos.ur[0], pos.ur[1], pos.ur[2]];
	      img = imgFunc.call(m_this, d, i);
	      if (!img) {
	        quad = {
	          idx: i,
	          pos: pos,
	          opacity: opacity,
	          color: util.convertColor(colorFunc.call(m_this, d, i))
	        };
	        if (d.reference) {
	          quad.reference = d.reference;
	        }
	        clrQuads.push(quad);
	        quadinfo.clrquad = quad;
	      } else {
	        image = m_this._objectListGet(m_images, img);
	        if (image === undefined) {
	          if (img instanceof Image) {
	            image = img;
	          } else {
	            image = new Image();
	            image.src = img;
	          }
	          m_this._objectListAdd(m_images, img, image);
	        }
	        quad = {
	          idx: i,
	          pos: pos,
	          opacity: opacity
	        };
	        if (d.reference) {
	          quad.reference = d.reference;
	        }
	        if (d.crop) {
	          quad.crop = d.crop;
	        }
	        if (image.complete && image.naturalWidth && image.naturalHeight) {
	          quad.image = image;
	        } else {
	          previewColor = undefined;
	          previewImage = previewImageFunc.call(m_this, d, i);
	          if (previewImage && previewImage instanceof Image &&
	              previewImage.complete && previewImage.naturalWidth &&
	              previewImage.naturalHeight) {
	            quad.image = previewImage;
	          } else {
	            previewColor = previewColorFunc.call(m_this, d, i);
	            if (previewColor === null) {
	              previewColor = undefined;
	            }
	            if (previewColor !== undefined) {
	              quad.color = util.convertColor(previewColor);
	              clrQuads.push(quad);
	              quadinfo.keep = false;
	            }
	          }
	          reload = loadedFunc.call(m_this, d, i);
	          if (reload) {
	            prev_onload = image.onload;
	            image.onload = function () {
	              if (previewColor !== undefined) {
	                if ($.inArray(quad, clrQuads) >= 0) {
	                  clrQuads.splice($.inArray(quad, clrQuads), 1);
	                }
	              }
	              quad.image = image;
	              m_this.dataTime().modified();
	              m_this.modified();
	              m_this._update();
	              m_this.layer().draw();
	              if (prev_onload) {
	                return prev_onload.apply(this, arguments);
	              }
	            };
	          } else if (previewColor === undefined && !quad.image) {
	            return;
	          }
	        }
	        imgQuads.push(quad);
	        quadinfo.imgquad = quad;
	      }
	      if (m_cacheQuads !== false && quadinfo.keep !== false) {
	        if (quadinfo.clrquad) {
	          m_nextQuadId += 1;
	          quadinfo.clrquad.quadId = m_nextQuadId;
	        }
	        if (quadinfo.imgquad) {
	          m_nextQuadId += 1;
	          quadinfo.imgquad.quadId = m_nextQuadId;
	        }
	        d._cachedQuad = quadinfo;
	      }
	    });
	    m_this._objectListEnd(m_images);
	    m_quads = {clrQuads: clrQuads, imgQuads: imgQuads, origin: origin};
	    return m_quads;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    arg = arg || {};
	    s_init.call(m_this, arg);

	    m_cacheQuads = (arg.cacheQuads !== false);

	    var style = $.extend(
	      {},
	      {
	        color: { r: 1.0, g: 1, b: 1 },
	        opacity: 1,
	        depth: 0,
	        drawOnAsyncResourceLoaded: true,
	        previewColor: null,
	        previewImage: null,
	        image: function (d) { return d.image; },
	        position: function (d) { return d; }
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    if (arg.position !== undefined) {
	      style.position = util.ensureFunction(arg.position);
	    }
	    m_this.style(style);
	    m_this.dataTime().modified();
	  };

	  return m_this;
	};

	/**
	 * Object specification for a quad feature.
	 *
	 * @extends geo.feature.spec // need to make a jsdoc plugin for this to work
	 * @typedef geo.quadFeature.spec
	 * @type {object}
	 */

	/**
	 * Create a quadFeature from an object.
	 *
	 * @see {@link geo.feature.create}
	 * @param {geo.layer} layer The layer to add the feature to
	 * @param {geo.quadFeature.spec} spec The object specification
	 * @returns {geo.quadFeature|null}
	 */
	quadFeature.create = function (layer, spec) {
	  'use strict';

	  spec = spec || {};
	  spec.type = 'quad';
	  return feature.create(layer, spec);
	};

	quadFeature.capabilities = {
	  /* support for solid-colored quads */
	  color: 'quad.color',
	  /* support for parallelogram images */
	  image: 'quad.image',
	  /* support for cropping quad images */
	  imageCrop: 'quad.imageCrop',
	  /* support for arbitrary quad images */
	  imageFull: 'quad.imageFull'
	};

	inherit(quadFeature, feature);
	module.exports = quadFeature;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class choroplethFeature
	 *
	 * @class geo.choroplethFeature
	 * @extends geo.feature
	 * @returns {geo.choroplethFeature}
	 *
	 */
	//////////////////////////////////////////////////////////////////////////////
	var choroplethFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof choroplethFeature)) {
	    return new choroplethFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  var $ = __webpack_require__(1);
	  var ensureFunction = __webpack_require__(196).ensureFunction;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var d3 = __webpack_require__(213),
	      m_this = this,
	      s_init = this._init,
	      m_choropleth = $.extend({},
	        {
	              /* 9-step based on paraview bwr colortable */
	          colorRange: [
	                {r: 0.07514311, g: 0.468049805, b: 1},
	                {r: 0.468487184, g: 0.588057293, b: 1},
	                {r: 0.656658579, g: 0.707001303, b: 1},
	                {r: 0.821573924, g: 0.837809045, b: 1},
	                {r: 0.943467973, g: 0.943498599, b: 0.943398095},
	                {r: 1, g: 0.788626485, b: 0.750707739},
	                {r: 1, g: 0.6289553, b: 0.568237474},
	                {r: 1, g: 0.472800903, b: 0.404551679},
	                {r: 0.916482116, g: 0.236630659, b: 0.209939162}
	          ],
	          scale: d3.scale.quantize(),
	          accessors: {
	                //accessor for ID on geodata feature
	            geoId: function (geoFeature) {
	              return geoFeature.properties.GEO_ID;
	            },
	                //accessor for ID on scalar element
	            scalarId: function (scalarElement) {
	              return scalarElement.id;
	            },
	                //accessor for value on scalar element
	            scalarValue: function (scalarElement) {
	              return scalarElement.value;
	            }
	          }
	        },
	        arg.choropleth);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set choropleth scalar data
	   *
	   * @returns {geo.feature.choropleth}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.scalar = function (data, aggregator) {
	    var scalarId, scalarValue;

	    if (data === undefined) {
	      return m_this.choropleth.get('scalar')();
	    } else {
	      scalarId = m_this.choropleth.get('accessors')().scalarId;
	      scalarValue = m_this.choropleth.get('accessors')().scalarValue;
	      m_choropleth.scalar = data;
	      m_choropleth.scalarAggregator = aggregator || d3.mean;
	      // we make internal dictionary from array for faster lookup
	      // when matching geojson features to scalar values,
	      // note that we also allow for multiple scalar elements
	      // for the same geo feature
	      m_choropleth.scalar._dictionary = data
	        .reduce(function (accumeDictionary, scalarElement) {
	          var id, value;

	          id = scalarId(scalarElement);
	          value = scalarValue(scalarElement);

	          accumeDictionary[id] =
	            accumeDictionary[id] ?
	            accumeDictionary[id].push(value) : [value];

	          return accumeDictionary;
	        }, {});
	      m_this.dataTime().modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set choropleth accessor
	   *
	   * @returns {geo.feature.choropleth}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.choropleth = function (arg1, arg2) {
	    var choropleth;

	    if (arg1 === undefined) {
	      return m_choropleth;
	    }
	    if (typeof arg1 === 'string' && arg2 === undefined) {
	      return m_choropleth[arg1];
	    }
	    if (arg2 === undefined) {
	      choropleth = $.extend(
	        {},
	        m_choropleth,
	        arg1
	      );
	      m_choropleth = choropleth;
	    } else {
	      m_choropleth[arg1] = arg2; //if you pass in accessor for prop
	    }
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * A uniform getter that always returns a function even for constant values.
	   * If undefined input, return all the choropleth values as an object.
	   *
	   * @param {string|undefined} key
	   * @return {function}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.choropleth.get = function (key) {
	    var all = {}, k;
	    if (key === undefined) {
	      for (k in m_choropleth) {
	        if (m_choropleth.hasOwnProperty(k)) {
	          all[k] = m_this.choropleth.get(k);
	        }
	      }
	      return all;
	    }
	    return ensureFunction(m_choropleth[key]);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * A method that adds a polygon feature to the current layer.
	   *
	   * @param {array} coordinateArray
	   * @param {geo.color} fillColor
	   * @return {geo.feature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._addPolygonFeature = function (feature, fillColor) {
	    var newFeature = m_this.layer()
	        .createFeature('polygon', {});

	    if (feature.geometry.type === 'Polygon') {
	      newFeature.data([{
	        type: 'Polygon',
	        coordinates: feature.geometry.coordinates
	      }]);
	    } else if (feature.geometry.type === 'MultiPolygon') {
	      newFeature.data(feature.geometry.coordinates.map(function (coordinateMap) {
	        return {
	          type: 'Polygon',
	          coordinates: coordinateMap
	        };
	      }));
	    }

	    newFeature
	      .polygon(function (d) {
	        return {
	          'outer': d.coordinates[0],
	          'inner': d.coordinates[1] // undefined but ok
	        };
	      })
	      .position(function (d) {
	        return {
	          x: d[0],
	          y: d[1]
	        };
	      })
	      .style({
	        'fillColor': fillColor
	      });

	    return newFeature;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * A method that adds polygons from a given feature to the current layer.
	   *
	   * @param {} geoJsonFeature
	   * @param geo.color
	   * @return [{geo.feature}]
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._featureToPolygons = function (feature, fillValue) {
	    return m_this
	      ._addPolygonFeature(feature, fillValue);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * A method that sets a choropleth scale's domain and range.
	   *
	   * @param {undefined | function({})} valueAccessor
	   * @return {geo.feature.choropleth}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._generateScale = function (valueAccessor) {
	    var extent =
	        d3.extent(m_this.scalar(), valueAccessor || undefined);

	    m_this.choropleth()
	      .scale
	      .domain(extent)
	      .range(m_this.choropleth().colorRange);

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**sr
	   * Generate scale for choropleth.data(), make polygons from features.
	   * @returns: [ [geo.feature.polygon, ...] , ... ]
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createChoropleth = function () {
	    var choropleth = m_this.choropleth,
	        data = m_this.data(),
	        scalars = m_this.scalar(),
	        valueFunc = choropleth.get('accessors')().scalarValue,
	        getFeatureId = choropleth.get('accessors')().geoId;

	    m_this._generateScale(valueFunc);

	    return data
	      .map(function (feature) {
	        var id = getFeatureId(feature);
	        var valueArray = scalars._dictionary[id];
	        var accumulatedScalarValue = choropleth().scalarAggregator(valueArray);
	        // take average of this array of values
	        // which allows for non-bijective correspondance
	        // between geo data and scalar data
	        var fillColor =
	            m_this
	            .choropleth()
	            .scale(accumulatedScalarValue);

	        return m_this
	          ._featureToPolygons(feature, fillColor);
	      });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    if (m_choropleth) {
	      m_this.dataTime().modified();
	    }
	  };

	  this._init(arg);
	  return this;
	};

	inherit(choroplethFeature, feature);
	module.exports = choroplethFeature;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.17"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.transpose = function(matrix) {
	    if (!(n = matrix.length)) return [];
	    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
	      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
	        row[j] = matrix[j][i];
	      }
	    }
	    return transpose;
	  };
	  function d3_transposeLength(d) {
	    return d.length;
	  }
	  d3.zip = function() {
	    return d3.transpose(arguments);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: d3_nsXhtml,
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (node = group[i]) {
	            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
	              exitNodes[i] = node;
	            } else {
	              nodeByKeyValue.set(keyValue, node);
	            }
	            keyValues[i] = keyValue;
	          }
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = d3_array(nodes);
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var  = Math.SQRT2, 2 = 2, 4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
	    if (d2 < 2) {
	      S = Math.log(w1 / w0) / ;
	      i = function(t) {
	        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];
	      };
	    } else {
	      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	      S = (r1 - r0) / ;
	      i = function(t) {
	        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];
	      };
	    }
	    i.duration = S * 1e3;
	    return i;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: null
	      };
	      scaleTo(+_);
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      }), center0 = null;
	    }
	    function mousedowned() {
	      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
	      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }

	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function() {
	    d3_timer.apply(this, arguments);
	  };
	  function d3_timer(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	    return timer;
	  }
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now(), timer = d3_timer_queueHead;
	    while (timer) {
	      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
	      timer = timer.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.c) {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      } else {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value = +value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;

	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;

	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;

	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();

	       case "c":
	        exponent = false;

	       case "d":
	        integer = true;
	        precision = 0;
	        break;

	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * ;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 *  + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var 00, 00, 0, cos0, sin0;
	    d3_geo_area.point = function(, ) {
	      d3_geo_area.point = nextPoint;
	      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), 
	      sin0 = Math.sin();
	    };
	    function nextPoint(, ) {
	       *= d3_radians;
	       =  * d3_radians / 2 +  / 4;
	      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      0 = , cos0 = cos, sin0 = sin;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(00, 00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var  = spherical[0],  = spherical[1], cos = Math.cos();
	    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
	  }
	  d3.geo.bounds = function() {
	    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;
	        range[0] = 0, range[1] = 1;
	      }
	    };
	    function point(, ) {
	      ranges.push(range = [ 0 = , 1 =  ]);
	      if ( < 0) 0 = ;
	      if ( > 1) 1 = ;
	    }
	    function linePoint(, ) {
	      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
	        if (antimeridian ^ (s * _ < i && i < s * )) {
	          var i = inflection[1] * d3_degrees;
	          if (i > 1) 1 = i;
	        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
	          var i = -inflection[1] * d3_degrees;
	          if (i < 0) 0 = i;
	        } else {
	          if ( < 0) 0 = ;
	          if ( > 1) 1 = ;
	        }
	        if (antimeridian) {
	          if ( < _) {
	            if (angle(0, ) > angle(0, 1)) 1 = ;
	          } else {
	            if (angle(, 1) > angle(0, 1)) 0 = ;
	          }
	        } else {
	          if (1 >= 0) {
	            if ( < 0) 0 = ;
	            if ( > 1) 1 = ;
	          } else {
	            if ( > _) {
	              if (angle(0, ) > angle(0, 1)) 1 = ;
	            } else {
	              if (angle(, 1) > angle(0, 1)) 0 = ;
	            }
	          }
	        }
	      } else {
	        point(, );
	      }
	      p0 = p, _ = ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = 0, range[1] = 1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(, ) {
	      if (p0) {
	        var d =  - _;
	        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
	      } else __ = , __ = ;
	      d3_geo_area.point(, );
	      linePoint(, );
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(__, __);
	      d3_geo_area.lineEnd();
	      if (abs(dSum) > ) 0 = -(1 = 180);
	      range[0] = 0, range[1] = 1;
	      p0 = null;
	    }
	    function angle(0, 1) {
	      return (1 -= 0) < 0 ? 1 + 360 : 1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      1 = 1 = -(0 = 0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, d;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < 2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < 2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(, ) {
	     *= d3_radians;
	    var cos = Math.cos( *= d3_radians);
	    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(, ) {
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians);
	      x0 = cos * Math.cos();
	      y0 = cos * Math.sin();
	      z0 = Math.sin();
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(, ) {
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var 00, 00, x0, y0, z0;
	    d3_geo_centroid.point = function(, ) {
	      00 = , 00 = ;
	      d3_geo_centroid.point = nextPoint;
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians);
	      x0 = cos * Math.cos();
	      y0 = cos * Math.sin();
	      z0 = Math.sin();
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(00, 00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(, ) {
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(, ) {
	        var point = rotate(, );
	        if (pointVisible( = point[0],  = point[1])) listener.point(, );
	      }
	      function pointLine(, ) {
	        var point = rotate(, );
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(, ) {
	        ring.push([ ,  ]);
	        var point = rotate(, );
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(, ) {
	        line.push([ ,  ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var 0 = NaN, 0 = NaN, s0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(1, 1) {
	        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
	        if (abs(d - ) < ) {
	          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
	          listener.point(s0, 0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(s1, 0);
	          listener.point(1, 0);
	          clean = 0;
	        } else if (s0 !== s1 && d >= ) {
	          if (abs(0 - s0) < ) 0 -= s0 * ;
	          if (abs(1 - s1) < ) 1 -= s1 * ;
	          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
	          listener.point(s0, 0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(s1, 0);
	          clean = 0;
	        }
	        listener.point(0 = 1, 0 = 1);
	        s0 = s1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        0 = 0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
	    var cos0, cos1, sin0_1 = Math.sin(0 - 1);
	    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var ;
	    if (from == null) {
	       = direction * half;
	      listener.point(-, );
	      listener.point(0, );
	      listener.point(, );
	      listener.point(, 0);
	      listener.point(, -);
	      listener.point(0, -);
	      listener.point(-, -);
	      listener.point(-, 0);
	      listener.point(-, );
	    } else if (abs(from[0] - to[0]) > ) {
	      var s = from[0] < to[0] ?  : -;
	       = direction * s / 2;
	      listener.point(-s, );
	      listener.point(0, );
	      listener.point(s, );
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
	        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
	        polarAngle += antimeridian ? d + sd *  : d;
	        if (antimeridian ^ 0 >= meridian ^  >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ d >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        0 = , sin0 = sin, cos0 = cos, point0 = point;
	      }
	    }
	    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < -) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);
	    function visible(, ) {
	      return Math.cos() * Math.cos() > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(, ) {
	          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ;
	              point1[1] += ;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
	      if (1 < 0) z = 0, 0 = 1, 1 = z;
	      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
	      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;
	      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(, ) {
	      var r = smallRadius ? radius :  - radius, code = 0;
	      if ( < -r) code |= 1; else if ( > r) code |= 2;
	      if ( < -r) code |= 4; else if ( > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];
	      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(0, 1) {
	    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
	    function forward(, ) {
	      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
	      return [  * Math.sin( *= n), 0 -  * Math.cos() ];
	    }
	    forward.invert = function(x, y) {
	      var 0_y = 0 - y;
	      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, );
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(, ) {
	        var c = d3_geo_cartesian([ ,  ]), p = project(, );
	        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(, ) {
	        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * 2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(2);
	      maxDepth = (2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + x, y - x[1] * k ];
	    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + x, y - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];
	       = _[0] % 360 * d3_radians;
	       = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];
	       = _[0] % 360 * d3_radians;
	       = _[1] % 360 * d3_radians;
	       = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
	      var center = project(, );
	      x = x - center[0] * k;
	      y = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(, ) {
	    return [ ,  ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(, ) {
	    return [  >  ?  -  :  < - ?  +  : ,  ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(, , ) {
	    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotation() {
	    return function(, ) {
	      return  += , [  >  ?  -  :  < - ?  +  : ,  ];
	    };
	  }
	  function d3_geo_rotation() {
	    var rotation = d3_geo_forwardRotation();
	    rotation.invert = d3_geo_forwardRotation(-);
	    return rotation;
	  }
	  function d3_geo_rotation(, ) {
	    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
	    function rotation(, ) {
	      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
	      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];
	    }
	    rotation.invert = function(, ) {
	      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
	      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * ;
	      } else {
	        from = radius + direction * ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
	    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - , dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - , dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var 0, sin0, cos0;
	    d3_geo_length.point = function(, ) {
	      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(, ) {
	      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
	      0 = , sin0 = sin, cos0 = cos;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(, ) {
	      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
	      return [ k * cos * Math.sin(), k * Math.sin() ];
	    }
	    azimuthal.invert = function(x, y) {
	      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {
	    return Math.sqrt(2 / (1 + coscos));
	  }, function() {
	    return 2 * Math.asin( / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {
	    var c = Math.acos(coscos);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(0, 1) {
	    var cos0 = Math.cos(0), t = function() {
	      return Math.tan( / 4 +  / 2);
	    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(, ) {
	      if (F > 0) {
	        if ( < -half + )  = -half + ;
	      } else {
	        if ( > half - )  = half - ;
	      }
	      var  = F / Math.pow(t(), n);
	      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];
	    }
	    forward.invert = function(x, y) {
	      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
	      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(0, 1) {
	    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
	    if (abs(n) < ) return d3_geo_equirectangular;
	    function forward(, ) {
	      var  = G - ;
	      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];
	    }
	    forward.invert = function(x, y) {
	      var 0_y = G - y;
	      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {
	    return 1 / coscos;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(, ) {
	    return [ , Math.log(Math.tan( / 4 +  / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - half ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k =  * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {
	    return 1 / (1 + coscos);
	  }, function() {
	    return 2 * Math.atan();
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(, ) {
	    return [ Math.log(Math.tan( / 4 +  / 2)), - ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
	            x: x0,
	            y: abs(x2 - x0) <  ? y2 : y1
	          } : abs(y3 - y1) <  && x1 - x3 >  ? {
	            x: abs(y2 - y1) <  ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) <  && y3 - y0 >  ? {
	            x: x1,
	            y: abs(x2 - x1) <  ? y2 : y0
	          } : abs(y3 - y0) <  && x3 - x0 >  ? {
	            x: abs(y2 - y0) <  ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ) * ,
	          y: Math.round(fy(d, i) / ) * ,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;

	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;

	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;

	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * half);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransformPop(s) {
	    return s.length ? s.pop() + "," : "";
	  }
	  function d3_interpolateTranslate(ta, tb, s, q) {
	    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
	      var i = s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    }
	  }
	  function d3_interpolateRotate(ra, rb, s, q) {
	    if (ra !== rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
	    }
	  }
	  function d3_interpolateSkew(wa, wb, s, q) {
	    if (wa !== wb) {
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
	    }
	  }
	  function d3_interpolateScale(ka, kb, s, q) {
	    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
	      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] !== 1 || kb[1] !== 1) {
	      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
	    }
	  }
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [];
	    a = d3.transform(a), b = d3.transform(b);
	    d3_interpolateTranslate(a.translate, b.translate, s, q);
	    d3_interpolateRotate(a.rotate, b.rotate, s, q);
	    d3_interpolateSkew(a.skew, b.skew, s, q);
	    d3_interpolateScale(a.scale, b.scale, s, q);
	    a = b = null;
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = ( - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: groupSums[di]
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        timer = null;
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) {
	          alpha = x;
	        } else {
	          timer.c = null, timer.t = NaN, timer = null;
	          event.end({
	            type: "end",
	            alpha: alpha = 0
	          });
	        }
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        timer = d3_timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = root.y = 0;
	      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(, ) {
	      var n = arguments.length;
	      if (n < 2)  = 1;
	      if (n < 1)  = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    return domain;
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(1, base * n / scale.ticks().length);
	      return function(d) {
	        var i = d / pow(Math.round(log(d)));
	        if (i * base < base - .5) i *= base;
	        return i <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var rc1 = rc, rc0 = rc;
	        if (da < ) {
	          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
	          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
	        }
	        if (x1 != null) {
	          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.length > 1 ? points.join("L") : points + "Z";
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return points.join("L") + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - half;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > ) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / );
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, activeId, active;
	      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        if (--lock.count) delete lock[activeId]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id], time, timer, duration, ease, tweens;
	    function schedule(elapsed) {
	      var delay = transition.delay;
	      timer.t = delay + time;
	      if (delay <= elapsed) return start(elapsed - delay);
	      timer.c = start;
	    }
	    function start(elapsed) {
	      var activeId = lock.active, active = lock[activeId];
	      if (active) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        --lock.count;
	        delete lock[activeId];
	        active.event && active.event.interrupt.call(node, node.__data__, active.index);
	      }
	      for (var cancelId in lock) {
	        if (+cancelId < id) {
	          var cancel = lock[cancelId];
	          cancel.timer.c = null;
	          cancel.timer.t = NaN;
	          --lock.count;
	          delete lock[cancelId];
	        }
	      }
	      timer.c = tick;
	      d3_timer(function() {
	        if (timer.c && tick(elapsed || 1)) {
	          timer.c = null;
	          timer.t = NaN;
	        }
	        return 1;
	      }, 0, time);
	      lock.active = id;
	      transition.event && transition.event.start.call(node, node.__data__, i);
	      tweens = [];
	      transition.tween.forEach(function(key, value) {
	        if (value = value.call(node, node.__data__, i)) {
	          tweens.push(value);
	        }
	      });
	      ease = transition.ease;
	      duration = transition.duration;
	    }
	    function tick(elapsed) {
	      var t = elapsed / duration, e = ease(t), n = tweens.length;
	      while (n > 0) {
	        tweens[--n].call(node, e);
	      }
	      if (t >= 1) {
	        transition.event && transition.event.end.call(node, node.__data__, i);
	        if (--lock.count) delete lock[id]; else delete node[ns];
	        return 1;
	      }
	    }
	    if (!transition) {
	      time = inherit.time;
	      timer = d3_timer(schedule, 0, time);
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        timer: timer,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ), tickExit = d3.transition(tick.exit()).style("opacity", ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = d3_array(arguments);
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
	}();

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var object = __webpack_require__(80);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Stores the current time for a map, triggers time keeping events, and
	 * handles the animation state and interaction.
	 *
	 * @class geo.clock
	 * @extends geo.object
	 * @returns {geo.clock}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var clock = function (opts) {
	  'use strict';

	  if (!(this instanceof clock)) {
	    return new clock(opts);
	  }
	  opts = opts || {};
	  object.call(this, opts);

	  var geo_event = __webpack_require__(5);

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_now = new Date(0),
	      m_start = null,
	      m_end = null,
	      m_step = null,
	      m_rate = null,
	      m_loop = Number.POSITIVE_INFINITY,
	      m_currentLoop = 0,
	      m_state = 'stop',
	      m_currentAnimation = null,
	      m_object = null;

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the geo.object to trigger events on.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.object = function (arg) {
	    if (arg === undefined) {
	      return m_object;
	    }
	    m_object = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Returns true if attached to a valid geo.object.
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._attached = function () {
	    return (m_object instanceof object);
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the current time.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.now = function (arg) {
	    var previous = m_now;
	    if (arg === undefined) {
	      return m_now;
	    }
	    m_now = arg;

	    if (m_now !== previous &&
	        m_this._attached()) {
	      m_this.object().geoTrigger(geo_event.clock.change, {
	        previous: previous,
	        current: m_now,
	        clock: m_this
	      });
	    }
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the animation start time.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.start = function (arg) {
	    if (arg === undefined) {
	      return m_start;
	    }
	    m_start = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the animation end time.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.end = function (arg) {
	    if (arg === undefined) {
	      return m_end;
	    }
	    m_end = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the animation time step.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.step = function (arg) {
	    if (arg === undefined) {
	      return m_step;
	    }
	    m_step = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set looping control of the clock.  This controls how many times the
	   * animation will repeat before stopping.  Default
	   * ``Number.POSITIVE_INFINITY``, the animation repeats forever.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.loop = function (arg) {
	    if (arg === undefined) {
	      return m_loop;
	    }
	    m_loop = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the animation state.  Valid values are:
	   *
	   *   * 'stop'
	   *   * 'play'
	   *   * 'pause'
	   *
	   * This will also trigger relevant events, but they may be fired
	   * asynchronously.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.state = function (arg, step) {

	    if (arg === undefined) {
	      return m_state;
	    }
	    if (['stop', 'play', 'pause'].indexOf(arg) < 0) {
	      console.log('WARNING: Ignored invalid state: ' + arg);
	      return m_this;
	    }

	    if (arg === 'play' && m_state === 'stop') {
	      // reset animation parameters
	      m_currentLoop = 0;
	      m_this.now(m_this.start());
	    }

	    if (arg === 'play' && m_state !== 'play') {
	      // Start a new animation.
	      m_state = arg;
	      m_this._animate(step || 1);
	    }

	    m_state = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the animation frame rate.  This is approximately the number
	   * of frames displayed per second.  A null value will use the browser's
	   * native requestAnimationFrame to draw new frames.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.framerate = function (arg) {
	    if (arg === undefined) {
	      return m_rate;
	    }
	    m_rate = arg;
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Step to the next frame in the animation.  Pauses the animation if it is
	   * playing.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.stepForward = function () {
	    m_this.state('pause');
	    m_this._setNextFrame(1);
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Step to the previous frame in the animation.  Pauses the animation if it is
	   * playing.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.stepBackward = function () {
	    m_this.state('pause');
	    m_this._setNextFrame(-1);
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Step to the next frame in the animation.  Will set the state to stop
	   * if the animation has reached the end and there are no more loops.
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._setNextFrame = function (step) {
	    var next = new Date(m_this.now().valueOf() + step * m_this.step());

	    if (next >= m_this.end() || next <= m_this.start()) {
	      if (m_this.loop() <= m_currentLoop) {
	        m_this.state('stop');
	        return;
	      }
	      m_currentLoop += 1;
	      if (step >= 0) {
	        m_this.now(m_this.start());
	      } else {
	        m_this.now(m_this.end());
	      }
	      return;
	    }
	    m_this.now(next);
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Start an animation.
	   * @param {integer} step The animation frame step (+1 for forward -1 for
	   *                       reverse, etc).
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._animate = function (step) {
	    var myAnimation = {};
	    m_currentAnimation = myAnimation;

	    function frame() {
	      if (myAnimation !== m_currentAnimation) {
	        // A new animation has started, so kill this one.
	        return;
	      }
	      m_this._setNextFrame(step);
	      if (m_this.state() === 'play') {

	        // Queue the next frame
	        if (!m_this.framerate()) {
	          window.requestAnimationFrame(frame);
	        } else {
	          window.setTimeout(frame, 1000 / m_this.framerate());
	        }
	      } else if (m_this._attached()) {
	        m_this.object().geoTrigger(geo_event.clock[m_this.state()], {
	          current: m_this.now(),
	          clock: m_this
	        });
	      }
	    }

	    // trigger the play event
	    if (m_this._attached()) {
	      m_this.object().geoTrigger(geo_event.clock.play, {
	        current: m_this.now(),
	        clock: m_this
	      });
	    }

	    // Queue the first frame
	    if (!m_this.framerate()) {
	      window.requestAnimationFrame(frame);
	    } else {
	      window.setTimeout(frame, 1000 / m_this.framerate());
	    }
	  };
	};

	inherit(clock, object);
	module.exports = clock;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class contourFeature
	 *
	 * @class geo.contourFeature
	 * @extends geo.feature
	 * @returns {geo.contourFeature}
	 *
	 */
	//////////////////////////////////////////////////////////////////////////////
	var contourFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof contourFeature)) {
	    return new contourFeature(arg);
	  }

	  var $ = __webpack_require__(1);
	  var util = __webpack_require__(196);

	  arg = arg || {};
	  feature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_contour = {},
	      s_init = this._init,
	      s_data = this.data;

	  if (arg.contour === undefined) {
	    m_contour = function (d) {
	      return d;
	    };
	  } else {
	    m_contour = arg.contour;
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Override the parent data method to keep track of changes to the
	   * internal coordinates.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.data = function (arg) {
	    var ret = s_data(arg);
	    return ret;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set contour accessor
	   *
	   * @returns {geo.pointFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.contour = function (arg1, arg2) {
	    if (arg1 === undefined) {
	      return m_contour;
	    }
	    if (typeof arg1 === 'string' && arg2 === undefined) {
	      return m_contour[arg1];
	    }
	    if (arg2 === undefined) {
	      var contour = $.extend(
	        {},
	        {
	          gridWidth: function () {
	            if (arg1.gridHeight) {
	              return Math.floor(m_this.data().length / arg1.gridHeight);
	            }
	            return Math.floor(Math.sqrt(m_this.data().length));
	          },
	          gridHeight: function () {
	            if (arg1.gridWidth) {
	              return Math.floor(m_this.data().length / arg1.gridWidth);
	            }
	            return Math.floor(Math.sqrt(m_this.data().length));
	          },
	          minColor: 'black',
	          minOpacity: 0,
	          maxColor: 'black',
	          maxOpacity: 0,
	        /* 9-step based on paraview bwr colortable */
	          colorRange: [
	            {r: 0.07514311, g: 0.468049805, b: 1},
	            {r: 0.468487184, g: 0.588057293, b: 1},
	            {r: 0.656658579, g: 0.707001303, b: 1},
	            {r: 0.821573924, g: 0.837809045, b: 1},
	            {r: 0.943467973, g: 0.943498599, b: 0.943398095},
	            {r: 1, g: 0.788626485, b: 0.750707739},
	            {r: 1, g: 0.6289553, b: 0.568237474},
	            {r: 1, g: 0.472800903, b: 0.404551679},
	            {r: 0.916482116, g: 0.236630659, b: 0.209939162}
	          ]
	        },
	        m_contour,
	        arg1
	      );
	      m_contour = contour;
	    } else {
	      m_contour[arg1] = arg2;
	    }
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * A uniform getter that always returns a function even for constant values.
	   * If undefined input, return all the contour values as an object.
	   *
	   * @param {string|undefined} key
	   * @return {function}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.contour.get = function (key) {
	    if (key === undefined) {
	      var all = {}, k;
	      for (k in m_contour) {
	        if (m_contour.hasOwnProperty(k)) {
	          all[k] = m_this.contour.get(k);
	        }
	      }
	      return all;
	    }
	    return util.ensureFunction(m_contour[key]);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set position accessor
	   *
	   * @returns {geo.pointFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_this.style('position');
	    } else {
	      m_this.style('position', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a set of vertices, values at the vertices, and opacities at the
	   * vertices.  Create a set of triangles of indices into the vertex array.
	   * Create a color and opacity map corresponding to the values.
	   *
	   * @returns: an object with pos, value, opacity, elements, minValue,
	   *           maxValue, minColor, maxColor, colorMap, factor.  If there is no
	   *           contour data that can be used, only elements is guaranteed to
	   *           exist, and it will be a zero-length array.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createContours = function () {
	    var i, i3, j, idx, k, val, numPts, usedPts = 0, usePos, item,
	        idxMap = {},
	        minval, maxval, range,
	        contour = m_this.contour,
	        data = m_this.data(),
	        posFunc = m_this.position(), posVal,
	        gridW = contour.get('gridWidth')(),
	        gridH = contour.get('gridHeight')(),
	        x0 = contour.get('x0')(),
	        y0 = contour.get('y0')(),
	        dx = contour.get('dx')(),
	        dy = contour.get('dy')(),
	        opacityFunc = m_this.style.get('opacity'),
	        opacityRange = contour.get('opacityRange')(),
	        rangeValues = contour.get('rangeValues')(),
	        valueFunc = m_this.style.get('value'), values = [],
	        stepped = contour.get('stepped')(),
	        wrapLong = contour.get('wrapLongitude')(),
	        calcX, skipColumn, x, origI, /* used for wrapping */
	        gridWorig = gridW,  /* can be different when wrapping */
	        result = {
	          minValue: contour.get('min')(),
	          maxValue: contour.get('max')(),
	          stepped: stepped === undefined || stepped ? true : false,
	          wrapLongitude: wrapLong === undefined || wrapLong ? true : false,
	          colorMap: [],
	          elements: []
	        };
	    /* Create the min/max colors and the color array */
	    result.minColor = $.extend({a: contour.get('minOpacity')() || 0},
	        util.convertColor(contour.get('minColor')()));
	    result.maxColor = $.extend({a: contour.get('maxOpacity')() || 0},
	        util.convertColor(contour.get('maxColor')()));
	    contour.get('colorRange')().forEach(function (clr, idx) {
	      result.colorMap.push($.extend(
	          {a: opacityRange && opacityRange[idx] !== undefined ?
	          opacityRange[idx] : 1}, util.convertColor(clr)));
	    });
	    /* Determine which values are usable */
	    if (gridW * gridH > data.length) {
	      gridH = Math.floor(data.length) / gridW;
	    }
	    /* If we are not using the position values (we are using x0, y0, dx, dy),
	     * and wrapLongitude is turned on, and the position spans 180 degrees,
	     * duplicate one or two columns of points at opposite ends of the map. */
	    usePos = (x0 === null || x0 === undefined || y0 === null ||
	        y0 === undefined || !dx || !dy);
	    if (!usePos && result.wrapLongitude && (x0 < -180 || x0 > 180 ||
	        x0 + dx * (gridW - 1) < -180 || x0 + dx * (gridW - 1) > 180) &&
	        dx > -180 && dx < 180) {
	      calcX = [];
	      for (i = 0; i < gridW; i += 1) {
	        x = x0 + i * dx;
	        while (x < -180) { x += 360; }
	        while (x > 180) { x -= 360; }
	        if (i && Math.abs(x - calcX[calcX.length - 1]) > 180) {
	          if (x > calcX[calcX.length - 1]) {
	            calcX.push(x - 360);
	            calcX.push(calcX[calcX.length - 2] + 360);
	          } else {
	            calcX.push(x + 360);
	            calcX.push(calcX[calcX.length - 2] - 360);
	          }
	          skipColumn = i;
	        }
	        calcX.push(x);
	      }
	      gridW += 2;
	      if (Math.abs(Math.abs(gridWorig * dx) - 360) < 0.01) {
	        gridW += 1;
	        x = x0 + gridWorig * dx;
	        while (x < -180) { x += 360; }
	        while (x > 180) { x -= 360; }
	        calcX.push(x);
	      }
	    }
	    /* Calculate the value for point */
	    numPts = gridW * gridH;
	    for (i = 0; i < numPts; i += 1) {
	      if (skipColumn === undefined) {
	        val = parseFloat(valueFunc(data[i]));
	      } else {
	        j = Math.floor(i / gridW);
	        origI = i - j * gridW;
	        origI += (origI > skipColumn ? -2 : 0);
	        if (origI >= gridWorig) {
	          origI -= gridWorig;
	        }
	        origI += j * gridWorig;
	        val = parseFloat(valueFunc(data[origI]));
	      }
	      values[i] = isNaN(val) ? null : val;
	      if (values[i] !== null) {
	        idxMap[i] = usedPts;
	        usedPts += 1;
	        if (minval === undefined) {
	          minval = maxval = values[i];
	        }
	        if (values[i] < minval) {
	          minval = values[i];
	        }
	        if (values[i] > maxval) {
	          maxval = values[i];
	        }
	      }
	    }
	    if (!usedPts) {
	      return result;
	    }
	    if (!$.isNumeric(result.minValue)) {
	      result.minValue = minval;
	    }
	    if (!$.isNumeric(result.maxValue)) {
	      result.maxValue = maxval;
	    }
	    if (!rangeValues || rangeValues.length !== result.colorMap.length + 1) {
	      rangeValues = null;
	    }
	    if (rangeValues) {  /* ensure increasing monotonicity */
	      for (k = 1; k < rangeValues.length; k += 1) {
	        if (rangeValues[k] > rangeValues[k + 1]) {
	          rangeValues = null;
	          break;
	        }
	      }
	    }
	    if (rangeValues) {
	      result.minValue = rangeValues[0];
	      result.maxValue = rangeValues[rangeValues.length - 1];
	    }
	    range = result.maxValue - result.minValue;
	    if (!range) {
	      result.colorMap = result.colorMap.slice(0, 1);
	      range = 1;
	      rangeValues = null;
	    }
	    result.rangeValues = rangeValues;
	    result.factor = result.colorMap.length / range;
	    /* Create triangles */
	    for (j = idx = 0; j < gridH - 1; j += 1, idx += 1) {
	      for (i = 0; i < gridW - 1; i += 1, idx += 1) {
	        if (values[idx] !== null && values[idx + 1] !== null &&
	            values[idx + gridW] !== null &&
	            values[idx + gridW + 1] !== null && i !== skipColumn) {
	          result.elements.push(idxMap[idx]);
	          result.elements.push(idxMap[idx + 1]);
	          result.elements.push(idxMap[idx + gridW]);
	          result.elements.push(idxMap[idx + gridW + 1]);
	          result.elements.push(idxMap[idx + gridW]);
	          result.elements.push(idxMap[idx + 1]);
	        }
	      }
	    }
	    /* Only locate the points that are in use. */
	    result.pos = new Array(usedPts * 3);
	    result.value = new Array(usedPts);
	    result.opacity = new Array(usedPts);
	    for (j = i = i3 = 0; j < numPts; j += 1) {
	      val = values[j];
	      if (val !== null) {
	        item = data[j];
	        if (usePos) {
	          posVal = posFunc(item);
	          result.pos[i3] = posVal.x;
	          result.pos[i3 + 1] = posVal.y;
	          result.pos[i3 + 2] = posVal.z || 0;
	        } else {
	          if (skipColumn === undefined) {
	            result.pos[i3] = x0 + dx * (j % gridW);
	          } else {
	            result.pos[i3] = calcX[j % gridW];
	          }
	          result.pos[i3 + 1] = y0 + dy * Math.floor(j / gridW);
	          result.pos[i3 + 2] = 0;
	        }
	        result.opacity[i] = opacityFunc(item);
	        if (rangeValues && val >= result.minValue && val <= result.maxValue) {
	          for (k = 1; k < rangeValues.length; k += 1) {
	            if (val <= rangeValues[k]) {
	              result.value[i] = k - 1 + (val - rangeValues[k - 1]) /
	                  (rangeValues[k] - rangeValues[k - 1]);
	              break;
	            }
	          }
	        } else {
	          result.value[i] = (val - result.minValue) * result.factor;
	        }
	        i += 1;
	        i3 += 3;
	      }
	    }
	    return result;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(
	      {},
	      {
	        opacity: 1.0,
	        position: function (d) {
	          return {x: d.x, y: d.y, z: d.z};
	        },
	        value: function (d) {
	          return m_this.position()(d).z;
	        }
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    m_this.style(defaultStyle);

	    if (m_contour) {
	      m_this.dataTime().modified();
	    }
	  };

	  this._init(arg);
	  return this;
	};

	inherit(contourFeature, feature);
	module.exports = contourFeature;

	/* Example:

	layer.createFeature('contour', {
	})
	.data(<array with w x h elements>)
	.position(function (d) {
	  return { x: <longitude>, y: <latitude>, z: <altitude>};
	})
	.style({
	  opacity: function (d) {
	    return <opacity of grid point>;
	  },
	  value: function (d) {            // defaults to position().z
	    return <contour value>;
	  }
	})
	.contour({
	  gridWidth: <width of grid>,
	  gridHeight: <height of grid>,
	  x0: <the x coordinate of the 0th point in the value array>,
	  y0: <the y coordinate of the 0th point in the value array>,
	  dx: <the distance in the x direction between the 0th and 1st point in the
	    value array>,
	  dy: <the distance in the y direction between the 0th and (gridWidth)th point
	    in the value array>,
	  wrapLongitude: <boolean (default true).  If true, AND the position array is
	    not used, assume the x coordinates is longitude and should be adjusted to
	    be within -180 to 180.  If the data spans 180 degrees, the points or
	    squares will be duplicated to ensure that the map is covered from -180 to
	    180 as appropriate.  Set this to false if using a non longitude x
	    coordinate.  This is ignored if the position array is used.>,
	  min: <optional minimum contour value, otherwise taken from style.value>,
	  max: <optional maximum contour value, otherwise taken from style.value>,
	  minColor: <color for any value below the minimum>,
	  minOpacity: <opacity for any value below the minimum>,
	  maxColor: <color for any value above the maximum>,
	  maxOpacity: <opacity for any value above the maximum>,
	  stepped: <boolean (default true).  If false, smooth transitions between
	    colors>,
	  colorRange: [<array of colors used for the contour>],
	  opacityRange: [<optional array of opacities used for the contour, expected to
	    be the same length as colorRange>],
	  rangeValues: [<if specified, instead of spacing the colors linearly, use this
	    spacing.  Must be increasing monotonic and one value longer than the length
	    of colorRange>]
	})

	Notes:
	* The position array is only used for position if not all of x0, y0, dx, and dy
	    are specified (not null or undefined).  If a value array is not specified,
	    the position array could still be used for the value.
	* If the value() of a grid point is null or undefined, that point will not be
	    included in the contour display.  Since the values are on a grid, if this
	    point is in the interior of the grid, this can remove up to four squares.
	* Only one of gridWidth and gridHeight needs to be specified.  If both are
	    specified and gridWidth * gridHeight < data().length, not all the data will
	    be used.  If neither are specified, floor(sqrt(data().length)) is used for
	    both.
	 */


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var renderer = __webpack_require__(217);
	var registerRenderer = __webpack_require__(76).registerRenderer;

	/**
	 * @class geo.domRenderer
	 * @extends geo.renderer
	 */
	var domRenderer = function (arg) {
	  'use strict';

	  if (!(this instanceof domRenderer)) {
	    return new domRenderer(arg);
	  }
	  renderer.call(this, arg);

	  arg = arg || {};

	  var m_this = this;

	  this.api = function () {
	    return 'dom';
	  };

	  this._init = function () {
	    var layer = m_this.layer().node();

	    if (!m_this.canvas() && layer && layer.length) {
	      // The renderer and the UI Layer share the same canvas
	      // at least for now. This renderer is essentially a noop renderer
	      // designed for backwards compatibility
	      m_this.canvas(layer[0]);
	    }
	  };

	  this._init(arg);
	  return this;
	};

	inherit(domRenderer, renderer);
	registerRenderer('dom', domRenderer);
	module.exports = domRenderer;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var object = __webpack_require__(80);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class renderer
	 *
	 * @class geo.renderer
	 * @extends geo.object
	 * @returns {geo.renderer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var renderer = function (arg) {
	  'use strict';

	  if (!(this instanceof renderer)) {
	    return new renderer(arg);
	  }
	  object.call(this);

	  arg = arg || {};
	  var m_this = this,
	      m_layer = arg.layer === undefined ? null : arg.layer,
	      m_canvas = arg.canvas === undefined ? null : arg.canvas,
	      m_initialized = false;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get layer of the renderer
	   *
	   * @returns {*}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.layer = function () {
	    return m_layer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get canvas for the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.canvas = function (val) {
	    if (val === undefined) {
	      return m_canvas;
	    } else {
	      m_canvas = val;
	      m_this.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get map that this renderer belongs to
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.map = function () {
	    if (m_layer) {
	      return m_layer.map();
	    } else {
	      return null;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set if renderer has been initialized
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.initialized = function (val) {
	    if (val === undefined) {
	      return m_initialized;
	    } else {
	      m_initialized = val;
	      return m_this;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get render API used by the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.api = function () {
	    throw new Error('Should be implemented by derived classes');
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Reset to default
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.reset = function () {
	    return true;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle resize event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._resize = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._render = function () {
	  };

	  return this;
	};

	inherit(renderer, object);
	module.exports = renderer;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (function () {
	  'use strict';

	  var $ = __webpack_require__(1);

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * This class implements a queue for Deferred objects.  Whenever one of the
	   * objects in the queue completes (resolved or rejected), another item in the
	   * queue is processed.  The number of concurrently processing items can be
	   * adjusted.  At this time (2015-12-29) most major browsers support 6
	   * concurrent requests from any given server, so, when using the queue for
	   * tile images, thie number of concurrent requests should be 6 * (number of
	   * subdomains serving tiles).
	   *
	   * @class geo.fetchQueue
	   *
	   * @param {Object?} [options] A configuration object for the queue
	   * @param {Number} [options.size=6] The maximum number of concurrent deferred
	   *    objects.
	   * @param {Number} [options.track=600] The number of objects that are tracked
	   *    that trigger checking if any of them have been abandoned.  The fetch
	   *    queue can grow to the greater of this size and the number of items that
	   *    are still needed.  Setting this to a low number will increase
	   *    processing time, to a high number can increase memory.  Ideally, it
	   *    should reflect the number of items that are kept in memory elsewhere.
	   *    If needed is null, this is ignored.
	   * @param {function} [options.needed=null] If set, this function is passed a
	   *    Deferred object and must return a truthy value if the object is still
	   *    needed.
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var fetchQueue = function (options) {
	    if (!(this instanceof fetchQueue)) {
	      return new fetchQueue(options);
	    }

	    options = options || {};
	    this._size = options.size || 6;
	    this._track = options.track || 600;
	    this._needed = options.needed || null;
	    this._batch = false;

	    var m_this = this,
	        m_next_batch = 1;

	    /**
	     * Get/set the maximum concurrent deferred object size.
	     */
	    Object.defineProperty(this, 'size', {
	      get: function () { return this._size; },
	      set: function (n) {
	        this._size = n;
	        this.next_item();
	      }
	    });

	    /**
	     * Get the current queue size.
	     */
	    Object.defineProperty(this, 'length', {
	      get: function () { return this._queue.length; }
	    });

	    /**
	     * Get the current number of processing items.
	     */
	    Object.defineProperty(this, 'processing', {
	      get: function () { return this._processing; }
	    });

	    /**
	     * Remove all items from the queue.
	     */
	    this.clear = function () {
	      this._queue = [];
	      this._processing = 0;
	      return this;
	    };

	    /**
	     * Add a Deferred object to the queue.
	     * @param {Deferred} defer Deferred object to add to the queue.
	     * @param {function} callback a function to call when the item's turn is
	     *  granted.
	     * @param {boolean} atEnd if false, add the item to the front of the queue
	     *  if batching is turned off or at the end of the current batch if it is
	     *  turned on.  If true, always add the item to the end of the queue.
	     */
	    this.add = function (defer, callback, atEnd) {
	      if (defer.__fetchQueue) {
	        var pos = $.inArray(defer, this._queue);
	        if (pos >= 0) {
	          this._queue.splice(pos, 1);
	          this._addToQueue(defer, atEnd);
	          return defer;
	        }
	      }
	      var wait = new $.Deferred();
	      var process = new $.Deferred();
	      wait.then(function () {
	        $.when(callback.call(defer)).always(process.resolve);
	      }, process.resolve);
	      defer.__fetchQueue = wait;
	      this._addToQueue(defer, atEnd);
	      $.when(wait, process).always(function () {
	        if (m_this._processing > 0) {
	          m_this._processing -= 1;
	        }
	        m_this.next_item();
	      }).promise(defer);
	      m_this.next_item();
	      return defer;
	    };

	    /**
	     * Add an item to the queue.  If batches are being used, add it at after
	     * other items in the same batch.
	     * @param {Deferred} defer Deferred object to add to the queue.
	     * @param {boolean} atEnd if false, add the item to the front of the queue
	     *  if batching is turned off or at the end of the current batch if it is
	     *  turned on.  If true, always add the item to the end of the queue.
	     */
	    this._addToQueue = function (defer, atEnd) {
	      defer.__fetchQueue._batch = this._batch;
	      if (atEnd) {
	        this._queue.push(defer);
	      } else if (!this._batch) {
	        this._queue.unshift(defer);
	      } else {
	        for (var i = 0; i < this._queue.length; i += 1) {
	          if (this._queue[i].__fetchQueue._batch !== this._batch) {
	            break;
	          }
	        }
	        this._queue.splice(i, 0, defer);
	      }
	    };

	    /**
	     * Get the position of a deferred object in the queue.
	     * @param {Deferred} defer Deferred object to get the position of.
	     * @returns {number} -1 if not in the queue, or the position in the queue.
	     */
	    this.get = function (defer) {
	      return $.inArray(defer, this._queue);
	    };

	    /**
	     * Remove a Deferred object from the queue.
	     * @param {Deferred} defer Deferred object to add to the queue.
	     * @returns {bool} true if the object was removed
	     */
	    this.remove = function (defer) {
	      var pos = $.inArray(defer, this._queue);
	      if (pos >= 0) {
	        this._queue.splice(pos, 1);
	        return true;
	      }
	      return false;
	    };

	    /**
	     * Start a new batch or clear using batches.
	     * @param {boolean} start true to start a new batch, false to turn off
	     *                        using batches.  Undefined to return the current
	     *                        state of batches.
	     * @return {Number|boolean|Object} the current batch state or this object.
	     */
	    this.batch = function (start) {
	      if (start === undefined) {
	        return this._batch;
	      }
	      if (!start) {
	        this._batch = false;
	      } else {
	        this._batch = m_next_batch;
	        m_next_batch += 1;
	      }
	      return this;
	    };

	    /**
	     * Check if any items are queued and if there if there are not too many
	     * deferred objects being processed.  If so, process more items.
	     */
	    this.next_item = function () {
	      if (m_this._innextitem) {
	        return;
	      }
	      m_this._innextitem = true;
	      /* if the queue is greater than the track size, check each item to see
	       * if it is still needed. */
	      if (m_this._queue.length > m_this._track && this._needed) {
	        for (var i = m_this._queue.length - 1; i >= 0; i -= 1) {
	          if (!m_this._needed(m_this._queue[i])) {
	            var discard = m_this._queue.splice(i, 1)[0];
	            m_this._processing += 1;
	            discard.__fetchQueue.reject();
	            delete discard.__fetchQueue;
	          }
	        }
	      }
	      while (m_this._processing < m_this._size && m_this._queue.length) {
	        var defer = m_this._queue.shift();
	        if (defer.__fetchQueue) {
	          m_this._processing += 1;
	          var needed = m_this._needed ? m_this._needed(defer) : true;
	          if (needed) {
	            defer.__fetchQueue.resolve();
	          } else {
	            defer.__fetchQueue.reject();
	          }
	          delete defer.__fetchQueue;
	        }
	      }
	      m_this._innextitem = false;
	    };

	    this.clear();
	    return this;
	  };

	  return fetchQueue;
	})();


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var featureLayer = __webpack_require__(207);
	var object = __webpack_require__(80);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class fileReader
	 *
	 * @class geo.fileReader
	 * @extends geo.object
	 * @returns {geo.fileReader}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var fileReader = function (arg) {
	  'use strict';
	  if (!(this instanceof fileReader)) {
	    return new fileReader(arg);
	  }
	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  arg = arg || {};

	  if (!(arg.layer instanceof featureLayer)) {
	    throw 'fileReader must be given a feature layer';
	  }

	  var m_layer = arg.layer;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the feature layer attached to the reader
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.layer = function () {
	    return m_layer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Tells the caller if it can handle the given file by returning a boolean.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.canRead = function () {
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Reads the file object and calls the done function when finished.  As an
	   * argument to done, provides a boolean that reports if the read was a
	   * success.  Possibly, it can call done with an object containing details
	   * of the read operation.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.read = function (file, done) {
	    done(false);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return a FileReader with handlers attached.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function newFileReader(done, progress) {
	    var reader = new FileReader();
	    if (progress) {
	      reader.onprogress = progress;
	    }
	    reader.onloadend = function () {
	      if (!reader.result) {
	        done(reader.error);
	      }
	      done(reader.result);
	    };
	    return reader;
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private method for reading a file object as a string.  Calls done with
	   * the string content when finished or an error object if unsuccessful.
	   * Optionally, the caller can provide a progress method that is called
	   * after reading each slice.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._getString = function (file, done, progress) {
	    var reader = newFileReader(done, progress);
	    reader.readAsText(file);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Like _getString, but returns an ArrayBuffer object.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._getArrayBuffer = function (file, done, progress) {
	    var reader = newFileReader(done, progress);
	    reader.readAsText(file);
	  };

	  return this;
	};

	inherit(fileReader, object);
	module.exports = fileReader;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class geomFeature
	 *
	 * @class geo.geomFeature
	 * @extends geo.feature
	 * @returns {geo.geomFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var geomFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof geomFeature)) {
	    return new geomFeature(arg);
	  }

	  var $ = __webpack_require__(1);

	  arg = arg || {};
	  feature.call(this, arg);

	  arg.style = arg.style === undefined ? $.extend({}, {
	    'color': [1.0, 1.0, 1.0],
	    'point_sprites': false,
	    'point_sprites_image': null
	  }, arg.style) : arg.style;

	  // Update style
	  this.style(arg.style);

	  return this;
	};

	inherit(geomFeature, feature);
	module.exports = geomFeature;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class graphFeature
	 *
	 * @class geo.greaphFeature
	 * @extends geo.feature
	 * @returns {geo.graphFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var graphFeature = function (arg) {
	  'use strict';

	  if (!(this instanceof graphFeature)) {
	    return new graphFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  var $ = __webpack_require__(1);
	  var util = __webpack_require__(196);
	  var registry = __webpack_require__(76);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_draw = this.draw,
	      s_style = this.style,
	      m_nodes = null,
	      m_points = null,
	      m_children = function (d) { return d.children; },
	      m_links = [],
	      s_init = this._init,
	      s_exit = this._exit;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(true, {},
	      {
	        nodes: {
	          radius: 5.0,
	          fill: true,
	          fillColor: { r: 1.0, g: 0.0, b: 0.0 },
	          strokeColor: { r: 0, g: 0, b: 0 }
	        },
	        links: {
	          strokeColor: { r: 0.0, g: 0.0, b: 0.0 }
	        },
	        linkType: 'path' /* 'path' || 'line' */
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    m_this.style(defaultStyle);
	    m_this.nodes(function (d) { return d; });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Call child _build methods
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    m_this.children().forEach(function (child) {
	      child._build();
	    });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Call child _update methods
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    m_this.children().forEach(function (child) {
	      child._update();
	    });
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Custom _exit method to remove all sub-features
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.data([]);
	    m_links.forEach(function (link) {
	      link._exit();
	      m_this.removeChild(link);
	    });
	    m_links = [];
	    m_points._exit();
	    m_this.removeChild(m_points);
	    s_exit();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set style
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.style = function (arg, arg2) {
	    var out = s_style.call(m_this, arg, arg2);
	    if (out !== m_this) {
	      return out;
	    }
	    // set styles for sub-features
	    m_points.style(arg.nodes);
	    m_links.forEach(function (l) {
	      l.style(arg.links);
	    });
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set links accessor.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.links = function (arg) {
	    if (arg === undefined) {
	      return m_children;
	    }

	    m_children = util.ensureFunction(arg);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set nodes
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.nodes = function (val) {
	    if (val === undefined) {
	      return m_nodes;
	    }
	    m_nodes = val;
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get internal node feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.nodeFeature = function () {
	    return m_points;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get internal link features
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.linkFeatures = function () {
	    return m_links;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build the feature for drawing
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {

	    var layer = m_this.layer(),
	        data = m_this.data(),
	        nLinks = 0,
	        style;

	    // get the feature style object
	    style = m_this.style();

	    // Bind data to the point nodes
	    m_points.data(data);
	    m_points.style(style.nodes);

	    // get links from node connections
	    data.forEach(function (source) {
	      (source.children || []).forEach(function (target) {
	        var link;
	        nLinks += 1;
	        if (m_links.length < nLinks) {
	          link = registry.createFeature(
	            style.linkType, layer, layer.renderer()
	          ).style(style.links);
	          m_this.addChild(link);
	          m_links.push(link);
	        }
	        m_links[nLinks - 1].data([source, target]);
	      });
	    });

	    m_links.splice(nLinks, m_links.length - nLinks).forEach(function (l) {
	      l._exit();
	      m_this.removeChild(l);
	    });

	    s_draw();
	    return m_this;
	  };

	  m_points = registry.createFeature(
	    'point',
	    this.layer(),
	    this.layer().renderer()
	  );
	  m_this.addChild(m_points);

	  if (arg.nodes) {
	    this.nodes(arg.nodes);
	  }

	  this._init(arg);
	  return this;
	};

	inherit(graphFeature, feature);
	module.exports = graphFeature;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var tile = __webpack_require__(223);

	module.exports = (function () {
	  'use strict';

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * This class defines a tile that is part of a standard "image pyramid", such
	   * as an open street map tile set.  Every tile is uniquely indexed by a row,
	   * column, and zoom level.  The number of rows/columns at zoom level z is
	   * `2^z`, the number of pixels per tile is configurable.
	   *
	   * By default, this class assumes that images are fetch from the url, but
	   * subclasses may define additional rendering steps to produce the images
	   * before passing them off to the handlers.
	   *
	   * @class geo.imageTile
	   * @param {object} spec The tile specification object
	   *
	   * @param {object} spec.index The global position of the tile
	   * @param {number} spec.index.x The x-coordinate (usually the column number)
	   * @param {number} spec.index.y The y-coordinate (usually the row number)
	   * @param {number} spec.index.level The zoom level
	   *
	   * @param {object?} spec.size The size of each tile
	   * @param {number} [spec.size.x=256] Width in pixels
	   * @param {number} [spec.size.y=256] Height in pixels
	   *
	   * @param {string} spec.url A url to the image
	   * @param {string} [spec.crossDomain='anonymous'] Image CORS attribute
	   *
	   * @param {object} spec.overlap The size of overlap with neighboring tiles
	   * @param {number} [spec.overlap.x=0]
	   * @param {number} [spec.overlap.y=0]
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var imageTile = function (spec) {
	    if (!(this instanceof imageTile)) {
	      return new imageTile(spec);
	    }

	    var $ = __webpack_require__(1);

	    spec.size = spec.size || {x: 256, y: 256};
	    this._image = null;

	    // Cache the coordinate scaling
	    this._cors = spec.crossDomain || 'anonymous';

	    // Call superclass constructor
	    tile.call(this, spec);

	    /**
	     * Read only accessor to the Image object used by the
	     * tile.  Note, this method does not gaurantee that the
	     * image data is available.  Use the promise interface
	     * to add asyncronous handlers.
	     * @returns {Image}
	     */
	    Object.defineProperty(this, 'image', {
	      get: function () { return this._image; }
	    });

	    /**
	     * Initiate the image request.
	     */
	    this.fetch = function () {
	      var defer;
	      if (!this._image) {
	        this._image = new Image(this.size.x, this.size.y);
	        // Only set the crossOrigin parameter if this is going across origins.
	        if (this._url.indexOf(':') >= 0 && this._url.indexOf('/') >= 0 &&
	            this._url.indexOf(':') < this._url.indexOf('/')) {
	          this._image.crossOrigin = this._cors;
	        }
	        defer = new $.Deferred();
	        this._image.onload = defer.resolve;
	        this._image.onerror = defer.reject;
	        this._image.src = this._url;

	        // attach a promise interface to `this`
	        defer.then(function () {
	          this._fetched = true;
	        }.bind(this)).promise(this);
	      }
	      return this;
	    };

	    /**
	     * Set the opacity of the tile to 0 and gradually fade in
	     * over the given number of milliseconds.  This will also
	     * resolve the embedded promise interface.
	     * @param {number} duration the duration of the animation in ms
	     * @returns {this} chainable
	     */
	    this.fadeIn = function (duration) {
	      var promise = this.fetch(), defer = new $.Deferred();
	      $(this._image).css('display', 'none');
	      promise.then(function () {
	        $(this._image).fadeIn(duration, function () {
	          defer.resolve();
	        });
	      }.bind(this));
	      return defer.promise(this);
	    };

	    return this;
	  };

	  inherit(imageTile, tile);
	  return imageTile;
	})();


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (function () {
	  'use strict';

	  var $ = __webpack_require__(1);

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * This class defines the raw interface for a "tile" on a map.  A tile is
	   * defined as a rectangular section of a map.  The base implementation
	   * is independent of the actual content of the tile, but assumes that
	   * the content is loaded asynchronously via a url.  The tile object
	   * has a promise-like interface.  For example,
	   *
	   * tile.then(function (data) {...}).catch(function (data) {...});
	   *
	   * @class geo.tile
	   * @param {Object} spec The tile specification object
	   *
	   * @param {Object} spec.index The global position of the tile
	   * @param {Number} spec.index.x The x-coordinate (usually the column number)
	   * @param {Number} spec.index.y The y-coordinate (usually the row number)
	   *
	   * @param {Object} spec.size The size of each tile
	   * @param {Number} spec.size.x Width (usually in pixels)
	   * @param {Number} spec.size.y Height (usually in pixels)
	   *
	   * @param {Object|String} spec.url A url or jQuery ajax config object
	   *
	   * @param {Object?} spec.overlap The size of overlap with neighboring tiles
	   * @param {Number} [spec.overlap.x=0]
	   * @param {Number} [spec.overlap.y=0]
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var tile = function (spec) {
	    if (!(this instanceof tile)) {
	      return new tile(spec);
	    }

	    this._index = spec.index;
	    this._size = spec.size;
	    this._overlap = spec.overlap || {x: 0, y: 0};
	    this._wrap = spec.wrap || {x: 1, y: 1};
	    this._url = spec.url;
	    this._fetched = false;
	    this._queue = spec.queue || null;

	    /**
	     * Return the index coordinates.
	     */
	    Object.defineProperty(this, 'index', {
	      get:
	        function () { return this._index; }
	    });

	    /**
	     * Return the tile sizes.
	     */
	    Object.defineProperty(this, 'size', {
	      get: function () { return this._size; }
	    });

	    /**
	     * Return the tile overlap sizes.
	     */
	    Object.defineProperty(this, 'overlap', {
	      get: function () { return this._overlap; }
	    });

	    /**
	     * Initiate the ajax request and add a promise interface
	     * to the tile object.  This method exists to allow
	     * derived classes the ability to override how the tile
	     * is obtained.  For example, imageTile uses an Image
	     * element rather than $.get.
	     */
	    this.fetch = function () {
	      if (!this._fetched) {
	        $.get(this._url).then(function () {
	          this._fetched = true;
	        }.bind(this)).promise(this);
	      }
	      return this;
	    };

	    /**
	     * Return whether this tile has been fetched already.
	     *
	     * @returns {boolean} True if the tile has been fetched.
	     */
	    this.fetched = function () {
	      return this._fetched;
	    };

	    /**
	     * Add a method to be called with the data when the ajax request is
	     * successfully resolved.
	     *
	     * @param {function?} onSuccess The success handler
	     * @param {function?} onFailure The failure handler
	     * @returns {this} Supports chained calling
	     *
	     */
	    this.then = function (onSuccess, onFailure) {
	      // both fetch and _queueAdd can replace the current then method
	      if (!this.fetched() && this._queue && this._queue.add && (!this.state ||
	          this.state() === 'pending')) {
	        this._queue.add(this, this.fetch);
	      } else {
	        this.fetch();
	      }
	      // Call then on the new promise
	      this.then(onSuccess, onFailure);
	      return this;
	    };

	    /**
	     * Add a method to be called with the data when the ajax fails.
	     *
	     * @param {function} method The rejection handler
	     * @returns {this} Supports chained calling
	     *
	     */
	    this.catch = function (method) {
	      this.then(undefined, method);
	      return this;
	    };

	    /**
	     * Return a unique string representation of the given tile useable
	     * as a hash key.  Possibly extend later to include url information
	     * to make caches aware of the tile source.
	     * @returns {string}
	     */
	    this.toString = function () {
	      return [this._index.level || 0, this._index.y, this._index.x].join('_');
	    };

	    /**
	     * Return the bounds of the tile given an index offset and
	     * a translation.
	     *
	     * @param {object} index The tile index containing (0, 0)
	     * @param {object} shift The coordinates of (0, 0) inside the tile
	     */
	    this.bounds = function (index, shift) {
	      var left, right, bottom, top;
	      left = this.size.x * (this.index.x - index.x) - this.overlap.x - shift.x;
	      right = left + this.size.x + this.overlap.x * 2;
	      top = this.size.y * (this.index.y - index.y) - this.overlap.y - shift.y;
	      bottom = top + this.size.y + this.overlap.y * 2;
	      return {
	        left: left,
	        right: right,
	        bottom: bottom,
	        top: top
	      };
	    };

	    /**
	     * Computes the global coordinates of the bottom edge.
	     * @returns {number}
	     */
	    Object.defineProperty(this, 'bottom', {
	      get: function () {
	        return this.size.y * (this.index.y + 1) + this.overlap.y;
	      }
	    });

	    /**
	     * Computes the global coordinates of the top edge.
	     * @returns {number}
	     */
	    Object.defineProperty(this, 'top', {
	      get: function () {
	        return this.size.y * this.index.y - this.overlap.y;
	      }
	    });

	    /**
	     * Computes the global coordinates of the left edge.
	     * @returns {number}
	     */
	    Object.defineProperty(this, 'left', {
	      get: function () {
	        return this.size.x * this.index.x - this.overlap.x;
	      }
	    });

	    /**
	     * Computes the global coordinates of the right edge.
	     * @returns {number}
	     */
	    Object.defineProperty(this, 'right', {
	      get: function () {
	        return this.size.x * (this.index.x + 1) + this.overlap.x;
	      }
	    });

	    /**
	     * Returns the global image size at this level.
	     * @returns {number}
	     */
	    Object.defineProperty(this, 'levelSize', {
	      value: {
	        width: Math.pow(2, this.index.level || 0) * this.size.x,
	        height: Math.pow(2, this.index.level || 0) * this.size.y
	      }
	    });

	    /**
	     * Set the opacity of the tile to 0 and gradually fade in
	     * over the given number of milliseconds.  This will also
	     * resolve the embedded promise interface.
	     * @param {number} duration the duration of the animation in ms
	     * @returns {this} chainable
	     */
	    this.fadeIn = function (duration) {
	      $.noop(duration);
	      return this;
	    };
	  };
	  return tile;
	})();


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFileReader = __webpack_require__(76).registerFileReader;
	var fileReader = __webpack_require__(219);

	//////////////////////////////////////////////////////////////////////////////
	/**
	* Create a new instance of class jsonReader
	*
	* @class geo.jsonReader
	* @extends geo.fileReader
	* @returns {geo.jsonReader}
	*/
	//////////////////////////////////////////////////////////////////////////////
	var jsonReader = function (arg) {
	  'use strict';
	  if (!(this instanceof jsonReader)) {
	    return new jsonReader(arg);
	  }

	  var $ = __webpack_require__(1);
	  var convertColor = __webpack_require__(196).convertColor;

	  var m_this = this;

	  fileReader.call(this, arg);

	  this.canRead = function (file) {
	    if (file instanceof File) {
	      return (file.type === 'application/json' || file.name.match(/\.json$/));
	    } else if (typeof file === 'string') {
	      try {
	        JSON.parse(file);
	      } catch (e) {
	        return false;
	      }
	      return true;
	    }
	    try {
	      if (Array.isArray(m_this._featureArray(file))) {
	        return true;
	      }
	    } catch (e) {}
	    return false;
	  };

	  this._readObject = function (file, done, progress) {
	    var object;
	    function onDone(fileString) {
	      if (typeof fileString !== 'string') {
	        done(false);
	      }

	      // We have two possibilities here:
	      // 1) fileString is a JSON string or is
	      // a URL.
	      try {
	        object = JSON.parse(fileString);
	        done(object);
	      } catch (e) {
	        if (!object) {
	          $.ajax({
	            type: 'GET',
	            url: fileString,
	            dataType: 'text'
	          }).done(function (data) {
	            object = JSON.parse(data);
	            done(object);
	          }).fail(function () {
	            done(false);
	          });
	        }
	      }
	    }

	    if (file instanceof File) {
	      m_this._getString(file, onDone, progress);
	    } else if (typeof file === 'string') {
	      onDone(file);
	    } else {
	      done(file);
	    }
	  };

	  /**
	   * Return an array of normalized geojson features.  This
	   * will do the following:
	   *
	   * 1. Turn bare geometries into features
	   * 2. Turn multi-geometry features into single geometry features
	   *
	   * Returns an array of Point, LineString, or Polygon features.
	   * @protected
	   */
	  this._featureArray = function (spec) {
	    var features, normalized = [];
	    switch (spec.type) {
	      case 'FeatureCollection':
	        features = spec.features;
	        break;

	      case 'Feature':
	        features = [spec];
	        break;

	      case 'GeometryCollection':
	        features = spec.geometries.map(function (g) {
	          return {
	            type: 'Feature',
	            geometry: g,
	            properties: {}
	          };
	        });
	        break;

	      case 'Point':
	      case 'LineString':
	      case 'Polygon':
	      case 'MultiPoint':
	      case 'MultiLineString':
	      case 'MultiPolygon':
	        features = [{
	          type: 'Feature',
	          geometry: spec,
	          properties: {}
	        }];
	        break;

	      default:
	        throw new Error('Invalid json type');
	    }

	    // flatten multi features
	    features.forEach(function (feature) {
	      Array.prototype.push.apply(normalized, m_this._feature(feature));
	    });

	    // remove features with empty geometries
	    normalized = normalized.filter(function (feature) {
	      return feature.geometry &&
	        feature.geometry.coordinates &&
	        feature.geometry.coordinates.length;
	    });
	    return normalized;
	  };

	  /**
	   * Normalize a feature object turning multi geometry features
	   * into an array of features, and single geometry features into
	   * an array containing one feature.
	   */
	  this._feature = function (spec) {
	    if (spec.type !== 'Feature') {
	      throw new Error('Invalid feature object');
	    }
	    switch (spec.geometry.type) {
	      case 'Point':
	      case 'LineString':
	      case 'Polygon':
	        return [spec];

	      case 'MultiPoint':
	      case 'MultiLineString':
	      case 'MultiPolygon':
	        return spec.geometry.coordinates.map(function (c) {
	          return {
	            type: 'Feature',
	            geometry: {
	              type: spec.geometry.type.replace('Multi', ''),
	              coordinates: c
	            },
	            properties: spec.properties
	          };
	        });

	      default:
	        throw new Error('Invalid geometry type');
	    }
	  };

	  /**
	   * Convert from a geojson position array into a geojs position object.
	   */
	  this._position = function (p) {
	    return {
	      x: p[0],
	      y: p[1],
	      z: p[2] || 0
	    };
	  };

	  /**
	   * Defines a style accessor the returns the given
	   * value of the property object, or a default value.
	   *
	   * @protected
	   * @param {string} prop The property name
	   * @param {object} default The default value
	   * @param {object} [spec] The argument containing the main property object
	   * @param {function} [convert] An optional conversion function
	   */
	  this._style = function (prop, _default, spec, convert) {
	    convert = convert || function (d) { return d; };
	    _default = convert(_default);
	    return function (d, i, e, j) {
	      var p;
	      if (spec) {
	        p = spec[j].properties;
	      } else {
	        p = d.properties;
	      }
	      if (p.hasOwnProperty(prop)) {
	        return convert(p[prop]);
	      }
	      return _default;
	    };
	  };

	  this.read = function (file, done, progress) {

	    function _done(object) {
	      var features, allFeatures = [], points, lines, polygons;

	      features = m_this._featureArray(object);

	      // process points
	      points = features.filter(function (f) { return f.geometry.type === 'Point'; });
	      if (points.length) {
	        allFeatures.push(
	          m_this.layer().createFeature('point')
	            .data(points)
	            .position(function (d) {
	              return m_this._position(d.geometry.coordinates);
	            })
	            .style({
	              fill: m_this._style('fill', true),
	              fillColor: m_this._style('fillColor', '#ff7800', null, convertColor),
	              fillOpacity: m_this._style('fillOpacity', 0.8),
	              stroke: m_this._style('stroke', true),
	              strokeColor: m_this._style('strokeColor', '#000000', null, convertColor),
	              strokeWidth: m_this._style('strokeWidth', 1),
	              strokeOpacity: m_this._style('strokeOpacity', 1),
	              radius: m_this._style('radius', 8)
	            })
	        );
	      }

	      // process lines
	      lines = features.filter(function (f) { return f.geometry.type === 'LineString'; });
	      if (lines.length) {
	        allFeatures.push(
	          m_this.layer().createFeature('line')
	            .data(lines)
	            .line(function (d) {
	              return d.geometry.coordinates;
	            })
	            .position(m_this._position)
	            .style({
	              strokeColor: m_this._style('strokeColor', '#ff7800', lines, convertColor),
	              strokeWidth: m_this._style('strokeWidth', 4, lines),
	              strokeOpacity: m_this._style('strokeOpacity', 0.5, lines)
	            })
	        );
	      }

	      // process polygons
	      polygons = features.filter(function (f) { return f.geometry.type === 'Polygon'; });
	      if (polygons.length) {
	        allFeatures.push(
	          m_this.layer().createFeature('polygon')
	            .data(polygons)
	            .polygon(function (d, i) {
	              return {
	                outer: d.geometry.coordinates[0],
	                inner: d.geometry.coordinates.slice(1)
	              };
	            })
	            .position(m_this._position)
	            .style({
	              fill: m_this._style('fill', true),
	              fillColor: m_this._style('fillColor', '#b0de5c', polygons, convertColor),
	              fillOpacity: m_this._style('fillOpacity', 0.8, polygons),
	              stroke: m_this._style('stroke', true),
	              strokeColor: m_this._style('strokeColor', '#999999', polygons, convertColor),
	              strokeWidth: m_this._style('strokeWidth', 2, polygons),
	              strokeOpacity: m_this._style('strokeOpacity', 1, polygons)
	            })
	        );
	      }
	      if (done) {
	        done(allFeatures);
	      }
	    }

	    m_this._readObject(file, _done, progress);
	  };
	};

	inherit(jsonReader, fileReader);
	registerFileReader('jsonReader', jsonReader);
	module.exports = jsonReader;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var vgl = __webpack_require__(81);
	var inherit = __webpack_require__(4);
	var sceneObject = __webpack_require__(79);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Creates a new map object
	 *
	 * Map coordinates for default world map, where c = half circumference at
	 * equator in meters, o = origin:
	 *   (-c, c) + o                   (c, c) + o
	 *            (center.x, center.y) + o            <-- center of viewport
	 *   (-c, -c) + o                  (c, -c) + o
	 *
	 * @class geo.map
	 * @extends geo.sceneObject
	 *
	 * *** Always required ***
	 * @param {string} node DOM selector for the map container
	 *
	 * *** Required when using a domain/CS different from OSM ***
	 * @param {string|geo.transform} [gcs='EPSG:3857']
	 *   The main coordinate system of the map
	 * @param {number} [maxZoom=16] The maximum zoom level
	 * @param {string|geo.transform} [ingcs='EPSG:4326']
	 *   The default coordinate system of interface calls.
	 * @param {number} [unitsPerPixel=156543] GCS to pixel unit scaling at zoom 0
	 *   (i.e. meters per pixel or degrees per pixel).
	 * @param {object?} maxBounds The maximum visable map bounds
	 * @param {number} [maxBounds.left=-20037508] The left bound
	 * @param {number} [maxBounds.right=20037508] The right bound
	 * @param {number} [maxBounds.bottom=-20037508] The bottom bound
	 * @param {number} [maxBounds.top=20037508] The top bound
	 *
	 * *** Initial view ***
	 * @param {number} [zoom=4] Initial zoom
	 * @param {object?} center Map center
	 * @param {number} [center.x=0]
	 * @param {number} [center.y=0]
	 * @param {number} [rotation=0] Clockwise rotation in radians
	 * @param {number?} width The map width (default node width)
	 * @param {number?} height The map height (default node height)
	 *
	 * *** Navigation ***
	 * @param {number} [min=0]  Minimum zoom level (though fitting to the viewport
	 *   may make it so this is smaller than the smallest possible value)
	 * @param {number} [max=16]  Maximum zoom level
	 * @param {boolean} [discreteZoom=false]  True to only allow integer zoom
	 *   levels.  False for any zoom level.
	 * @param {boolean} [allowRotation=true]  False prevents rotation, true allows
	 *   any rotation.  If a function, the function is called with a rotation
	 *   (angle in radians) and returns a valid rotation (this can be used to
	 *   constrain the rotation to a range or specific values).
	 *
	 * *** Advanced parameters ***
	 * @param {geo.camera?} camera The camera to control the view
	 * @param {geo.mapInteractor?} interactor The UI event handler
	 * @param {geo.clock?} clock The clock used to synchronize time events
	 * @param {boolean} [autoResize=true] Adjust map size on window resize
	 * @param {boolean} [clampBoundsX=false] Prevent panning outside of the
	 *   maximum bounds in the horizontal direction.
	 * @param {boolean} [clampBoundsY=true] Prevent panning outside of the
	 *   maximum bounds in the vertical direction.
	 * @param {boolean} [clampZoom=true] Prevent zooming out so that the map area
	 *   is smaller than the window.
	 *
	 * @returns {geo.map}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var map = function (arg) {
	  'use strict';
	  if (!(this instanceof map)) {
	    return new map(arg);
	  }
	  arg = arg || {};

	  if (arg.node === undefined || arg.node === null) {
	    console.warn('map creation requires a node');
	    return this;
	  }

	  sceneObject.call(this, arg);

	  var camera = __webpack_require__(202);
	  var transform = __webpack_require__(6);
	  var util = __webpack_require__(196);
	  var registry = __webpack_require__(76);
	  var geo_event = __webpack_require__(5);
	  var mapInteractor = __webpack_require__(210);
	  var clock = __webpack_require__(214);
	  var uiLayer = __webpack_require__(226);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private member variables
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_exit = this._exit,
	      // See https://en.wikipedia.org/wiki/Web_Mercator
	      // phiMax = 180 / Math.PI * (2 * Math.atan(Math.exp(Math.PI)) - Math.PI / 2),
	      m_x = 0,
	      m_y = 0,
	      m_node = $(arg.node),
	      m_width = arg.width || m_node.width() || 512,
	      m_height = arg.height || m_node.height() || 512,
	      m_gcs = arg.gcs === undefined ? 'EPSG:3857' : arg.gcs,
	      m_ingcs = arg.ingcs === undefined ? 'EPSG:4326' : arg.ingcs,
	      m_center = {x: 0, y: 0},
	      m_zoom = arg.zoom === undefined ? 4 : arg.zoom,
	      m_rotation = 0,
	      m_fileReader = null,
	      m_interactor = null,
	      m_validZoomRange = {min: 0, max: 16, origMin: 0},
	      m_transition = null,
	      m_queuedTransition = null,
	      m_clock = null,
	      m_discreteZoom = arg.discreteZoom ? true : false,
	      m_allowRotation = (typeof arg.allowRotation === 'function' ?
	                         arg.allowRotation : (arg.allowRotation === undefined ?
	                         true : !!arg.allowRotation)),
	      m_maxBounds = arg.maxBounds || {},
	      m_camera = arg.camera || camera(),
	      m_unitsPerPixel,
	      m_clampBoundsX,
	      m_clampBoundsY,
	      m_clampZoom,
	      m_origin,
	      m_scale = {x: 1, y: 1, z: 1}; // constant and ignored for the moment

	  /* Compute the maximum bounds on our map projection.  By default, x ranges
	   * from [-180, 180] in the interface projection, and y matches the x range in
	   * the map (not the interface) projection.  For images, this might be
	   * [0, width] and [0, height] instead. */
	  var mcx = ((m_maxBounds.left || 0) + (m_maxBounds.right || 0)) / 2,
	      mcy = ((m_maxBounds.bottom || 0) + (m_maxBounds.top || 0)) / 2;
	  m_maxBounds.left = transform.transformCoordinates(m_ingcs, m_gcs, {
	    x: m_maxBounds.left !== undefined ? m_maxBounds.left : -180, y: mcy
	  }).x;
	  m_maxBounds.right = transform.transformCoordinates(m_ingcs, m_gcs, {
	    x: m_maxBounds.right !== undefined ? m_maxBounds.right : 180, y: mcy
	  }).x;
	  m_maxBounds.top = (m_maxBounds.top !== undefined ?
	    transform.transformCoordinates(m_ingcs, m_gcs, {
	      x: mcx, y: m_maxBounds.top}).y : m_maxBounds.right);
	  m_maxBounds.bottom = (m_maxBounds.bottom !== undefined ?
	    transform.transformCoordinates(m_ingcs, m_gcs, {
	      x: mcx, y: m_maxBounds.bottom}).y : m_maxBounds.left);
	  m_unitsPerPixel = (arg.unitsPerPixel || (
	    m_maxBounds.right - m_maxBounds.left) / 256);

	  m_camera.viewport = {width: m_width, height: m_height};
	  arg.center = util.normalizeCoordinates(arg.center);
	  arg.autoResize = arg.autoResize === undefined ? true : arg.autoResize;
	  m_clampBoundsX = arg.clampBoundsX === undefined ? false : arg.clampBoundsX;
	  m_clampBoundsY = arg.clampBoundsY === undefined ? true : arg.clampBoundsY;
	  m_clampZoom = arg.clampZoom === undefined ? true : arg.clampZoom;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the number of world space units per display pixel at the given
	   * zoom level.
	   *
	   * @param {Number} [zoom=0] The target zoom level
	   * @param {Number?} unit If present, set the unitsPerPixel otherwise return
	   *   the current value.
	   * @returns {Number|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.unitsPerPixel = function (zoom, unit) {
	    zoom = zoom || 0;
	    if (unit) {
	      // get the units at level 0
	      m_unitsPerPixel = Math.pow(2, zoom) * unit;

	      // redraw all the things
	      m_this.draw();
	      return m_this;
	    }
	    return Math.pow(2, -zoom) * m_unitsPerPixel;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the clampBoundsX setting.  If changed, adjust the bounds of the
	   * map as needed.
	   *
	   * @param {boolean?} clamp The new clamp value.
	   * @returns {boolean|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clampBoundsX = function (clamp) {
	    if (clamp === undefined) {
	      return m_clampBoundsX;
	    }
	    if (clamp !== m_clampBoundsX) {
	      m_clampBoundsX = !!clamp;
	      m_this.pan({x: 0, y: 0});
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the clampBoundsY setting.  If changed, adjust the bounds of the
	   * map as needed.
	   *
	   * @param {boolean?} clamp The new clamp value.
	   * @returns {boolean|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clampBoundsY = function (clamp) {
	    if (clamp === undefined) {
	      return m_clampBoundsY;
	    }
	    if (clamp !== m_clampBoundsY) {
	      m_clampBoundsY = !!clamp;
	      m_this.pan({x: 0, y: 0});
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the clampZoom setting.  If changed, adjust the bounds of the map
	   * as needed.
	   *
	   * @param {boolean?} clamp The new clamp value.
	   * @returns {boolean|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clampZoom = function (clamp) {
	    if (clamp === undefined) {
	      return m_clampZoom;
	    }
	    if (clamp !== m_clampZoom) {
	      m_clampZoom = !!clamp;
	      reset_minimum_zoom();
	      m_this.zoom(m_zoom);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the allowRotation setting.  If changed, adjust the map as needed.
	   *
	   * @param {boolean|function} allowRotation the new allowRotation value.
	   * @returns {boolean|function|this}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.allowRotation = function (allowRotation) {
	    if (allowRotation === undefined) {
	      return m_allowRotation;
	    }
	    if (typeof allowRotation !== 'function') {
	      allowRotation = !!allowRotation;
	    }
	    if (allowRotation !== m_allowRotation) {
	      m_allowRotation = allowRotation;
	      m_this.rotation(m_rotation);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the map's world coordinate origin in gcs coordinates
	   *
	   * @returns {object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.origin = function () {
	    return $.extend({}, m_origin);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the map's world coordinate scaling relative gcs units
	   *
	   * @returns {object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.scale = function () {
	    return $.extend({}, m_scale);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the camera
	   *
	   * @returns {geo.camera}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.camera = function () {
	    return m_camera;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get map gcs
	   *
	   * @returns {string}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.gcs = function (arg) {
	    if (arg === undefined) {
	      return m_gcs;
	    }
	    if (arg !== m_gcs) {
	      var oldCenter = m_this.center(undefined, undefined);
	      m_gcs = arg;
	      reset_minimum_zoom();
	      var newZoom = fix_zoom(m_zoom);
	      if (newZoom !== m_zoom) {
	        m_this.zoom(newZoom);
	      }
	      m_this.center(oldCenter, undefined);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get map interface gcs
	   *
	   * @returns {string}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.ingcs = function (arg) {
	    if (arg === undefined) {
	      return m_ingcs;
	    }
	    m_ingcs = arg;
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get root node of the map
	   *
	   * @returns {object}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.node = function () {
	    return m_node;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set zoom level of the map
	   *
	   * @param {number} val if undefined, return the current zoom level.
	   *    Otherwise, the new zoom level to set.
	   * @param {object} origin if present, an object with 'geo' containing the
	   *    gcs coordinates where the action started and 'map' containing the
	   *    display coordinates of the same location before the zoom is applied.
	   * @param {boolean} ignoreDiscreteZoom if true, ignore the discreteZoom
	   *    option when determining the new view.
	   * @returns {Number|geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.zoom = function (val, origin, ignoreDiscreteZoom) {
	    if (val === undefined) {
	      return m_zoom;
	    }
	    var evt, bounds;
	    /* If we are zooming around a point, ignore the clamp bounds */
	    var aroundPoint = (origin && (origin.mapgcs || origin.geo) && origin.map);
	    var ignoreClampBounds = aroundPoint;

	    /* The ignoreDiscreteZoom flag is intended to allow non-integer zoom values
	     * during animation. */
	    val = fix_zoom(val, ignoreDiscreteZoom);
	    if (val === m_zoom) {
	      return m_this;
	    }

	    m_zoom = val;

	    bounds = m_this.boundsFromZoomAndCenter(
	      val, m_center, m_rotation, null, ignoreDiscreteZoom, ignoreClampBounds);
	    m_this.modified();

	    camera_bounds(bounds, m_rotation);
	    evt = {
	      geo: {},
	      zoomLevel: m_zoom,
	      screenPosition: origin ? origin.map : undefined
	    };
	    m_this.geoTrigger(geo_event.zoom, evt);

	    if (aroundPoint) {
	      var shifted = m_this.gcsToDisplay(origin.mapgcs || origin.geo,
	                                        origin.mapgcs ? null : undefined);
	      m_this.pan({x: origin.map.x - shifted.x, y: origin.map.y - shifted.y},
	                 ignoreDiscreteZoom, true);
	    } else {
	      m_this.pan({x: 0, y: 0}, ignoreDiscreteZoom);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Pan the map by (x: dx, y: dy) pixels.
	   *
	   * @param {Object} delta x and y delta in display pixels
	   * @param {boolean} ignoreDiscreteZoom if true, ignore the discreteZoom
	   *    option when determining the new view.
	   * @param {boolean} ignoreClampBounds if true or 'limited', ignore the
	   *    clampBoundsX options (up to a point, see fix_bounds) when determining
	   *    the new view.
	   * @returns {geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.pan = function (delta, ignoreDiscreteZoom, ignoreClampBounds) {
	    var evt = {
	      geo: {},
	      screenDelta: delta
	    };

	    if (delta.x || delta.y) {
	      var unit = m_this.unitsPerPixel(m_zoom);

	      var sinr = Math.sin(m_rotation), cosr = Math.cos(m_rotation);
	      m_camera.pan({
	        x: (delta.x * cosr - (-delta.y) * sinr) * unit,
	        y: (delta.x * sinr + (-delta.y) * cosr) * unit
	      });
	    }
	    /* If m_clampBounds* is true, clamp the pan */
	    var bounds = m_camera.bounds;
	    bounds = fix_bounds(bounds, m_rotation, ignoreClampBounds === 'limited' ? {
	      x: delta.x, y: delta.y, unit: unit} : undefined,
	      ignoreClampBounds === true);
	    if (bounds !== m_camera.bounds) {
	      var panPos = m_this.gcsToDisplay({
	        x: m_camera.bounds.left, y: m_camera.bounds.top}, null);
	      bounds = m_this.boundsFromZoomAndCenter(m_zoom, {
	        x: (bounds.left + bounds.right) / 2,
	        y: (bounds.top + bounds.bottom) / 2
	      }, m_rotation, null, ignoreDiscreteZoom, true);
	      camera_bounds(bounds, m_rotation);
	      var clampPos = m_this.gcsToDisplay({
	        x: m_camera.bounds.left, y: m_camera.bounds.top}, null);
	      evt.screenDelta.x += clampPos.x - panPos.x;
	      evt.screenDelta.y += clampPos.y - panPos.y;
	    }

	    m_center = m_camera.displayToWorld({
	      x: m_width / 2,
	      y: m_height / 2
	    });

	    m_this.geoTrigger(geo_event.pan, evt);

	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the map rotation.  The rotation is performed around the current
	   * view center.  Rotation mostly ignores clampBoundsX, as the behavior
	   * feels peculiar otherwise.
	   *
	   * @param {Object} rotation angle in radians (positive is clockwise)
	   * @param {Object} origin is specified, rotate about this origin
	   * @param {boolean} ignoreRotationFunc if true, don't constrain the rotation.
	   * @returns {geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.rotation = function (rotation, origin, ignoreRotationFunc) {
	    if (rotation === undefined) {
	      return m_rotation;
	    }
	    var aroundPoint = (origin && origin.geo && origin.map);

	    rotation = fix_rotation(rotation, ignoreRotationFunc);
	    if (rotation === m_rotation) {
	      return m_this;
	    }
	    m_rotation = rotation;

	    var bounds = m_this.boundsFromZoomAndCenter(
	        m_zoom, m_center, m_rotation, null, ignoreRotationFunc, true);
	    m_this.modified();

	    camera_bounds(bounds, m_rotation);

	    var evt = {
	      geo: {},
	      rotation: m_rotation,
	      screenPosition: origin ? origin.map : undefined
	    };

	    m_this.geoTrigger(geo_event.rotate, evt);

	    if (aroundPoint) {
	      var shifted = m_this.gcsToDisplay(origin.geo);
	      m_this.pan({x: origin.map.x - shifted.x, y: origin.map.y - shifted.y},
	                 undefined, true);
	    } else {
	      m_this.pan({x: 0, y: 0}, undefined, true);
	    }
	    /* Changing the rotation can change our minimum zoom */
	    reset_minimum_zoom();
	    m_this.zoom(m_zoom, undefined, ignoreRotationFunc);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set center of the map to the given geographic coordinates, or get the
	   * current center.  Uses bare objects {x: 0, y: 0}.
	   *
	   * @param {Object} coordinates
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.  If setting the
	   *    center, they are converted from this gcs to the map projection.  The
	   *    returned center are converted from the map projection to this gcs.
	   * @param {boolean} ignoreDiscreteZoom if true, ignore the discreteZoom
	   *    option when determining the new view.
	   * @param {boolean} ignoreClampBounds if true or 'limited', ignore the
	   *    clampBoundsX options (up to a point, see fix_bounds) when determining
	   *    the new view.
	   * @returns {Object|geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.center = function (coordinates, gcs, ignoreDiscreteZoom,
	                          ignoreClampBounds) {
	    var center;
	    if (coordinates === undefined) {
	      center = $.extend({}, m_this.worldToGcs(m_center, gcs));
	      return center;
	    }

	    // get the screen coordinates of the new center
	    center = m_this.gcsToWorld(coordinates, gcs);

	    camera_bounds(m_this.boundsFromZoomAndCenter(
	        m_zoom, center, m_rotation, null, ignoreDiscreteZoom,
	        ignoreClampBounds), m_rotation);
	    m_this.modified();
	    // trigger a pan event
	    m_this.geoTrigger(geo_event.pan, {
	      geo: coordinates,
	      screenDelta: null
	    });
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add layer to the map
	   *
	   * @param {geo.layer} layer to be added to the map
	   * @return {geom.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createLayer = function (layerName, arg) {
	    arg = arg || {};
	    var newLayer = registry.createLayer(
	      layerName, m_this, arg);

	    if (newLayer) {
	      m_this.addChild(newLayer);
	      m_this.children().forEach(function (c) {
	        if (c instanceof uiLayer) {
	          c.moveToTop();
	        }
	      });
	      newLayer._update();
	      m_this.modified();

	      m_this.geoTrigger(geo_event.layerAdd, {
	        type: geo_event.layerAdd,
	        target: m_this,
	        layer: newLayer
	      });
	    }

	    return newLayer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Remove layer from the map
	   *
	   * @param {geo.layer} layer that should be removed from the map
	   * @return {geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.deleteLayer = function (layer) {

	    if (layer !== null && layer !== undefined) {
	      layer._exit();
	      m_this.removeChild(layer);

	      m_this.modified();

	      m_this.geoTrigger(geo_event.layerRemove, {
	        type: geo_event.layerRemove,
	        target: m_this,
	        layer: layer
	      });
	    }

	    /// Return deleted layer (similar to createLayer) as in the future
	    /// we may provide extension of this method to support deletion of
	    /// layer using id or some sort.
	    return layer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the size of the map.
	   *
	   * @param {Object?} arg
	   * @param {Number} arg.width width in pixels
	   * @param {Number} arg.height height in pixels
	   * @returns {Object} An object containing width and height as keys
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.size = function (arg) {
	    if (arg === undefined) {
	      return {
	        width: m_width,
	        height: m_height
	      };
	    }
	    m_this.resize(0, 0, arg.width, arg.height);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the rotated size of the map.  This is the width and height of the
	   * non-rotated area necessary to enclose the rotated area in pixels.
	   *
	   * @returns {Object} An object containing width and height as keys
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.rotatedSize = function () {
	    if (!this.rotation()) {
	      return {
	        width: m_width,
	        height: m_height
	      };
	    }
	    var bds = rotate_bounds_center(
	        {x: 0, y: 0}, {width: m_width, height: m_height}, this.rotation());
	    return {
	      width: Math.abs(bds.right - bds.left),
	      height: Math.abs(bds.top - bds.bottom)
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Resize map (deprecated)
	   *
	   * @param {Number} x x-offset in display space
	   * @param {Number} y y-offset in display space
	   * @param {Number} w width in display space
	   * @param {Number} h height in display space
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.resize = function (x, y, w, h) {

	    // store the original center and restore it after the resize
	    var oldCenter = m_this.center();
	    m_x = x;
	    m_y = y;
	    m_width = w || m_width;
	    m_height = h || m_height;

	    reset_minimum_zoom();
	    var newZoom = fix_zoom(m_zoom);
	    if (newZoom !== m_zoom) {
	      m_this.zoom(newZoom);
	    }
	    m_this.camera().viewport = {width: m_width, height: m_height};
	    m_this.center(oldCenter);

	    m_this.geoTrigger(geo_event.resize, {
	      type: geo_event.resize,
	      target: m_this,
	      x: m_x,
	      y: m_y,
	      width: m_width,
	      height: m_height
	    });

	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from gcs coordinates to map world coordinates.
	   * @param {object} c The input coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @param {string?} gcs The gcs of the input (map.gcs() by default)
	   * @return {object} World space coordinates
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.gcsToWorld = function (c, gcs) {
	    gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	    if (gcs !== m_gcs) {
	      c = transform.transformCoordinates(gcs, m_gcs, c);
	    }
	    if (m_origin.x || m_origin.y || m_origin.z) {
	      c = transform.affineForward(
	        {origin: m_origin},
	        [c]
	      )[0];
	    } else if (!('z' in c)) {
	      c = {x: c.x, y: c.y, z: 0};
	    }
	    return c;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from map world coordinates to gcs coordinates.
	   * @param {object} c The input coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.
	   * @return {object} GCS space coordinates
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.worldToGcs = function (c, gcs) {
	    if (m_origin.x || m_origin.y || m_origin.z) {
	      c = transform.affineInverse(
	        {origin: m_origin},
	        [c]
	      )[0];
	    } else if (!('z' in c)) {
	      c = {x: c.x, y: c.y, z: 0};
	    }
	    gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	    if (gcs !== m_gcs) {
	      c = transform.transformCoordinates(m_gcs, gcs, c);
	    }
	    return c;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from gcs coordinates to display coordinates.
	   *
	   *    gcsToWorld | worldToDisplay
	   *
	   * @param {object} c The input coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.
	   * @return {object} Display space coordinates
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.gcsToDisplay = function (c, gcs) {
	    c = m_this.gcsToWorld(c, gcs);
	    return m_this.worldToDisplay(c);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from world coordinates to display coordinates using the attached
	   * camera.
	   * @param {object} c The input coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @return {object} Display space coordinates
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.worldToDisplay = function (c) {
	    return m_camera.worldToDisplay(c);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from display to gcs coordinates
	   *
	   *    displayToWorld | worldToGcs
	   *
	   * @param {object} c The input display coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.
	   * @return {object} GCS space coordinates
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.displayToGcs = function (c, gcs) {
	    c = m_this.displayToWorld(c); // done via camera
	    return m_this.worldToGcs(c, gcs);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from display coordinates to world coordinates using the attached
	   * camera.
	   * @param {object} c The input coordinate to convert
	   * @param {object} c.x
	   * @param {object} c.y
	   * @param {object} [c.z=0]
	   * @return {object} World space coordinates
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.displayToWorld = function (c) {
	    return m_camera.displayToWorld(c);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Manually force to render map
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	    var i, layers = m_this.children();

	    m_this.geoTrigger(geo_event.draw, {
	      type: geo_event.draw,
	      target: m_this
	    });

	    m_this._update();

	    for (i = 0; i < layers.length; i += 1) {
	      layers[i].draw();
	    }

	    m_this.geoTrigger(geo_event.drawEnd, {
	      type: geo_event.drawEnd,
	      target: m_this
	    });

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Attach a file reader to a layer in the map to be used as a drop target.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.fileReader = function (readerType, opts) {
	    var layer, renderer;
	    opts = opts || {};
	    if (!readerType) {
	      return m_fileReader;
	    }
	    layer = opts.layer;
	    if (!layer) {
	      renderer = opts.renderer;
	      if (!renderer) {
	        renderer = 'd3';
	      }
	      layer = m_this.createLayer('feature', {renderer: renderer});
	    }
	    opts.layer = layer;
	    opts.renderer = renderer;
	    m_fileReader = registry.createFileReader(readerType, opts);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize the map
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {

	    if (m_node === undefined || m_node === null) {
	      throw 'Map require DIV node';
	    }

	    m_node.css('position', 'relative');
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update map
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function (request) {
	    var i, layers = m_this.children();
	    for (i = 0; i < layers.length; i += 1) {
	      layers[i]._update(request);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Exit this map
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.exit = function () {
	    var i, layers = m_this.children();
	    for (i = 0; i < layers.length; i += 1) {
	      layers[i]._exit();
	    }
	    if (m_this.interactor()) {
	      m_this.interactor().destroy();
	      m_this.interactor(null);
	    }
	    m_this.node().off('.geo');
	    /* make sure the map node has nothing left in it */
	    m_this.node().empty();
	    $(window).off('resize', resizeSelf);
	    s_exit();
	  };

	  this._init(arg);

	  // set up drag/drop handling
	  this.node().on('dragover.geo', function (e) {
	    var evt = e.originalEvent;

	    if (m_this.fileReader()) {
	      evt.stopPropagation();
	      evt.preventDefault();
	      evt.dataTransfer.dropEffect = 'copy';
	    }
	  })
	  .on('drop.geo', function (e) {
	    var evt = e.originalEvent, reader = m_this.fileReader(),
	        i, file;

	    function done() {
	      m_this.draw();
	    }

	    if (reader) {
	      evt.stopPropagation();
	      evt.preventDefault();

	      for (i = 0; i < evt.dataTransfer.files.length; i += 1) {
	        file = evt.dataTransfer.files[i];
	        if (reader.canRead(file)) {
	          reader.read(file, done); // to do: trigger event on done
	        }
	      }
	    }
	  });

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the map interactor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.interactor = function (arg) {
	    if (arg === undefined) {
	      return m_interactor;
	    }
	    m_interactor = arg;

	    // this makes it possible to set a null interactor
	    // i.e. map.interactor(null);
	    if (m_interactor) {
	      /* If we set a map interactor, make sure we have a tabindex */
	      if (!m_node.attr('tabindex')) {
	        m_node.attr('tabindex', 0);
	      }
	      m_interactor.map(m_this);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the map clock
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.clock = function (arg) {
	    if (arg === undefined) {
	      return m_clock;
	    }
	    m_clock = arg;

	    if (m_clock) {
	      m_clock.object(m_this);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the min/max zoom range.
	   *
	   * @param {Object} arg {min: minimumzoom, max: maximumzom}
	   * @param {boolean} noRefresh if true, don't update the map if the zoom level
	   *                            has changed.
	   * @returns {Object|geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.zoomRange = function (arg, noRefresh) {
	    if (arg === undefined) {
	      return $.extend({}, m_validZoomRange);
	    }
	    if (arg.max !== undefined) {
	      m_validZoomRange.max = arg.max;
	    }
	    if (arg.min !== undefined) {
	      m_validZoomRange.min = m_validZoomRange.origMin = arg.min;
	    }
	    reset_minimum_zoom();
	    if (!noRefresh) {
	      m_this.zoom(m_zoom);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Start an animated zoom/pan/rotate.  If a second transition is requested
	   * while a transition is already in progress, a new transition is created
	   * that is functionally from whereever the map has moved to (possibly partway
	   * through the first transition) going to the end point of the new
	   * transition.
	   *
	   * Options:
	   * <pre>
	   *   opts = {
	   *     center: { x: ... , y: ... } // the new center
	   *     zoom: ... // the new zoom level
	   *     zoomOrigin: ... // an origin to use when zooming.  Optional.
	   *     rotation: ... // the new rotation angle
	   *     duration: ... // the duration (in ms) of the transition
	   *     ease: ... // an easing function [0, 1] -> [0, 1]
	   *   }
	   * </pre>
	   *
	   * Call with no arguments to return the current transition information.
	   *
	   * @param {object?} opts
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.  Applies only to the
	   *    center coordinate of the opts and to converting zoom values to height,
	   *    if specified.
	   * @returns {geo.map}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.transition = function (opts, gcs, animTime) {

	    if (opts === undefined) {
	      return m_transition;
	    }

	    if (m_transition) {
	      /* The queued transition needs to combine the current transition's
	       * endpoint, any other queued transition, and the new transition to be
	       * complete. */
	      var transitionEnd = $.extend(true, {}, m_transition.end);
	      if (transitionEnd.center && m_gcs !== m_ingcs) {
	        transitionEnd.center = transform.transformCoordinates(
	          m_gcs, m_ingcs, transitionEnd.center);
	      }
	      m_queuedTransition = $.extend(
	        {}, transitionEnd || {}, m_queuedTransition || {}, opts);
	      return m_this;
	    }

	    function interp1(p0, p1, t) {
	      return p0 + (p1 - p0) * t;
	    }
	    function defaultInterp(p0, p1) {
	      return function (t) {
	        var result = [];
	        $.each(p0, function (idx) {
	          result.push(interp1(p0[idx], p1[idx], t));
	        });
	        return result;
	      };
	    }

	    var units = m_this.unitsPerPixel(0);

	    // Transform zoom level into z-coordinate and inverse
	    function zoom2z(z) {
	      return vgl.zoomToHeight(z + 1, m_width, m_height) * units;
	    }
	    function z2zoom(z) {
	      return vgl.heightToZoom(z / units, m_width, m_height) - 1;
	    }

	    var defaultOpts = {
	      center: m_this.center(undefined, null),
	      zoom: m_this.zoom(),
	      rotation: m_this.rotation(),
	      duration: 1000,
	      ease: function (t) {
	        return t;
	      },
	      interp: defaultInterp,
	      done: null,
	      zCoord: true
	    };

	    if (opts.center) {
	      gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	      opts = $.extend(true, {}, opts);
	      opts.center = util.normalizeCoordinates(opts.center);
	      if (gcs !== m_gcs) {
	        opts.center = transform.transformCoordinates(gcs, m_gcs, opts.center);
	      }
	    }
	    opts = $.extend(true, {}, defaultOpts, opts);

	    m_transition = {
	      start: {
	        center: m_this.center(undefined, null),
	        zoom: m_this.zoom(),
	        rotation: m_this.rotation()
	      },
	      end: {
	        center: opts.center,
	        zoom: fix_zoom(opts.zoom),
	        rotation: fix_rotation(opts.rotation, undefined, true)
	      },
	      ease: opts.ease,
	      zCoord: opts.zCoord,
	      done: opts.done,
	      duration: opts.duration,
	      zoomOrigin: opts.zoomOrigin
	    };

	    m_transition.interp = opts.interp([
	      m_transition.start.center.x,
	      m_transition.start.center.y,
	      opts.zCoord ? zoom2z(m_transition.start.zoom) : m_transition.start.zoom,
	      m_transition.start.rotation
	    ], [
	      m_transition.end.center.x,
	      m_transition.end.center.y,
	      opts.zCoord ? zoom2z(m_transition.end.zoom) : m_transition.end.zoom,
	      m_transition.end.rotation
	    ]);

	    function anim(time) {
	      var done = m_transition.done,
	          next = m_queuedTransition;
	      if (m_transition.cancel === true) {
	        /* Finish cancelling a transition. */
	        m_this.geoTrigger(geo_event.transitioncancel, opts);
	        if (done) {
	          done({
	            cancel: true,
	            source: m_transition.cancelSource,
	            transition: m_transition
	          });
	        }
	        m_transition = null;
	        /* There will only be a queuedTransition if it was created after this
	         * transition was cancelled */
	        if (m_queuedTransition) {
	          next = m_queuedTransition;
	          m_queuedTransition = null;
	          m_this.transition(next, undefined, time);
	        }
	        return;
	      }

	      if (!m_transition.start.time) {
	        m_transition.start.time = time;
	        m_transition.end.time = time + opts.duration;
	      }
	      m_transition.time = time - m_transition.start.time;
	      if (time >= m_transition.end.time || next) {
	        if (!next) {
	          var needZoom = m_zoom !== fix_zoom(m_transition.end.zoom);
	          m_this.center(m_transition.end.center, null, needZoom, needZoom);
	          m_this.zoom(m_transition.end.zoom, m_transition.zoomOrigin);
	          m_this.rotation(fix_rotation(m_transition.end.rotation));
	        }

	        m_this.geoTrigger(geo_event.transitionend, opts);

	        if (done) {
	          done({next: !!next});
	        }

	        m_transition = null;
	        if (m_queuedTransition) {
	          next = m_queuedTransition;
	          m_queuedTransition = null;
	          m_this.transition(next, undefined, time);
	        }

	        return;
	      }

	      var z = m_transition.ease(
	        (time - m_transition.start.time) / opts.duration
	      );

	      var p = m_transition.interp(z);
	      if (m_transition.zCoord) {
	        p[2] = z2zoom(p[2]);
	      }
	      if (fix_zoom(p[2], true) === m_zoom) {
	        m_this.center({
	          x: p[0],
	          y: p[1]
	        }, null, true, true);
	      } else {
	        m_center = m_this.gcsToWorld({x: p[0], y: p[1]}, null, true, true);
	        m_this.zoom(p[2], m_transition.zoomOrigin, true);
	      }
	      m_this.rotation(p[3], undefined, true);

	      window.requestAnimationFrame(anim);
	    }

	    m_this.geoTrigger(geo_event.transitionstart, opts);

	    if (geo_event.cancelNavigation) {
	      m_transition = null;
	      m_this.geoTrigger(geo_event.transitionend, opts);
	      return m_this;
	    } else if (geo_event.cancelAnimation) {
	      // run the navigation synchronously
	      opts.duration = 0;
	      anim(0);
	    } else if (animTime) {
	      anim(animTime);
	    } else {
	      window.requestAnimationFrame(anim);
	    }
	    return m_this;
	  };

	  /**
	   * Cancel any existing transition.  The transition will send a cancel event
	   * at the next animation frame, but no further activity occurs.
	   *
	   * @param {string} [source] optional cause of the cancel.  This can be any
	   *                 value, but something like <method name>.<action> is
	   *                 recommended to allow other functions to determine the
	   *                 source and cause of the transition being canceled.
	   * @returns {bool} true if a transition was in progress.
	   */
	  this.transitionCancel = function (source) {
	    if (m_transition && (m_transition.cancel !== true || m_queuedTransition)) {
	      m_transition.cancel = true;
	      m_transition.cancelSource = source || m_transition.cancelSource || '';
	      m_queuedTransition = null;
	      return true;
	    }
	    return false;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the locations of the current map corners as latitudes/longitudes.
	   * When provided the argument should be an object containing the keys left,
	   * top, right, bottom declaring the desired new map bounds.  The new bounds
	   * will contain at least the min/max lat/lngs provided modified by clamp
	   * settings.  In any case, the actual new bounds will be returned by this
	   * function.
	   *
	   * @param {geo.geoBounds} [bds] The requested map bounds
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.  If setting the
	   *    bounds, they are converted from this gcs to the map projection.  The
	   *    returned bounds are converted from the map projection to this gcs.
	   * @return {geo.geoBounds} The actual new map bounds
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.bounds = function (bds, gcs) {
	    var nav;

	    gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	    if (bds !== undefined) {
	      if (gcs !== m_gcs) {
	        var trans = transform.transformCoordinates(gcs, m_gcs, [{
	          x: bds.left, y: bds.top}, {x: bds.right, y: bds.bottom}]);
	        bds = {
	          left: trans[0].x,
	          top: trans[0].y,
	          right: trans[1].x,
	          bottom: trans[1].y
	        };
	      }
	      bds = fix_bounds(bds, m_rotation);
	      nav = m_this.zoomAndCenterFromBounds(bds, m_rotation, null);

	      // This might have consequences in terms of bounds/zoom clamping.
	      // What behavior do we expect from this method in that case?
	      m_this.zoom(nav.zoom);
	      m_this.center(nav.center, null);
	    }

	    return m_this.boundsFromZoomAndCenter(m_zoom, m_center, m_rotation, gcs,
	                                          true);
	  };

	  this.maxBounds = function (bounds, gcs) {
	    gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	    if (bounds === undefined) {
	      return {
	        left: transform.transformCoordinates(m_gcs, gcs, {
	          x: m_maxBounds.left, y: 0}).x,
	        right: transform.transformCoordinates(m_gcs, gcs, {
	          x: m_maxBounds.right, y: 0}).x,
	        bottom: transform.transformCoordinates(m_gcs, gcs, {
	          x: 0, y: m_maxBounds.bottom}).y,
	        top: transform.transformCoordinates(m_gcs, gcs, {
	          x: 0, y: m_maxBounds.top}).y
	      };
	    }
	    var cx = ((bounds.left || 0) + (bounds.right || 0)) / 2,
	        cy = ((bounds.bottom || 0) + (bounds.top || 0)) / 2;
	    if (bounds.left !== undefined) {
	      m_maxBounds.left = transform.transformCoordinates(gcs, m_gcs, {
	        x: bounds.left, y: cy}).x;
	    }
	    if (bounds.right !== undefined) {
	      m_maxBounds.right = transform.transformCoordinates(gcs, m_gcs, {
	        x: bounds.right, y: cy}).x;
	    }
	    if (bounds.bottom !== undefined) {
	      m_maxBounds.bottom = transform.transformCoordinates(gcs, m_gcs, {
	        x: cx, y: bounds.bottom}).y;
	    }
	    if (bounds.top !== undefined) {
	      m_maxBounds.top = transform.transformCoordinates(gcs, m_gcs, {
	        x: cx, y: bounds.top}).y;
	    }
	    reset_minimum_zoom();
	    m_this.zoom(m_zoom);
	    m_this.pan({x: 0, y: 0});
	    return this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the center zoom level necessary to display the given lat/lon bounds.
	   *
	   * @param {geo.geoBounds} [bds] The requested map bounds
	   * @param {number} rotation Rotation in clockwise radians.
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.
	   * @return {object} Object containing keys 'center' and 'zoom'
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.zoomAndCenterFromBounds = function (bounds, rotation, gcs) {
	    var center, zoom;

	    gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	    if (gcs !== m_gcs) {
	      var trans = transform.transformCoordinates(gcs, m_gcs, [{
	        x: bounds.left, y: bounds.top}, {x: bounds.right, y: bounds.bottom}]);
	      bounds = {
	        left: trans[0].x,
	        top: trans[0].y,
	        right: trans[1].x,
	        bottom: trans[1].y
	      };
	    }
	    if (bounds.left >= bounds.right || bounds.bottom >= bounds.top) {
	      throw new Error('Invalid bounds provided');
	    }

	    // calculate the zoom to fit the bounds
	    zoom = fix_zoom(calculate_zoom(bounds, rotation));

	    // clamp bounds if necessary
	    bounds = fix_bounds(bounds, rotation);

	    /* This relies on having the map projection coordinates be uniform
	     * regardless of location.  If not, the center will not be correct. */
	    // calculate new center
	    center = {
	      x: (bounds.left + bounds.right) / 2 - m_origin.x,
	      y: (bounds.top + bounds.bottom) / 2 - m_origin.y
	    };
	    if (gcs !== m_gcs) {
	      center = transform.transformCoordinates(m_gcs, gcs, center);
	    }
	    return {
	      zoom: zoom,
	      center: center
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the bounds that will be displayed with the given zoom and center.
	   *
	   * Note: the bounds may not have the requested zoom and center due to map
	   * restrictions.
	   *
	   * @param {number} zoom The requested zoom level
	   * @param {geo.geoPosition} center The requested center
	   * @param {number} rotation The requested rotation
	   * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	   *    null to use the map gcs, or any other transform.
	   * @param {boolean} ignoreDiscreteZoom if true, ignore the discreteZoom
	   *    option when determining the new view.
	   * @param {boolean} ignoreClampBounds if true or 'limited', ignore the
	   *    clampBoundsX options (up to a point, see fix_bounds) when determining
	   *    the new view.
	   * @return {geo.geoBounds}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.boundsFromZoomAndCenter = function (zoom, center, rotation, gcs,
	        ignoreDiscreteZoom, ignoreClampBounds) {
	    var width, height, halfw, halfh, bounds, units;

	    gcs = (gcs === null ? m_gcs : (gcs === undefined ? m_ingcs : gcs));
	    // preprocess the arguments
	    zoom = fix_zoom(zoom, ignoreDiscreteZoom);
	    units = m_this.unitsPerPixel(zoom);
	    center = m_this.gcsToWorld(center, gcs);

	    // get half the width and height in world coordinates
	    width = m_width * units;
	    height = m_height * units;
	    halfw = width / 2;
	    halfh = height / 2;

	    // calculate the bounds.  This is only valid if the map projection has
	    // uniform units in each direction.  If not, then worldToGcs should be
	    // used.

	    if (rotation) {
	      center.x += m_origin.x;
	      center.y += m_origin.y;
	      bounds = rotate_bounds_center(
	        center, {width: width, height: height}, rotation);
	      // correct the bounds when clamping is enabled
	      bounds.width = width;
	      bounds.height = height;
	      bounds = fix_bounds(bounds, rotation, undefined, ignoreClampBounds);
	    } else {
	      bounds = {
	        left: center.x - halfw + m_origin.x,
	        right: center.x + halfw + m_origin.x,
	        bottom: center.y - halfh + m_origin.y,
	        top: center.y + halfh + m_origin.y
	      };
	      // correct the bounds when clamping is enabled
	      bounds = fix_bounds(bounds, 0, undefined, ignoreClampBounds);
	    }
	    if (gcs !== m_gcs) {
	      var bds = transform.transformCoordinates(
	        m_gcs, gcs,
	        [[bounds.left, bounds.top], [bounds.right, bounds.bottom]]);
	      bounds = {
	        left: bds[0][0], top: bds[0][1], right: bds[1][0], bottom: bds[1][1]
	      };
	    }
	    /* Add the original width and height of the viewport before rotation. */
	    bounds.width = width;
	    bounds.height = height;
	    return bounds;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/set the discrete zoom flag.
	   *
	   * @param {bool} If specified, the discrete zoom flag.
	   * @return {bool} The current discrete zoom flag if no parameter is
	   *                specified, otherwise the map object.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.discreteZoom = function (discreteZoom) {
	    if (discreteZoom === undefined) {
	      return m_discreteZoom;
	    }
	    discreteZoom = discreteZoom ? true : false;
	    if (m_discreteZoom !== discreteZoom) {
	      m_discreteZoom = discreteZoom;
	      if (m_discreteZoom) {
	        m_this.zoom(Math.round(m_this.zoom()));
	      }
	      m_this.interactor().options({discreteZoom: m_discreteZoom});
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the layers contained in the map.
	   * Alias of {@linkcode geo.sceneObject.children}.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.layers = this.children;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the attribution notice displayed on the bottom right corner of
	   * the map.  The content of this notice is managed by individual layers.
	   * This method queries all of the visible layers and joins the individual
	   * attribution notices into a single element.  By default, this method
	   * is called on each of the following events:
	   *
	   *   * geo.event.layerAdd
	   *   * geo.event.layerRemove
	   *
	   * In addition, layers should call this method when their own attribution
	   * notices has changed.  Users, in general, should not need to call this.
	   * @returns {this} Chainable
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateAttribution = function () {
	    // clear any existing attribution content
	    m_this.node().find('.geo-attribution').remove();

	    // generate a new attribution node
	    var $a = $('<div/>')
	      .addClass('geo-attribution')
	      .css({
	        position: 'absolute',
	        right: '0px',
	        bottom: '0px',
	        'padding-right': '5px',
	        cursor: 'auto',
	        font: '11px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif',
	        'z-index': '1001',
	        background: 'rgba(255,255,255,0.7)',
	        clear: 'both',
	        display: 'block',
	        'pointer-events': 'auto'
	      }).on('mousedown', function (evt) {
	        evt.stopPropagation();
	      });

	    // append content from each layer
	    m_this.children().forEach(function (layer) {
	      var content = layer.attribution();
	      if (content) {
	        $('<span/>')
	          .addClass('geo-attribution-layer')
	          .css({
	            'padding-left': '5px'
	          })
	          .html(content)
	          .appendTo($a);
	      }
	    });

	    $a.appendTo(m_this.node());
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  //
	  // The following are some private methods for interacting with the camera.
	  // In order to hide the complexity of dealing with map aspect ratios,
	  // clamping behavior, reseting zoom levels on resize, etc. from the
	  // layers, the map handles camera movements directly.  This requires
	  // passing all camera movement events through the map initially.  The
	  // map uses these methods to fix up the events according to the constraints
	  // of the display and passes the event to the layers.
	  //
	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Calculate the scaling factor to fit the given map bounds
	   * into the viewport with the correct aspect ratio.
	   * @param {object} bounds A desired bounds
	   * @return {object} Multiplicative aspect ratio correction
	   * @private
	   */
	  function camera_scaling(bounds) {
	    var width = bounds.right - bounds.left,
	        height = bounds.top - bounds.bottom,
	        ar_bds = Math.abs(width / height),
	        ar_vp = m_width / m_height,
	        sclx, scly;

	    if (ar_bds > ar_vp) {
	      // fit left and right
	      sclx = 1;

	      // grow top and bottom
	      scly = ar_bds / ar_vp;
	    } else {
	      // fit top and bottom
	      scly = 1;

	      // grow left and right
	      sclx = ar_vp / ar_bds;
	    }
	    return {x: sclx, y: scly};
	  }

	  /**
	   * Adjust a set of bounds based on a rotation.
	   * @private.
	   */
	  function rotate_bounds(bounds, rotation) {
	    if (rotation) {
	      var center = {
	        x: (bounds.left + bounds.right) / 2,
	        y: (bounds.top + bounds.bottom) / 2
	      };
	      var size = {
	        width: Math.abs(bounds.left - bounds.right),
	        height: Math.abs(bounds.top - bounds.bottom)
	      };
	      bounds = rotate_bounds_center(center, size, rotation);
	    }
	    return bounds;
	  }

	  /**
	   * Generate a set of bounds based on a center point, a width and height, and
	   * a rotation.
	   * @private.
	   */
	  function rotate_bounds_center(center, size, rotation) {
	    // calculate the half width and height
	    var width = size.width / 2, height = size.height / 2;
	    var sinr = Math.sin(rotation), cosr = Math.cos(rotation);
	    var ul = {}, ur = {}, ll = {}, lr = {};
	    ul.x = center.x + (-width) * cosr - (-height) * sinr;
	    ul.y = center.y + (-width) * sinr + (-height) * cosr;
	    ur.x = center.x + width * cosr - (-height) * sinr;
	    ur.y = center.y + width * sinr + (-height) * cosr;
	    ll.x = center.x + (-width) * cosr - height * sinr;
	    ll.y = center.y + (-width) * sinr + height * cosr;
	    lr.x = center.x + width * cosr - height * sinr;
	    lr.y = center.y + width * sinr + height * cosr;
	    return {
	      left: Math.min(ul.x, ur.x, ll.x, lr.x),
	      right: Math.max(ul.x, ur.x, ll.x, lr.x),
	      bottom: Math.min(ul.y, ur.y, ll.y, lr.y),
	      top: Math.max(ul.y, ur.y, ll.y, lr.y)
	    };
	  }

	  /**
	   * Calculate the minimum zoom level to fit the given
	   * bounds inside the view port using the view port size,
	   * the given bounds, and the number of units per
	   * pixel.  The method sets the valid zoom bounds as well
	   * as the current zoom level to be within that range.
	   * @private
	   */
	  function calculate_zoom(bounds, rotation) {
	    if (rotation === undefined) {
	      rotation = m_rotation;
	    }
	    bounds = rotate_bounds(bounds, rotation);
	    // compare the aspect ratios of the viewport and bounds
	    var scl = camera_scaling(bounds), z;

	    if (scl.y > scl.x) {
	      // left to right matches exactly
	      // center map vertically and have blank borders on the
	      // top and bottom (or repeat tiles)
	      z = -Math.log2(
	        Math.abs(bounds.right - bounds.left) * scl.x /
	        (m_width * m_unitsPerPixel)
	      );
	    } else {
	      // top to bottom matches exactly, blank border on the
	      // left and right (or repeat tiles)
	      z = -Math.log2(
	        Math.abs(bounds.top - bounds.bottom) * scl.y /
	        (m_height * m_unitsPerPixel)
	      );
	    }
	    return z;
	  }

	  /**
	   * Reset the minimum zoom level given the current window size.
	   * @private
	   */
	  function reset_minimum_zoom() {
	    if (m_clampZoom) {
	      m_validZoomRange.min = Math.max(
	          m_validZoomRange.origMin, calculate_zoom(m_maxBounds));
	    } else {
	      m_validZoomRange.min = m_validZoomRange.origMin;
	    }
	  }

	  /**
	   * Return the nearest valid zoom level to the requested zoom.
	   * @private
	   * @param {number} zoom a zoom level to adjust to current settings
	   * @param {boolean} ignoreDiscreteZoom if true, ignore the discreteZoom
	   *    option when determining the new view.
	   * @returns {number} the zoom level clamped to the allowed zoom range and
	   *    with other settings applied.
	   */
	  function fix_zoom(zoom, ignoreDiscreteZoom) {
	    zoom = Math.max(
	      Math.min(
	        m_validZoomRange.max,
	        zoom
	      ),
	      m_validZoomRange.min
	    );
	    if (m_discreteZoom && !ignoreDiscreteZoom) {
	      zoom = Math.round(zoom);
	      if (zoom < m_validZoomRange.min) {
	        zoom = Math.ceil(m_validZoomRange.min);
	      }
	    }
	    return zoom;
	  }

	  /**
	   * Return a valid rotation angle.
	   * @private
	   */
	  function fix_rotation(rotation, ignoreRotationFunc, noRangeLimit) {
	    if (!m_allowRotation) {
	      return 0;
	    }
	    if (!ignoreRotationFunc && typeof m_allowRotation === 'function') {
	      rotation = m_allowRotation(rotation);
	    }
	    /* Ensure that the rotation is in the range [0, 2pi) */
	    if (!noRangeLimit) {
	      var range = Math.PI * 2;
	      rotation = (rotation % range) + (rotation >= 0 ? 0 : range);
	      if (Math.min(Math.abs(rotation), Math.abs(rotation - range)) < 0.00001) {
	        rotation = 0;
	      }
	    }
	    return rotation;
	  }

	  /**
	   * Return the nearest valid bounds maintaining the width and height.  Does
	   * nothing if m_clampBounds* is false.  If a delta is specified, will only
	   * clamp if the out-of-bounds condition would be worse.  If ignoreClampBounds
	   * is true, clamping is applied only to prevent more than half the image from
	   * being off screen.
	   * @private
	   * @param {object} bounds: the new bounds to apply in map gcs coordinates.
	   * @param {number} rotation: the angle of rotation in radians.  May be falsy
	   *    to have no rotation.
	   * @param {object} delta: if present, the shift in position in screen
	   *    coordinates.  Bounds will only be adjusted if the bounds would be
	   *    more out of position after the shift.
	   * @param {boolean} ignoreClampBounds: if true and clampBoundX is set, allow
	   *    the bounds to be less clamped.  Specifically, the map's maxBounds can
	   *    be shifted so that they lie no further than the center of the bounds
	   *    (rather than being forced to be at the edge).
	   */
	  function fix_bounds(bounds, rotation, delta, ignoreClampBounds) {
	    if (!m_clampBoundsX && !m_clampBoundsY) {
	      return bounds;
	    }
	    var dx, dy, maxBounds = m_maxBounds;
	    if (rotation) {
	      maxBounds = $.extend({}, m_maxBounds);
	      /* When rotated, expand the maximum bounds so that they will allow the
	       * corners to be visible.  We know the rotated bounding box, plus the
	       * original maximum bounds.  To fit the corners of the maximum bounds, we
	       * can expand the total bounds by the same factor that the rotated
	       * bounding box is expanded from the non-rotated bounding box (for a
	       * small rotation, this is sin(rotation) * (original bounding box height)
	       * in the width).  This feels like appropriate behaviour with one of the
	       * two bounds clamped.  With both, it seems mildly peculiar. */
	      var bw = Math.abs(bounds.right - bounds.left),
	          bh = Math.abs(bounds.top - bounds.bottom),
	          absinr = Math.abs(Math.sin(rotation)),
	          abcosr = Math.abs(Math.cos(rotation)),
	          ow, oh;
	      if (bounds.width && bounds.height) {
	        ow = bounds.width;
	        oh = bounds.height;
	      } else if (Math.abs(absinr - abcosr) < 0.0005) {
	        /* If we are close to a 45 degree rotation, it is ill-determined to
	         * compute the original (pre-rotation) bounds width and height.  In
	         * this case, assume that we are using the map's aspect ratio. */
	        if (m_width && m_height) {
	          var aspect = Math.abs(m_width / m_height);
	          var fac = Math.pow(1 + Math.pow(aspect, 2), 0.5);
	          ow = Math.max(bw, bh) / fac;
	          oh = ow * aspect;
	        } else {
	          /* Fallback if we don't have width or height */
	          ow = bw * abcosr;
	          oh = bh * absinr;
	        }
	      } else {
	        /* Compute the pre-rotation (original) bounds width and height */
	        ow = (abcosr * bw - absinr * bh) / (abcosr * abcosr - absinr * absinr);
	        oh = (abcosr * bh - absinr * bw) / (abcosr * abcosr - absinr * absinr);
	      }
	      /* Our maximum bounds are expanded based on the projected length of a
	       * tilted side of the original bounding box in the rotated bounding box.
	       * To handle all rotations, take the minimum difference in width or
	       * height. */
	      var bdx = bw - Math.max(abcosr * ow, absinr * oh),
	          bdy = bh - Math.max(abcosr * oh, absinr * ow);
	      maxBounds.left -= bdx;
	      maxBounds.right += bdx;
	      maxBounds.top += bdy;
	      maxBounds.bottom -= bdy;
	    }
	    if (ignoreClampBounds) {
	      maxBounds = {
	        left: maxBounds.left - (bounds.right - bounds.left) / 2,
	        right: maxBounds.right + (bounds.right - bounds.left) / 2,
	        top: maxBounds.top - (bounds.bottom - bounds.top) / 2,
	        bottom: maxBounds.bottom + (bounds.bottom - bounds.top) / 2
	      };
	    }
	    if (m_clampBoundsX) {
	      if (bounds.right - bounds.left > maxBounds.right - maxBounds.left) {
	        dx = maxBounds.left - ((bounds.right - bounds.left - (
	          maxBounds.right - maxBounds.left)) / 2) - bounds.left;
	      } else if (bounds.left < maxBounds.left) {
	        dx = maxBounds.left - bounds.left;
	      } else if (bounds.right > maxBounds.right) {
	        dx = maxBounds.right - bounds.right;
	      }
	      if (dx && (!delta || delta.x * dx > 0)) {
	        if (delta && Math.abs(dx) > Math.abs(delta.x * delta.unit)) {
	          dx = Math.abs(delta.x * delta.unit) * dx / Math.abs(dx);
	        }
	        bounds = {
	          left: bounds.left += dx,
	          right: bounds.right += dx,
	          top: bounds.top,
	          bottom: bounds.bottom
	        };
	      }
	    }
	    if (m_clampBoundsY) {
	      if (bounds.top - bounds.bottom > maxBounds.top - maxBounds.bottom) {
	        dy = maxBounds.bottom - ((bounds.top - bounds.bottom - (
	          maxBounds.top - maxBounds.bottom)) / 2) - bounds.bottom;
	      } else if (bounds.top > maxBounds.top) {
	        dy = maxBounds.top - bounds.top;
	      } else if (bounds.bottom < maxBounds.bottom) {
	        dy = maxBounds.bottom - bounds.bottom;
	      }
	      if (dy && (!delta || -delta.y * dy > 0)) {
	        if (delta && Math.abs(dy) > Math.abs(delta.y * delta.unit)) {
	          dy = Math.abs(delta.y * delta.unit) * dy / Math.abs(dy);
	        }
	        bounds = {
	          top: bounds.top += dy,
	          bottom: bounds.bottom += dy,
	          left: bounds.left,
	          right: bounds.right
	        };
	      }
	    }
	    return bounds;
	  }

	  /**
	   * Call the camera bounds method with the given bounds, but
	   * correct for the viewport aspect ratio.
	   * @private
	   */
	  function camera_bounds(bounds, rotation) {
	    m_camera.rotation = rotation || 0;
	    /* When dealing with rotation, use the original width and height of the
	     * bounds, as the rotation will have expanded them. */
	    if (bounds.width && bounds.height && rotation) {
	      var cx = (bounds.left + bounds.right) / 2,
	          cy = (bounds.top + bounds.bottom) / 2;
	      m_camera.viewFromCenterSizeRotation({x: cx, y: cy}, bounds, rotation);
	    } else {
	      m_camera.bounds = bounds;
	    }
	    /* Update the center to what was set. */
	    m_center = {
	      x: (m_camera.bounds.left + m_camera.bounds.right) / 2,
	      y: (m_camera.bounds.top + m_camera.bounds.bottom) / 2
	    };
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  //
	  // All the methods are now defined.  From here, we are initializing all
	  // internal variables and event handlers.
	  //
	  ////////////////////////////////////////////////////////////////////////////

	  // Set the world origin
	  m_origin = {x: 0, y: 0};

	  // Fix the zoom level (minimum and initial)
	  this.zoomRange(arg, true);
	  m_zoom = fix_zoom(m_zoom);
	  m_rotation = fix_rotation(m_rotation);
	  // Now update to the correct center and zoom level
	  this.center($.extend({}, arg.center || m_center), undefined);

	  if (arg.interactor !== null) {
	    this.interactor(arg.interactor || mapInteractor({discreteZoom: m_discreteZoom}));
	  }
	  this.clock(arg.clock || clock());

	  function resizeSelf() {
	    m_this.resize(0, 0, m_node.width(), m_node.height());
	  }

	  if (arg.autoResize) {
	    $(window).resize(resizeSelf);
	  }

	  // attach attribution updates to layer events
	  m_this.geoOn([
	    geo_event.layerAdd,
	    geo_event.layerRemove
	  ], m_this.updateAttribution);

	  return this;
	};

	/**
	 * General object specification for map types.  Any additional
	 * values in the object are passed to the map constructor.
	 * @typedef geo.map.spec
	 * @type {object}
	 * @property {object[]} [data=[]] The default data array to
	 * apply to each feature if none exists
	 * @property {geo.layer.spec[]} [layers=[]] Layers to create
	 */

	/**
	 * Create a map from an object.  Any errors in the creation
	 * of the map will result in returning null.
	 * @param {geo.map.spec} spec The object specification
	 * @returns {geo.map|null}
	 */
	map.create = function (spec) {
	  'use strict';

	  var _map = map(spec),
	      layer = __webpack_require__(201);

	  /* If the spec is bad, we still end up with an object, but it won't have a
	   * zoom function */
	  if (!_map || !_map.zoom) {
	    console.warn('Could not create map.');
	    return null;
	  }

	  spec.data = spec.data || [];
	  spec.layers = spec.layers || [];

	  spec.layers.forEach(function (l) {
	    l.data = l.data || spec.data;
	    l.layer = layer.create(_map, l);
	  });

	  return _map;
	};

	inherit(map, sceneObject);
	module.exports = map;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerLayer = __webpack_require__(76).registerLayer;
	var layer = __webpack_require__(201);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class uiLayer
	 *
	 * @class geo.gui.uiLayer
	 * @extends {geo.layer}
	 * @returns {geo.gui.uiLayer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var uiLayer = function (arg) {
	  'use strict';

	  var createWidget = __webpack_require__(76).createWidget;

	  // The widget stays fixed on the screen.
	  arg.renderer = 'dom';
	  arg.sticky = false;

	  if (!(this instanceof uiLayer)) {
	    return new uiLayer(arg);
	  }
	  layer.call(this, arg);

	  var m_this = this,
	      s_exit = this._exit;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a new ui control
	   *
	   * @returns {geo.gui.Widget} Will return a new control widget
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.createWidget = function (widgetName, arg) {
	    var newWidget = createWidget(widgetName, m_this, arg);

	    // We only want top level widgets to be a child of the uiLayer
	    if (!(arg && 'parent' in arg)) {
	      m_this.addChild(newWidget);
	    }

	    newWidget._init(arg);
	    m_this.modified();
	    return newWidget;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete a ui control
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.deleteWidget = function (widget) {
	    widget._exit();
	    m_this.removeChild(widget);
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Free memory and destroy the layer.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.children().forEach(function (child) {
	      m_this.deleteWidget(child);
	    });
	    s_exit();
	  };
	};

	inherit(uiLayer, layer);

	registerLayer('ui', uiLayer);
	module.exports = uiLayer;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (function () {
	  'use strict';

	  var $ = __webpack_require__(1);
	  var inherit = __webpack_require__(4);
	  var tileLayer = __webpack_require__(228);
	  var registry = __webpack_require__(76);
	  var quadFeature = __webpack_require__(211);

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a new instance of osmLayer
	   *
	   * @class geo.osmLayer
	   * @extends geo.featureLayer
	   *
	   * @param {object} arg - arg can contain following keys: baseUrl,
	   *        imageFormat (such as png or jpeg), and displayLast
	   *        (to decide whether or not render tiles from last zoom level).
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var osmLayer = function (arg) {

	    var imageTile = __webpack_require__(222);

	    if (!(this instanceof osmLayer)) {
	      return new osmLayer(arg);
	    }
	    if (arg.mapOpacity !== undefined && arg.opacity === undefined) {
	      arg.opacity = arg.mapOpacity;
	    }
	    tileLayer.call(this, arg);

	    /* mapOpacity is just another name for the layer opacity. */
	    this.mapOpacity = this.opacity;

	    /**
	     * Returns an instantiated imageTile object with the given indices.  This
	     * method always returns a new tile object.  Use `_getTileCached`
	     * to use the caching layer.
	     * @param {object} index The tile index
	     * @param {number} index.x
	     * @param {number} index.y
	     * @param {number} index.level
	     * @param {object} source The tile index used for constructing the url
	     * @param {number} source.x
	     * @param {number} source.y
	     * @param {number} source.level
	     * @returns {geo.tile}
	     */
	    this._getTile = function (index, source) {
	      var urlParams = source || index;
	      return imageTile({
	        index: index,
	        size: {x: this._options.tileWidth, y: this._options.tileHeight},
	        queue: this._queue,
	        url: this._options.url(urlParams.x, urlParams.y, urlParams.level || 0,
	                               this._options.subdomains)
	      });
	    }.bind(this);
	  };

	  /**
	   * This object contains the default options used to initialize the osmLayer.
	   */
	  osmLayer.defaults = $.extend({}, tileLayer.defaults, {
	    minLevel: 0,
	    maxLevel: 18,
	    tileOverlap: 0,
	    tileWidth: 256,
	    tileHeight: 256,
	    tileOffset : function (level) {
	      var s = Math.pow(2, level - 1) * 256;
	      return {x: s, y: s};
	    },
	    wrapX: true,
	    wrapY: false,
	    url: 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
	    attribution: 'Tile data &copy; <a href="http://osm.org/copyright">' +
	      'OpenStreetMap</a> contributors'
	  });

	  inherit(osmLayer, tileLayer);
	  /* By default, ask to support image quads.  If the user needs full
	   * reprojection, they will need to require the
	   * quadFeature.capabilities.imageFull feature */
	  registry.registerLayer('osm', osmLayer, [quadFeature.capabilities.image]);
	  return osmLayer;
	})();


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (function () {
	  'use strict';

	  var inherit = __webpack_require__(4);
	  var featureLayer = __webpack_require__(207);

	  /**
	   * Standard modulo operator where the output is in [0, b) for all inputs.
	   * @private
	   */
	  function modulo(a, b) {
	    return ((a % b) + b) % b;
	  }

	  /**
	   * Pick a subdomain from a list of subdomains based on a the tile location.
	   *
	   * @param {number} x: the x tile coordinate.
	   * @param {number} y: the y tile coordinate.
	   * @param {list} subdomains: the list of known subdomains.
	   */
	  function m_getTileSubdomain(x, y, subdomains) {
	    return subdomains[modulo(x + y, subdomains.length)];
	  }

	  /**
	   * Returns an OSM tile server formatting function from a standard format
	   * string. Replaces {s}, {z}, {x}, and {y}.
	   *
	   * @param {string} base The tile format string
	   * @returns: a conversion function.
	   * @private.
	   */
	  function m_tileUrlFromTemplate(base) {
	    return function (x, y, z, subdomains) {
	      return base.replace('{s}', m_getTileSubdomain(x, y, subdomains))
	        .replace('{z}', z)
	        .replace('{x}', x)
	        .replace('{y}', y);
	    };
	  }

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * This method defines a tileLayer, which is an abstract class defining a
	   * layer divided into tiles of arbitrary data.  Notably, this class provides
	   * the core functionality of the osmLayer, but hooks exist to render tiles
	   * dynamically from vector data, or to display arbitrary grids of images
	   * in a custom coordinate system.  When multiple zoom levels are present
	   * in a given dataset, this class assumes that the space occupied by
	   * tile (i, j) at level z is covered by a 2x2 grid of tiles at zoom
	   * level z + 1:
	   *
	   *   (2i, 2j),     (2i, 2j + 1)
	   *   (2i + 1, 2j), (2i + 1, 2j + 1)
	   *
	   * The higher level tile set should represent a 2x increase in resolution.
	   *
	   * Although not currently supported, this class is intended to extend to
	   * 3D grids of tiles as well where 1 tile is covered by a 2x2x2 grid of
	   * tiles at the next level.  The tiles are assumed to be rectangular,
	   * identically sized, and aligned with x/y axis of the underlying
	   * coordinate system.  The local coordinate system is in pixels relative
	   * to the current zoom level and changes when the zoom level crosses an
	   * integer threshold.
	   *
	   * The constructor takes a number of optional parameters that customize
	   * the display of the tiles.  The default values of these options are
	   * stored as the `defaults` attribution on the constructor.  Supporting
	   * alternate tiling protocols often only requires adjusting these
	   * defaults.
	   *
	   * @class geo.tileLayer
	   * @extends geo.featureLayer
	   * @param {object?} options
	   * @param {number} [options.minLevel=0]    The minimum zoom level available
	   * @param {number} [options.maxLevel=18]   The maximum zoom level available
	   * @param {number} [options.tileOverlap=0]
	   *    Number of pixels of overlap between tiles
	   * @param {number} [options.tileWidth=256]
	   *    The tile width as displayed without overlap
	   * @param {number} [options.tileHeight=256]
	   *    The tile height as displayed without overlap
	   * @param {function} [options.tilesAtZoom=null]
	   *    A function that is given a zoom level and returns {x: (num), y: (num)}
	   *    with the number of tiles at that zoom level.
	   * @param {number} [options.cacheSize=400] The maximum number of tiles to
	   *    cache.  The default is 200 if keepLower is false.
	   * @param {bool}   [options.keepLower=true]
	   *    Keep lower zoom level tiles when showing high zoom level tiles.  This
	   *    uses more memory but results in smoother transitions.
	   * @param {bool}   [options.wrapX=true]    Wrap in the x-direction
	   * @param {bool}   [options.wrapY=false]   Wrap in the y-direction
	   * @param {function|string} [options.url=null]
	   *   A function taking the current tile indices and returning a URL or jquery
	   *   ajax config to be passed to the {geo.tile} constructor.
	   *   Example:
	   *     (x, y, z, subdomains) => "http://example.com/z/y/x.png"
	   *   If this is a string, a template url with {x}, {y}, {z}, and {s} as
	   *   template variables.  {s} picks one of the subdomains parameter.
	   * @param {string|list} [options.subdomain="abc"]  Subdomains to use in
	   *   template url strings.  If a string, this is converted to a list before
	   *   being passed to a url function.
	   * @param {string} [options.baseUrl=null]  If defined, use the old-style base
	   *   url instead of the options.url parameter.  This is functionally the same
	   *   as using a url of baseUrl/{z}/{x}/{y}.(options.imageFormat || png).  If
	   *   the specified string does not end in a slash, one is added.
	   * @param {string} [options.imageFormat='png']
	   *   This is only used if a baseUrl is specified, in which case it determines
	   *   the image name extension used in the url.
	   * @param {number} [options.animationDuration=0]
	   *   The number of milliseconds for the tile loading animation to occur.  **This
	   *   option is currently buggy because old tiles will purge before the animation
	   *   is complete.**
	   * @param {string} [options.attribution]
	   *   An attribution to display with the layer (accepts HTML)
	   * @param {function} [options.tileRounding=Math.round]
	   *   This function determines which tiles will be loaded when the map is at
	   *   a non-integer zoom.  For example, `Math.floor`, will use tile level 2
	   *   when the map is at zoom 2.9.
	   * @param {function} [options.tileOffset]
	   *   This function takes a zoom level argument and returns, in units of
	   *   pixels, the coordinates of the point (0, 0) at the given zoom level
	   *   relative to the bottom left corner of the domain.
	   * @param {function} [options.tileMaxBounds=null]
	   *   This function takes a zoom level argument and returns, in units of
	   *   pixels, the top, left, right, and bottom maximum value for which tiles
	   *   should be drawn at the given zoom level relative to the bottom left
	   *   corner of the domain.  This can be used to crop tiles at the edges of
	   *   tile layer.  Note that if tiles wrap, only complete tiles in the
	   *   wrapping direction(s) are supported, and this max bounds will probably
	   *   not behave properly.
	   * @param {bool}   [options.topDown=false]  True if the gcs is top-down,
	   *   false if bottom-up (the ingcs does not matter, only the gcs coordinate
	   *   system).  When false, this inverts the gcs y-coordinate when calculating
	   *   local coordinates.
	   * @returns {geo.tileLayer}
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var tileLayer = function (options) {

	    var $ = __webpack_require__(1);
	    var geo_event = __webpack_require__(5);
	    var transform = __webpack_require__(6);
	    var tileCache = __webpack_require__(229);
	    var fetchQueue = __webpack_require__(218);
	    var adjustLayerForRenderer = __webpack_require__(76).adjustLayerForRenderer;
	    var Tile = __webpack_require__(223);

	    if (!(this instanceof tileLayer)) {
	      return new tileLayer(options);
	    }
	    featureLayer.call(this, options);

	    options = $.extend(true, {}, this.constructor.defaults, options || {});
	    if (!options.cacheSize) {
	      // this size should be sufficient for a 4k display
	      options.cacheSize = options.keepLower ? 600 : 200;
	    }
	    if ($.type(options.subdomains) === 'string') {
	      options.subdomains = options.subdomains.split('');
	    }
	    /* We used to call the url option baseUrl.  If a baseUrl is specified, use
	     * it instead of url, interpretting it as before. */
	    if (options.baseUrl) {
	      var url = options.baseUrl;
	      if (url && url.charAt(url.length - 1) !== '/') {
	        url += '/';
	      }
	      options.url = url + '{z}/{x}/{y}.' + (options.imageFormat || 'png');
	    }
	    /* Save the original url so that we can return it if asked */
	    options.originalUrl = options.url;
	    if ($.type(options.url) === 'string') {
	      options.url = m_tileUrlFromTemplate(options.url);
	    }

	    var s_init = this._init,
	        s_exit = this._exit,
	        m_lastTileSet = [],
	        m_maxBounds = [],
	        m_exited;

	    // copy the options into a private variable
	    this._options = $.extend(true, {}, options);

	    // set the layer attribution text
	    this.attribution(options.attribution);

	    // initialize the object that keeps track of actively drawn tiles
	    this._activeTiles = {};

	    // initialize the object that stores active tile regions in a
	    // tree-like structure providing quick queries to determine
	    // if tiles are completely obscured or not.
	    this._tileTree = {};

	    // initialize the in memory tile cache
	    this._cache = tileCache({size: options.cacheSize});

	    // initialize the tile fetch queue
	    this._queue = fetchQueue({
	      // this should probably be 6 * subdomains.length if subdomains are used
	      size: 6,
	      // if track is the same as the cache size, then neither processing time
	      // nor memory will be wasted.  Larger values will use more memory,
	      // smaller values will do needless computations.
	      track: options.cacheSize,
	      needed: function (tile) {
	        return tile === this.cache.get(tile.toString(), true);
	      }.bind(this)
	    });

	    var m_tileOffsetValues = {};

	    /**
	     * Readonly accessor to the options object
	     */
	    Object.defineProperty(this, 'options', {get: function () {
	      return $.extend({}, this._options);
	    }});

	    /**
	     * Readonly accessor to the tile cache object.
	     */
	    Object.defineProperty(this, 'cache', {get: function () {
	      return this._cache;
	    }});

	    /**
	     * Readonly accessor to the active tile mapping.  This is an object containing
	     * all currently drawn tiles (hash(tile) => tile).
	     */
	    Object.defineProperty(this, 'activeTiles', {get: function () {
	      return $.extend({}, this._activeTiles); // copy on output
	    }});

	    /**
	     * The number of tiles at the given zoom level
	     * The default implementation just returns `Math.pow(2, z)`.
	     * @param {number} level A zoom level
	     * @returns {{x: nx, y: ny}} The number of tiles in each axis
	     */
	    this.tilesAtZoom = function (level) {
	      if (this._options.tilesAtZoom) {
	        return this._options.tilesAtZoom.call(this, level);
	      }
	      var s = Math.pow(2, level);
	      return {x: s, y: s};
	    };

	    /**
	     * The maximum tile bounds at the given zoom level, or null if no special
	     * tile bounds.
	     *
	     * @param {number} level A zoom level
	     * @returns {object} {x: width, y: height} The maximum tile bounds in
	     *      pixels for the specified level, or null if none specified.
	     */
	    this.tilesMaxBounds = function (level) {
	      if (this._options.tilesMaxBounds) {
	        return this._options.tilesMaxBounds.call(this, level);
	      }
	      return null;
	    };

	    /**
	     * Get the crop values for a tile based on the tilesMaxBounds function.
	     * Returns undefined if the tile should not be cropped.
	     *
	     * @param {object} tile: the tile to compute crop values for.
	     * @returns {object} either undefined or an object with x and y values
	     *      which is the size in pixels for the tile.
	     */
	    this.tileCropFromBounds = function (tile) {
	      if (!this._options.tilesMaxBounds) {
	        return;
	      }
	      var level = tile.index.level,
	          bounds = this._tileBounds(tile);
	      if (m_maxBounds[level] === undefined) {
	        m_maxBounds[level] = this.tilesMaxBounds(level) || null;
	      }
	      if (m_maxBounds[level] && (bounds.right > m_maxBounds[level].x ||
	          bounds.bottom > m_maxBounds[level].y)) {
	        return {
	          x: Math.max(0, Math.min(m_maxBounds[level].x, bounds.right) - bounds.left),
	          y: Math.max(0, Math.min(m_maxBounds[level].y, bounds.bottom) - bounds.top)
	        };
	      }
	    };

	    /**
	     * Returns true if the given tile index is valid:
	     *   * min level <= level <= max level
	     *   * 0 <= x <= 2^level - 1
	     *   * 0 <= y <= 2^level - 1
	     * @param {object} index The tile index
	     * @param {number} index.x
	     * @param {number} index.y
	     * @param {number} index.level
	     * @returns {geo.tile}
	     */
	    this.isValid = function (index) {
	      if (!(this._options.minLevel <= index.level &&
	           index.level <= this._options.maxLevel)) {
	        return false;
	      }
	      if (!(this._options.wrapX ||
	            0 <= index.x &&
	            index.x <= this.tilesAtZoom(index.level).x - 1)) {
	        return false;
	      }
	      if (!(this._options.wrapY ||
	            0 <= index.y &&
	            index.y <= this.tilesAtZoom(index.level).y - 1)) {
	        return false;
	      }
	      return true;
	    };

	    /**
	     * Returns the current origin tile and offset at the given zoom level.
	     * This is intended to be cached in the future to optimize coordinate
	     * transformations.
	     * @protected
	     * @param {number} level The target zoom level
	     * @returns {object} {index: {x, y}, offset: {x, y}}
	     */
	    this._origin = function (level) {
	      var origin = this.toLevel(this.toLocal(this.map().origin()), level),
	          o = this._options,
	          index, offset;

	      // get the tile index
	      index = {
	        x: Math.floor(origin.x / o.tileWidth),
	        y: Math.floor(origin.y / o.tileHeight)
	      };

	      // get the offset inside the tile (in pixels)
	      // This computation should contain the only numerically unstable
	      // subtraction in this class.  All other methods will assume
	      // coordinates are given relative to the map origin.
	      offset = {
	        x: origin.x - o.tileWidth * index.x,
	        y: origin.y - o.tileHeight * index.y
	      };
	      return {index: index, offset: offset};
	    };

	    /**
	     * Returns a tile's bounds in its level coordinates.
	     * @param {geo.tile} tile
	     * @returns {object} bounds
	     */
	    this._tileBounds = function (tile) {
	      var origin = this._origin(tile.index.level);
	      return tile.bounds(origin.index, origin.offset);
	    };

	    /**
	     * Returns the tile indices at the given point.
	     * @param {object} point The coordinates in pixels relative to the map origin.
	     * @param {number} point.x
	     * @param {number} point.y
	     * @param {number} level The target zoom level
	     * @returns {object} The tile indices
	     */
	    this.tileAtPoint = function (point, level) {
	      var o = this._origin(level);
	      var map = this.map();
	      point = this.displayToLevel(map.gcsToDisplay(point, null), level);
	      if (isNaN(point.x)) { point.x = 0; }
	      if (isNaN(point.y)) { point.y = 0; }
	      var to = this._tileOffset(level);
	      if (to) {
	        point.x += to.x;
	        point.y += to.y;
	      }
	      var tile = {
	        x: Math.floor(
	          o.index.x + (o.offset.x + point.x) / this._options.tileWidth
	        ),
	        y: Math.floor(
	          o.index.y + (o.offset.y + point.y) / this._options.tileHeight
	        )
	      };
	      return tile;
	    };

	    /**
	     * Returns a tile's bounds in a gcs.
	     * @param {object|tile} either a tile or an object with {x, y, level}
	     *                      specifying a tile.
	     * @param {string|geo.transform} [gcs] undefined to use the interface gcs,
	     *    null to use the map gcs, or any other transform.
	     * @returns {object} The tile bounds in the specified gcs.
	     */
	    this.gcsTileBounds = function (indexOrTile, gcs) {
	      var tile = (indexOrTile.index ? indexOrTile : Tile({
	        index: indexOrTile,
	        size: {x: this._options.tileWidth, y: this._options.tileHeight},
	        url: ''
	      }));
	      var to = this._tileOffset(tile.index.level),
	          bounds = tile.bounds({x: 0, y: 0}, to),
	          map = this.map(),
	          unit = map.unitsPerPixel(tile.index.level);
	      var coord = [{
	        x: bounds.left * unit, y: this._topDown() * bounds.top * unit
	      }, {
	        x: bounds.right * unit, y: this._topDown() * bounds.bottom * unit
	      }];
	      gcs = (gcs === null ? map.gcs() : (
	          gcs === undefined ? map.ingcs() : gcs));
	      if (gcs !== map.gcs()) {
	        coord = transform.transformCoordinates(map.gcs(), gcs, coord);
	      }
	      return {
	        left: coord[0].x,
	        top: coord[0].y,
	        right: coord[1].x,
	        bottom: coord[1].y
	      };
	    };

	    /**
	     * Returns an instantiated tile object with the given indices.  This
	     * method always returns a new tile object.  Use `_getTileCached`
	     * to use the caching layer.
	     * @param {object} index The tile index
	     * @param {number} index.x
	     * @param {number} index.y
	     * @param {number} index.level
	     * @param {object} source The tile index used for constructing the url
	     * @param {number} source.x
	     * @param {number} source.y
	     * @param {number} source.level
	     * @returns {geo.tile}
	     */
	    this._getTile = function (index, source) {
	      var urlParams = source || index;
	      return Tile({
	        index: index,
	        size: {x: this._options.tileWidth, y: this._options.tileHeight},
	        queue: this._queue,
	        url: this._options.url(urlParams.x, urlParams.y, urlParams.level || 0,
	                               this._options.subdomains)
	      });
	    };

	    /**
	     * Returns an instantiated tile object with the given indices.  This
	     * method is similar to `_getTile`, but checks the cache before
	     * generating a new tile.
	     * @param {object} index The tile index
	     * @param {number} index.x
	     * @param {number} index.y
	     * @param {number} index.level
	     * @param {object} source The tile index used for constructing the url
	     * @param {number} source.x
	     * @param {number} source.y
	     * @param {number} source.level
	     * @param {boolean} delayPurge If true, don't purge tiles from the cache
	     * @returns {geo.tile}
	     */
	    this._getTileCached = function (index, source, delayPurge) {
	      var tile = this.cache.get(this._tileHash(index));
	      if (tile === null) {
	        tile = this._getTile(index, source);
	        this.cache.add(tile, this.remove.bind(this), delayPurge);
	      }
	      return tile;
	    };

	    /**
	     * Returns a string representation of the tile at the given index.
	     * This method is used as a hashing function for the caching layer.
	     *
	     * Note: This method _must_ return the same string as:
	     *
	     *   tile({index: index}).toString();
	     *
	     * @param {object} index The tile index
	     * @param {number} index.x
	     * @param {number} index.y
	     * @param {number} index.level
	     * @returns {string}
	     */
	    this._tileHash = function (index) {
	      return [index.level || 0, index.y, index.x].join('_');
	    };

	    /**
	     * Returns the optimal starting and ending tile indices
	     * (inclusive) necessary to fill the given viewport.
	     * @param {number} level The zoom level
	     * @param {object} bounds The map bounds in world coordinates
	     */
	    this._getTileRange = function (level, bounds) {
	      var corners = [
	        this.tileAtPoint({x: bounds.left, y: bounds.top}, level),
	        this.tileAtPoint({x: bounds.right, y: bounds.top}, level),
	        this.tileAtPoint({x: bounds.left, y: bounds.bottom}, level),
	        this.tileAtPoint({x: bounds.right, y: bounds.bottom}, level)
	      ];
	      return {
	        start: {
	          x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
	          y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
	        },
	        end: {
	          x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
	          y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
	        }
	      };
	    };

	    /**
	     * Returns a list of tiles necessary to fill the screen at the given
	     * zoom level, center point, and viewport size.  The list is optionally
	     * ordered by loading priority (center tiles first).
	     *
	     * @protected
	     * @param {number} maxLevel The zoom level
	     * @param {object} bounds The map bounds
	     * @param {boolean} sorted Return a sorted list
	     * @param {boolean} onlyIfChanged If the set of tiles have not changed
	     *     (even if their desired order has), return undefined instead of an
	     *     array of tiles.
	     * @returns {geo.tile[]} An array of tile objects
	     */
	    this._getTiles = function (maxLevel, bounds, sorted, onlyIfChanged) {
	      var i, j, tiles = [], index, nTilesLevel,
	          start, end, indexRange, source, center, changed = false, old, level,
	          minLevel = (this._options.keepLower ? this._options.minLevel :
	                      maxLevel);
	      if (maxLevel < minLevel) {
	        maxLevel = minLevel;
	      }

	      /* Generate a list of the tiles that we want to create.  This is done
	       * before sorting, because we want to actually generate the tiles in
	       * the sort order. */
	      for (level = minLevel; level <= maxLevel; level += 1) {
	        // get the tile range to fetch
	        indexRange = this._getTileRange(level, bounds);
	        start = indexRange.start;
	        end = indexRange.end;
	        // total number of tiles existing at this level
	        nTilesLevel = this.tilesAtZoom(level);

	        if (!this._options.wrapX) {
	          start.x = Math.min(Math.max(start.x, 0), nTilesLevel.x - 1);
	          end.x = Math.min(Math.max(end.x, 0), nTilesLevel.x - 1);
	          if (level === minLevel && this._options.keepLower) {
	            start.x = 0;
	            end.x = nTilesLevel.x - 1;
	          }
	        }
	        if (!this._options.wrapY) {
	          start.y = Math.min(Math.max(start.y, 0), nTilesLevel.y - 1);
	          end.y = Math.min(Math.max(end.y, 0), nTilesLevel.y - 1);
	          if (level === minLevel && this._options.keepLower) {
	            start.y = 0;
	            end.y = nTilesLevel.y - 1;
	          }
	        }
	        /* If we are reprojecting tiles, we need a check to not use all levels
	         * if the number of tiles is excessive. */
	        if (this._options.gcs && this._options.gcs !== this.map().gcs() &&
	            level !== minLevel &&
	            (end.x + 1 - start.x) * (end.y + 1 - start.y) >
	            (this.map().size().width * this.map().size().height /
	            this._options.tileWidth / this._options.tileHeight) * 16) {
	          break;
	        }

	        // loop over the tile range
	        for (i = start.x; i <= end.x; i += 1) {
	          for (j = start.y; j <= end.y; j += 1) {
	            index = {level: level, x: i, y: j};
	            source = {level: level, x: i, y: j};
	            if (this._options.wrapX) {
	              source.x = modulo(source.x, nTilesLevel.x);
	            }
	            if (this._options.wrapY) {
	              source.y = modulo(source.y, nTilesLevel.y);
	            }
	            if (this.isValid(source)) {
	              if (onlyIfChanged && tiles.length < m_lastTileSet.length) {
	                old = m_lastTileSet[tiles.length];
	                changed = changed || (index.level !== old.level ||
	                    index.x !== old.x || index.y !== old.y);
	              }
	              tiles.push({index: index, source: source});
	            }
	          }
	        }
	      }

	      if (onlyIfChanged) {
	        if (!changed && tiles.length === m_lastTileSet.length) {
	          return;
	        }
	        m_lastTileSet.splice(0, m_lastTileSet.length);
	        $.each(tiles, function (idx, tile) {
	          m_lastTileSet.push(tile.index);
	        });
	      }

	      if (sorted) {
	        center = {
	          x: (start.x + end.x) / 2,
	          y: (start.y + end.y) / 2,
	          level: maxLevel,
	          bottomLevel: maxLevel
	        };
	        var numTiles = Math.max(end.x - start.x, end.y - start.y) + 1;
	        for (; numTiles >= 1; numTiles /= 2) {
	          center.bottomLevel -= 1;
	        }
	        tiles.sort(this._loadMetric(center));
	        /* If we are using a fetch queue, start a new batch */
	        if (this._queue) {
	          this._queue.batch(true);
	        }
	      }
	      if (this.cache.size < tiles.length) {
	        console.log('Increasing cache size to ' + tiles.length);
	        this.cache.size = tiles.length;
	      }
	      /* Actually get the tiles. */
	      for (i = 0; i < tiles.length; i += 1) {
	        tiles[i] = this._getTileCached(tiles[i].index, tiles[i].source, true);
	      }
	      this.cache.purge(this.remove.bind(this));
	      return tiles;
	    };

	    /**
	     * Prefetches tiles up to a given zoom level around a given bounding box.
	     *
	     * @param {number} level The zoom level
	     * @param {object} bounds The map bounds
	     * @returns {$.Deferred} resolves when all of the tiles are fetched
	     */
	    this.prefetch = function (level, bounds) {
	      var tiles;
	      tiles = this._getTiles(level, bounds, true);
	      return $.when.apply($,
	        tiles.map(function (tile) {
	          return tile.fetch();
	        })
	      );
	    };

	    /**
	     * This method returns a metric that determines tile loading order.  The
	     * default implementation prioritizes tiles that are closer to the center,
	     * or at a lower zoom level.
	     * @protected
	     * @param {index1} center   The center tile
	     * @param {number} center.x
	     * @param {number} center.y
	     * @returns {function} A function accepted by Array.prototype.sort
	     */
	    this._loadMetric = function (center) {
	      return function (a, b) {
	        var a0, b0, dx, dy, cx, cy, scale;

	        a = a.index || a;
	        b = b.index || b;
	        // shortcut if zoom level differs
	        if (a.level !== b.level) {
	          if (center.bottomLevel && ((a.level >= center.bottomLevel) !==
	                                     (b.level >= center.bottomLevel))) {
	            return a.level >= center.bottomLevel ? -1 : 1;
	          }
	          return a.level - b.level;
	        }

	        /* compute the center coordinates relative to a.level.  Since we really
	         * care about the center of the tiles, use an offset */
	        scale = Math.pow(2, a.level - center.level);
	        cx = (center.x + 0.5) * scale - 0.5;
	        cy = (center.y + 0.5) * scale - 0.5;

	        // calculate distances to the center squared
	        dx = a.x - cx;
	        dy = a.y - cy;
	        a0 = dx * dx + dy * dy;

	        dx = b.x - cx;
	        dy = b.y - cy;
	        b0 = dx * dx + dy * dy;

	        // return negative if a < b, or positive if a > b
	        return a0 - b0;
	      };
	    };

	    /**
	     * Convert a coordinate from pixel coordinates at the given zoom
	     * level to world coordinates.
	     * @param {object} coord
	     * @param {number} coord.x The offset in pixels (level 0) from the left edge
	     * @param {number} coord.y The offset in pixels (level 0) from the bottom edge
	     * @param {number} level   The zoom level of the source coordinates
	     */
	    this.fromLevel = function (coord, level) {
	      var s = Math.pow(2, -level);
	      return {
	        x: coord.x * s,
	        y: coord.y * s
	      };
	    };

	    /**
	     * Convert a coordinate from layer coordinates to pixel coordinates at the
	     * given zoom level.
	     * @param {object} coord
	     * @param {number} coord.x The offset in pixels (level 0) from the left edge
	     * @param {number} coord.y The offset in pixels (level 0) from the bottom edge
	     * @param {number} level   The zoom level of the new coordinates
	     */
	    this.toLevel = function (coord, level) {
	      var s = Math.pow(2, level);
	      return {
	        x: coord.x * s,
	        y: coord.y * s
	      };
	    };

	    /**
	     * Draw the given tile on the active canvas.
	     * @param {geo.tile} tile The tile to draw
	     */
	    this.drawTile = function (tile) {
	      var hash = tile.toString();

	      if (this._activeTiles.hasOwnProperty(hash)) {
	        // the tile is already drawn, move it to the top
	        this._moveToTop(tile);
	      } else {
	        // pass to the rendering implementation
	        this._drawTile(tile);
	      }

	      // add the tile to the active cache
	      this._activeTiles[hash] = tile;
	    };

	    /**
	     * Render the tile on the canvas.  This implementation draws the tiles directly
	     * on the DOM using <img> tags.  Derived classes should override this method
	     * to draw the tile on a renderer specific context.
	     * @protected
	     * @param {geo.tile} tile The tile to draw
	     */
	    this._drawTile = function (tile) {
	      // Make sure this method is not called when there is
	      // a renderer attached.
	      //
	      if (this.renderer() !== null) {
	        throw new Error('This draw method is not valid on renderer managed layers.');
	      }

	      // get the layer node
	      var level = tile.index.level,
	          div = $(this._getSubLayer(level)),
	          bounds = this._tileBounds(tile),
	          duration = this._options.animationDuration,
	          container = $('<div class="geo-tile-container"/>').attr(
	            'tile-reference', tile.toString()),
	          crop;

	      // apply a transform to place the image correctly
	      container.append(tile.image);
	      container.css({
	        position: 'absolute',
	        left: (bounds.left - parseInt(div.attr('offsetx') || 0, 10)) + 'px',
	        top: (bounds.top - parseInt(div.attr('offsety') || 0, 10)) + 'px'
	      });

	      crop = this.tileCropFromBounds(tile);
	      if (crop) {
	        container.css({
	          width: crop.x + 'px',
	          height: crop.y + 'px',
	          overflow: 'hidden'
	        });
	      }

	      // apply fade in animation
	      if (duration > 0) {
	        tile.fadeIn(duration);
	      }

	      // append the image element
	      div.append(container);

	      // add an error handler
	      tile.catch(function () {
	        // May want to do something special here later
	        console.warn('Could not load tile at ' + tile.toString());
	        this._remove(tile);
	      }.bind(this));
	    };

	    /**
	     * Remove the given tile from the canvas and the active cache.
	     * @param {geo.tile|string} tile The tile (or hash) to remove
	     * @returns {geo.tile} the tile removed from the active layer
	     */
	    this.remove = function (tile) {
	      var hash = tile.toString();
	      var value = this._activeTiles[hash];

	      if (value instanceof Tile) {
	        this._remove(value);
	      }

	      delete this._activeTiles[hash];
	      return value;
	    };

	    /**
	     * Remove the given tile from the canvas.  This implementation just
	     * finds and removes the <img> element created for the tile.
	     * @param {geo.tile|string} tile The tile object to remove
	     */
	    this._remove = function (tile) {
	      if (tile.image) {
	        if (tile.image.parentElement) {
	          $(tile.image.parentElement).remove();
	        } else {
	          /* This shouldn't happen, but sometimes does.  Originally it happened
	           * when a tile was removed from the cache before it was finished
	           * being used; there is still some much rarer condition that can
	           * cause it.  Log that it happened until we can figure out how to fix
	           * the issue. */
	          console.log('No parent element to remove ' + tile.toString(), tile);
	        }
	        $(tile.image).remove();
	      }
	    };

	    /**
	     * Move the given tile to the top on the canvas.
	     * @param {geo.tile} tile The tile object to move
	     */
	    this._moveToTop = function (tile) {
	      $.noop(tile);
	    };

	    /**
	     * Query the attached map for the current bounds and return them
	     * as pixels at the current zoom level.
	     * @returns {object}
	     *  Bounds object with left, right, top, bottom keys
	     * @protected
	     */
	    this._getViewBounds = function () {
	      var map = this.map(),
	          mapZoom = map.zoom(),
	          zoom = this._options.tileRounding(mapZoom),
	          scale = Math.pow(2, mapZoom - zoom),
	          size = map.size();
	      var ul = this.displayToLevel({x: 0, y: 0}),
	          ur = this.displayToLevel({x: size.width, y: 0}),
	          ll = this.displayToLevel({x: 0, y: size.height}),
	          lr = this.displayToLevel({x: size.width, y: size.height});
	      return {
	        level: zoom,
	        scale: scale,
	        left: Math.min(ul.x, ur.x, ll.x, lr.x),
	        right: Math.max(ul.x, ur.x, ll.x, lr.x),
	        top: Math.min(ul.y, ur.y, ll.y, lr.y),
	        bottom: Math.max(ul.y, ur.y, ll.y, lr.y)
	      };
	    };

	    /**
	     * Remove all inactive tiles from the display.  An inactive tile
	     * is one that is no longer visible either because it was panned
	     * out of the active view or the zoom has changed.
	     * @protected
	     * @param {number} zoom Tiles (in bounds) at this zoom level will be kept
	     * @param {boolean} doneLoading If true, allow purging additional tiles.
	     * @param {object} bounds view bounds.  If not specified, this is
	     *   obtained from _getViewBounds().
	     */
	    this._purge = function (zoom, doneLoading, bounds) {
	      var tile, hash;

	      // Don't purge tiles in an active update
	      if (this._updating) {
	        return;
	      }

	      // get the view bounds
	      if (!bounds) {
	        bounds = this._getViewBounds();
	      }

	      for (hash in this._activeTiles) {

	        tile = this._activeTiles[hash];
	        if (this._canPurge(tile, bounds, zoom, doneLoading)) {
	          this.remove(tile);
	        }
	      }
	      return this;
	    };

	    /**
	     * Remove all active tiles from the canvas.
	     * @returns {geo.tile[]} The array of tiles removed
	     */
	    this.clear = function () {
	      var tiles = [], tile;

	      // ignoring the warning here because this is a privately
	      // controlled object with simple keys
	      for (tile in this._activeTiles) {
	        tiles.push(this.remove(tile));
	      }

	      // clear out the tile coverage tree
	      this._tileTree = {};

	      m_lastTileSet = [];

	      return tiles;
	    };

	    /**
	     * Reset the layer to the initial state, clearing the canvas
	     * and resetting the tile cache.
	     * @returns {this} Chainable
	     */
	    this.reset = function () {
	      this.clear();
	      this._cache.clear();
	    };

	    /**
	     * Compute local coordinates from the given world coordinates.  The
	     * tile layer uses units of pixels relative to the world space
	     * coordinate origin.
	     * @param {object} pt A point in world space coordinates
	     * @param {number|undefined} zoom If unspecified, use the map zoom.
	     * @returns {object} Local coordinates
	     */
	    this.toLocal = function (pt, zoom) {
	      var map = this.map(),
	          unit = map.unitsPerPixel(zoom === undefined ? map.zoom() : zoom);
	      return {
	        x: pt.x / unit,
	        y: this._topDown() * pt.y / unit
	      };
	    };

	    /**
	     * Compute world coordinates from the given local coordinates.  The
	     * tile layer uses units of pixels relative to the world space
	     * coordinate origin.
	     * @param {object} pt A point in world space coordinates
	     * @param {number|undefined} zoom If unspecified, use the map zoom.
	     * @returns {object} Local coordinates
	     */
	    this.fromLocal = function (pt, zoom) {
	      // these need to always use the *layer* unitsPerPixel, or possibly
	      // convert tile space using a transform
	      var map = this.map(),
	          unit = map.unitsPerPixel(zoom === undefined ? map.zoom() : zoom);
	      return {
	        x: pt.x * unit,
	        y: this._topDown() * pt.y * unit
	      };
	    };

	    /**
	     * Return a factor for invertin the y units as appropriate.
	     * @return {number}
	     */
	    this._topDown = function () {
	      return this._options.topDown ? 1 : -1;
	    };

	    /**
	     * Return the DOM element containing a level specific layer.  This will
	     * create the element if it doesn't already exist.
	     * @param {number} level The zoom level of the layer to fetch
	     * @return {DOM}
	     */
	    this._getSubLayer = function (level) {
	      if (!this.canvas()) {
	        return;
	      }
	      var node = this.canvas()
	        .find('div[data-tile-layer=' + level.toFixed() + ']').get(0);
	      if (!node) {
	        node = $(
	          '<div class=geo-tile-layer data-tile-layer="' + level.toFixed() + '"/>'
	        ).css({
	          'transform-origin': '0px 0px',
	          'line-height': 0,
	          'font-size': 0
	        }).get(0);
	        this.canvas().append(node);
	      }
	      return node;
	    };

	    /**
	     * Set sublayer transforms to align them with the given zoom level.
	     * @param {number} level The target zoom level
	     * @param {object} view The view bounds.  The top and left are used to
	     *                      adjust the offset of tile layers.
	     * @return {object} the x and y offsets for the current level.
	     */
	    this._updateSubLayers = function (level, view) {
	      var canvas = this.canvas(),
	          lastlevel = parseInt(canvas.attr('lastlevel'), 10),
	          lastx = parseInt(canvas.attr('lastoffsetx') || 0, 10),
	          lasty = parseInt(canvas.attr('lastoffsety') || 0, 10);
	      if (lastlevel === level && Math.abs(lastx - view.left) < 65536 &&
	          Math.abs(lasty - view.top) < 65536) {
	        return {x: lastx, y: lasty};
	      }
	      var map = this.map(),
	          to = this._tileOffset(level),
	          x = parseInt((view.left + view.right - map.size().width) / 2 + to.x, 10),
	          y = parseInt((view.top + view.bottom - map.size().height) / 2 + to.y, 10);
	      canvas.find('.geo-tile-layer').each(function (idx, el) {
	        var $el = $(el),
	            layer = parseInt($el.data('tileLayer'), 10);
	        $el.css(
	          'transform',
	          'scale(' + Math.pow(2, level - layer) + ')'
	        );
	        var layerx = parseInt(x / Math.pow(2, level - layer), 10),
	            layery = parseInt(y / Math.pow(2, level - layer), 10),
	            dx = layerx - parseInt($el.attr('offsetx') || 0, 10),
	            dy = layery - parseInt($el.attr('offsety') || 0, 10);
	        $el.attr({offsetx: layerx, offsety: layery});
	        $el.find('.geo-tile-container').each(function (tileidx, tileel) {
	          $(tileel).css({
	            left: (parseInt($(tileel).css('left'), 10) - dx) + 'px',
	            top: (parseInt($(tileel).css('top'), 10) - dy) + 'px'
	          });
	        });
	      });
	      canvas.attr({lastoffsetx: x, lastoffsety: y, lastlevel: level});
	      return {x: x, y: y};
	    };

	    /**
	     * Update the view according to the map/camera.
	     * @returns {this} Chainable
	     */
	    this._update = function (evt) {
	      /* Ignore zoom and rotate events, as they are ALWAYS followed by a pan
	       * event */
	      if (evt && evt.event && (evt.event.event === geo_event.zoom ||
	          evt.event.event === geo_event.rotate)) {
	        return;
	      }
	      var map = this.map(),
	          bounds = map.bounds(undefined, null),
	          mapZoom = map.zoom(),
	          zoom = this._options.tileRounding(mapZoom),
	          tiles;
	      if (this._updateSubLayers) {
	        var view = this._getViewBounds();
	        // Update the transform for the local layer coordinates
	        var offset = this._updateSubLayers(zoom, view) || {x: 0, y: 0};

	        var to = this._tileOffset(zoom);
	        if (this.renderer() === null) {
	          var scale = Math.pow(2, mapZoom - zoom),
	              rotation = map.rotation(),
	              rx = -to.x + -(view.left + view.right) / 2 + offset.x,
	              ry = -to.y + -(view.bottom + view.top) / 2 + offset.y,
	              dx = (rx + map.size().width / 2),
	              dy = (ry + map.size().height / 2);

	          this.canvas().css({
	            'transform-origin': '' +
	                -rx + 'px ' +
	                -ry + 'px'
	          });
	          var transform = 'translate(' + dx + 'px' + ',' + dy + 'px' + ')' +
	              'scale(' + scale + ')';
	          if (rotation) {
	            transform += 'rotate(' + (rotation * 180 / Math.PI) + 'deg)';
	          }
	          this.canvas().css('transform', transform);
	        }
	        /* Set some attributes that can be used by non-css based viewers.  This
	         * doesn't include the map center, as that may need to be handled
	         * differently from the view center. */
	        this.canvas().attr({
	          scale: Math.pow(2, mapZoom - zoom),
	          dx: -to.x + -(view.left + view.right) / 2,
	          dy: -to.y + -(view.bottom + view.top) / 2,
	          offsetx: offset.x,
	          offsety: offset.y,
	          rotation: map.rotation()
	        });
	      }

	      tiles = this._getTiles(
	        zoom, bounds, true, true
	      );

	      if (tiles === undefined) {
	        return;
	      }

	      // reset the tile coverage tree
	      this._tileTree = {};

	      tiles.forEach(function (tile) {
	        if (tile.fetched()) {
	          /* if we have already fetched the tile, we know we can just draw it,
	           * as the bounds won't have changed since the call to _getTiles. */
	          this.drawTile(tile);

	          // mark the tile as covered
	          this._setTileTree(tile);
	        } else {
	          if (!tile._queued) {
	            tile.then(function () {
	              if (m_exited) {
	                /* If we have disconnected the renderer, do nothing.  This
	                 * happens when the layer is being deleted. */
	                return;
	              }
	              if (tile !== this.cache.get(tile.toString())) {
	                /* If the tile has fallen out of the cache, don't draw it -- it
	                 * is untracked.  This may be an indication that a larger cache
	                 * should have been used. */
	                return;
	              }
	              /* Check if a tile is still desired.  Don't draw it if it
	               * isn't. */
	              var mapZoom = map.zoom(),
	                  zoom = this._options.tileRounding(mapZoom),
	                  view = this._getViewBounds();
	              if (this._canPurge(tile, view, zoom)) {
	                this.remove(tile);
	                return;
	              }

	              this.drawTile(tile);

	              // mark the tile as covered
	              this._setTileTree(tile);
	            }.bind(this));

	            this.addPromise(tile);
	            tile._queued = true;
	          } else {
	            /* If we are using a fetch queue, tell the queue so this tile can
	             * be reprioritized. */
	            var pos = this._queue ? this._queue.get(tile) : -1;
	            if (pos >= 0) {
	              this._queue.add(tile);
	            }
	          }
	        }
	      }.bind(this));
	      // purge all old tiles when the new tiles are loaded (successfully or not)
	      $.when.apply($, tiles)
	        .done(// called on success and failure
	          function () {
	            var map = this.map(),
	                mapZoom = map.zoom(),
	                zoom = this._options.tileRounding(mapZoom);
	            this._purge(zoom, true);
	          }.bind(this)
	        );
	    };

	    /**
	     * Set a value in the tile tree object indicating that the given area of
	     * the canvas is covered by the tile.
	     * @protected
	     * @param {geo.tile} tile
	     */
	    this._setTileTree = function (tile) {
	      if (this._options.keepLower) {
	        return;
	      }
	      var index = tile.index;
	      this._tileTree[index.level] = this._tileTree[index.level] || {};
	      this._tileTree[index.level][index.x] = this._tileTree[index.level][index.x] || {};
	      this._tileTree[index.level][index.x][index.y] = tile;
	    };

	    /**
	     * Get a value in the tile tree object if it exists or return null.
	     * @protected
	     * @param {object} index A tile index object
	     * @param {object} index.level
	     * @param {object} index.x
	     * @param {object} index.y
	     * @returns {geo.tile|null}
	     */
	    this._getTileTree = function (index) {
	      return (
	          (
	            this._tileTree[index.level] || {}
	          )[index.x] || {}
	        )[index.y] || null;
	    };

	    /**
	     * Returns true if the tile is completely covered by other tiles on the canvas.
	     * Currently this method only checks layers +/- 1 away from `tile`.  If the
	     * zoom level is allowed to change by 2 or more in a single update step, this
	     * method will need to be refactored to make a more robust check.  Returns
	     * an array of tiles covering it or null if any part of the tile is exposed.
	     * @protected
	     * @param {geo.tile} tile
	     * @returns {geo.tile[]|null}
	     */
	    this._isCovered = function (tile) {
	      var level = tile.index.level,
	          x = tile.index.x,
	          y = tile.index.y,
	          tiles = [];

	      // Check one level up
	      tiles = this._getTileTree({
	        level: level - 1,
	        x: Math.floor(x / 2),
	        y: Math.floor(y / 2)
	      });
	      if (tiles) {
	        return [tiles];
	      }

	      // Check one level down
	      tiles = [
	        this._getTileTree({
	          level: level + 1,
	          x: 2 * x,
	          y: 2 * y
	        }),
	        this._getTileTree({
	          level: level + 1,
	          x: 2 * x + 1,
	          y: 2 * y
	        }),
	        this._getTileTree({
	          level: level + 1,
	          x: 2 * x,
	          y: 2 * y + 1
	        }),
	        this._getTileTree({
	          level: level + 1,
	          x: 2 * x + 1,
	          y: 2 * y + 1
	        })
	      ];
	      if (tiles.every(function (t) { return t !== null; })) {
	        return tiles;
	      }

	      return null;
	    };

	    /**
	     * Returns true if the provided tile is outside of the current view bounds
	     * and can be removed from the canvas.
	     * @protected
	     * @param {geo.tile} tile
	     * @param {object?} bounds The view bounds
	     * @param {object?} bounds.left
	     * @param {object?} bounds.right
	     * @param {object?} bounds.top
	     * @param {object?} bounds.bottom
	     * @returns {boolean}
	     */
	    this._outOfBounds = function (tile, bounds) {
	      /* We may want to add an (n) tile edge buffer so we appear more
	       * responsive */
	      var to = this._tileOffset(tile.index.level);
	      var scale = 1;
	      if (tile.index.level !== bounds.level) {
	        scale = Math.pow(2, (bounds.level || 0) - (tile.index.level || 0));
	      }
	      return (tile.bottom - to.y) * scale < bounds.top ||
	             (tile.left - to.x) * scale > bounds.right ||
	             (tile.top - to.y) * scale > bounds.bottom ||
	             (tile.right - to.x) * scale < bounds.left;
	    };

	    /**
	     * Returns true if the provided tile can be purged from the canvas.  This method
	     * will return `true` if the tile is completely covered by one or more other tiles
	     * or it is outside of the active view bounds.  This method returns the logical and
	     * of `_isCovered` and `_outOfBounds`.
	     * @protected
	     * @param {geo.tile} tile
	     * @param {object?} bounds The view bounds (if empty, assume global bounds)
	     * @param {number} bounds.left
	     * @param {number} bounds.right
	     * @param {number} bounds.top
	     * @param {number} bounds.bottom
	     * @param {number} bounds.level The zoom level the bounds are given as
	     * @param {number} zoom Keep in bound tile at this zoom level
	     * @param {boolean} doneLoading If true, allow purging additional tiles.
	     * @returns {boolean}
	     */
	    this._canPurge = function (tile, bounds, zoom, doneLoading) {
	      if (this._options.keepLower) {
	        zoom = zoom || 0;
	        if (zoom < tile.index.level &&
	            tile.index.level !== this._options.minLevel) {
	          return true;
	        }
	        if (tile.index.level === this._options.minLevel &&
	            !this._options.wrapX && !this._options.wrapY) {
	          return false;
	        }
	      } else {
	        /* For tile layers that should only keep one layer, if loading is
	         * finished, purge all but the current layer.  This is important for
	         * semi-transparanet layers. */
	        if ((doneLoading || this._isCovered(tile)) &&
	            zoom !== tile.index.level) {
	          return true;
	        }
	      }
	      if (bounds) {
	        return this._outOfBounds(tile, bounds);
	      }
	      return false;
	    };

	    /**
	     * Convert display pixel coordinates (where (0,0) is the upper left) to
	     * layer pixel coordinates (typically (0,0) is the center of the map and
	     * the upper-left has the most negative values).
	     * By default, this is done at the current base zoom level.
	     *
	     * @param pt: the point to convert.  If undefined, use the center of the
	     *            display.
	     * @param zoom: if specified, the zoom level to use.
	     * @returns: the point in level coordinates.
	     */
	    this.displayToLevel = function (pt, zoom) {
	      var map = this.map(),
	          mapzoom = map.zoom(),
	          roundzoom = this._options.tileRounding(mapzoom),
	          unit = map.unitsPerPixel(zoom === undefined ? roundzoom : zoom);
	      if (pt === undefined) {
	        var size = map.size();
	        pt = {x: size.width / 2, y: size.height / 2};
	      }
	      /* Reverse the y coordinate, since we expect the gcs coordinate system
	       * to be right-handed and the level coordinate system to be
	       * left-handed. */
	      var gcsPt = map.displayToGcs(pt, this._options.gcs || null),
	          lvlPt = {x: gcsPt.x / unit, y: this._topDown() * gcsPt.y / unit};
	      return lvlPt;
	    };

	    /**
	     * Get or set the tile url string or function.  If changed, load the new
	     * tiles.
	     *
	     * @param {string|function} [url] The new tile url.
	     * @returns {string|function|this}
	     */
	    this.url = function (url) {
	      if (url === undefined) {
	        return this._options.originalUrl;
	      }
	      if (url === this._options.originalUrl) {
	        return this;
	      }
	      this._options.originalUrl = url;
	      if ($.type(url) === 'string') {
	        url = m_tileUrlFromTemplate(url);
	      }
	      this._options.url = url;
	      this.reset();
	      this.map().draw();
	      return this;
	    };

	    /**
	     * Get or set the subdomains used for templating.
	     *
	     * @param {string|list} [subdomains] A comma-separated list, a string of
	     *      single character subdomains, or a list.
	     * @returns {string|list|this}
	     */
	    this.subdomains = function (subdomains) {
	      if (subdomains === undefined) {
	        return this._options.subdomains;
	      }
	      if (subdomains) {
	        if ($.type(subdomains) === 'string') {
	          if (subdomains.indexOf(',') >= 0) {
	            subdomains = subdomains.split(',');
	          } else {
	            subdomains = subdomains.split('');
	          }
	        }
	        this._options.subdomains = subdomains;
	        this.reset();
	        this.map().draw();
	      }
	      return this;
	    };

	    /**
	     * Return a value from the tileOffset function, caching it for different
	     * levels.
	     *
	     * @param {Number} level the level to pass to the tileOffset function.
	     * @returns {Object} a tile offset object with x and y properties.
	     */
	    this._tileOffset = function (level) {
	      if (m_tileOffsetValues[level] === undefined) {
	        m_tileOffsetValues[level] = this._options.tileOffset(level);
	      }
	      return m_tileOffsetValues[level];
	    };

	    /**
	     * Initialize after the layer is added to the map.
	     */
	    this._init = function () {
	      var sublayer;

	      // call super method
	      s_init.apply(this, arguments);

	      if (this.renderer() === null) {
	        // Initialize sublayers in the correct order
	        for (sublayer = 0; sublayer <= this._options.maxLevel; sublayer += 1) {
	          this._getSubLayer(sublayer);
	        }
	      }
	      return this;
	    };

	    /**
	     * Clean up the layer.
	     */
	    this._exit = function () {
	      this.reset();
	      // call super method
	      s_exit.apply(this, arguments);
	      m_exited = true;
	      return this;
	    };

	    adjustLayerForRenderer('tile', this);

	    return this;
	  };

	  /**
	   * This object contains the default options used to initialize the tileLayer.
	   */
	  tileLayer.defaults = {
	    minLevel: 0,
	    maxLevel: 18,
	    tileOverlap: 0,
	    tileWidth: 256,
	    tileHeight: 256,
	    wrapX: true,
	    wrapY: false,
	    url: null,
	    subdomains: 'abc',
	    tileOffset: function (level) {
	      void level;
	      return {x: 0, y: 0};
	    },
	    tilesMaxBounds: null,
	    topDown: false,
	    keepLower: true,
	    // cacheSize: 400,  // set depending on keepLower
	    tileRounding: Math.round,
	    attribution: '',
	    animationDuration: 0
	  };

	  inherit(tileLayer, featureLayer);
	  return tileLayer;
	})();


/***/ },
/* 229 */
/***/ function(module, exports) {

	module.exports = (function () {
	  'use strict';

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * This class implements a simple cache for tile objects.  Each tile is
	   * stored in cache object keyed by a configurable hashing function.  Another
	   * array keeps track of last access times for each tile to purge old tiles
	   * once the maximum cache size is reached.
	   *
	   * @class geo.tileCache
	   *
	   * @param {object?} [options] A configuratoin object for the cache
	   * @param {number} [options.size=64] The maximum number of tiles to store
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  var tileCache = function (options) {
	    if (!(this instanceof tileCache)) {
	      return new tileCache(options);
	    }
	    options = options || {};
	    this._size = options.size || 64;

	    /**
	     * Get/set the maximum cache size.
	     */
	    Object.defineProperty(this, 'size', {
	      get: function () { return this._size; },
	      set: function (n) {
	        while (this._atime.length > n) {
	          this.remove(this._atime[this._atime.length - 1]);
	        }
	        this._size = n;
	      }
	    });

	    /**
	     * Get the current cache size.
	     */
	    Object.defineProperty(this, 'length', {
	      get: function () { return this._atime.length; }
	    });

	    /**
	     * Get the position of the tile in the access queue.
	     * @param {string} hash The tile's hash value
	     * @returns {number} The position in the queue or -1
	     */
	    this._access = function (hash) {
	      return this._atime.indexOf(hash);
	    };

	    /**
	     * Remove a tile from the cache.
	     * @param {string|geo.tile} tile The tile or its hash
	     * @returns {bool} true if a tile was removed
	     */
	    this.remove = function (tile) {
	      var hash = typeof tile === 'string' ? tile : tile.toString();

	      // if the tile is not in the cache
	      if (!(hash in this._cache)) {
	        return false;
	      }

	      // Remove the tile from the access queue
	      this._atime.splice(this._access(hash), 1);

	      // Remove the tile from the cache
	      delete this._cache[hash];
	      return true;
	    };

	    /**
	     * Remove all tiles from the cache.
	     */
	    this.clear = function () {
	      this._cache = {};  // The hash -> tile mapping
	      this._atime = [];  // The access queue (the hashes are stored)
	      return this;
	    };

	    /**
	     * Get a tile from the cache if it exists, otherwise
	     * return null.  This method also moves the tile to the
	     * front of the access queue.
	     *
	     * @param {string|geo.tile} hash The tile or the tile hash value
	     * @param {boolean} noMove if true, don't move the tile to the front of the
	     *     access queue.
	     * @returns {geo.tile|null}
	     */
	    this.get = function (hash, noMove) {
	      hash = typeof hash === 'string' ? hash : hash.toString();
	      if (!(hash in this._cache)) {
	        return null;
	      }

	      if (!noMove) {
	        this._atime.splice(this._access(hash), 1);
	        this._atime.unshift(hash);
	      }
	      return this._cache[hash];
	    };

	    /**
	     * Add a tile to the cache.
	     * @param {geo.tile} tile
	     * @param {function} removeFunc if specified and tiles must be purged from
	     *      the cache, call this function on each tile before purging.
	     * @param {boolean} noPurge if true, don't purge tiles.
	     */
	    this.add = function (tile, removeFunc, noPurge) {
	      // remove any existing tiles with the same hash
	      this.remove(tile);
	      var hash = tile.toString();

	      // add the tile
	      this._cache[hash] = tile;
	      this._atime.unshift(hash);

	      if (!noPurge) {
	        this.purge(removeFunc);
	      }
	    };

	    /**
	     * Purge tiles from the cache if it is full.
	     * @param {function} removeFunc if specified and tiles must be purged from
	     *      the cache, call this function on each tile before purging.
	     */
	    this.purge = function (removeFunc) {
	      var hash;
	      while (this._atime.length > this.size) {
	        hash = this._atime.pop();
	        var tile = this._cache[hash];
	        if (removeFunc) {
	          removeFunc(tile);
	        }
	        delete this._cache[hash];
	      }
	    };

	    this.clear();
	    return this;
	  };
	  return tileCache;
	})();


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class pathFeature
	 *
	 * @class geo.pathFeature
	 * @extends geo.feature
	 * @returns {geo.pathFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var pathFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof pathFeature)) {
	    return new pathFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_position = arg.position === undefined ? [] : arg.position,
	      s_init = this._init;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set positions
	   *
	   * @returns {geo.pathFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_position;
	    }
	    // Copy incoming array of positions
	    m_position = val;
	    m_this.dataTime().modified();
	    m_this.modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(
	      {},
	      {
	        'strokeWidth': function () { return 1; },
	        'strokeColor': function () { return { r: 1.0, g: 1.0, b: 1.0 }; }
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    m_this.style(defaultStyle);

	    if (m_position) {
	      m_this.dataTime().modified();
	    }
	  };

	  this._init(arg);
	  return this;
	};

	inherit(pathFeature, feature);
	module.exports = pathFeature;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);
	var transform = __webpack_require__(6);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class heatmapFeature
	 *
	 * @class geo.heatmapFeature
	 * @param {Object} arg Options object
	 * @extends geo.feature
	 * @param {Object|Function} [position] Position of the data.  Default is
	 *   (data).
	 * @param {Object|Function} [intensity] Scalar value of each data point. Scalar
	 *   value must be a positive real number and will be used to compute
	 *   the weight for each data point.
	 * @param {number} [maxIntensity=null] Maximum intensity of the data. Maximum
	 *   intensity must be a positive real number and will be used to normalize all
	 *   intensities with a dataset. If no value is given, then a it will
	 *   be computed.
	 * @param {number} [minIntensity=null] Minimum intensity of the data. Minimum
	 *   intensity must be a positive real number will be used to normalize all
	 *   intensities with a dataset. If no value is given, then a it will
	 *   be computed.
	 * @param {number} [updateDelay=1000] Delay in milliseconds after a zoom,
	 *   rotate, or pan event before recomputing the heatmap.
	 * @param {boolean|number|'auto'} [binned='auto'] If true or a number,
	 *   spatially bin data as part of producing the heatpmap.  If false, each
	 *   datapoint stands on its own.  If 'auto', bin data if there are more data
	 *   points than there would be bins.  Using true or auto uses bins that are
	 *   max(Math.floor((radius + blurRadius) / 8), 3).
	 * @param {Object|string|Function} [style.color] Color transfer function that.
	 *   will be used to evaluate color of each pixel using normalized intensity
	 *   as the look up value.
	 * @param {Object|Function} [style.radius=10] Radius of a point in terms of
	 *   number of pixels.
	 * @param {Object|Function} [style.blurRadius=10] Blur radius for each point in
	 *  terms of number of pixels.
	 * @param {boolean} [style.gaussian=true] If true, appoximate a gaussian
	 *   distribution for each point using a multi-segment linear radial
	 *   appoximation.  The total weight of the gaussian area is approximately the
	 *   9/16 r^2.  The sum of radius + blurRadius is used as the radius for the
	 *   gaussian distribution.
	 * @returns {geo.heatmapFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	var heatmapFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof heatmapFeature)) {
	    return new heatmapFeature(arg);
	  }
	  arg = arg || {};
	  feature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_position,
	      m_intensity,
	      m_maxIntensity,
	      m_minIntensity,
	      m_updateDelay,
	      m_binned,
	      m_gcsPosition,
	      s_init = this._init;

	  m_position = arg.position || function (d) { return d; };
	  m_intensity = arg.intensity || function (d) { return 1; };
	  m_maxIntensity = arg.maxIntensity !== undefined ? arg.maxIntensity : null;
	  m_minIntensity = arg.minIntensity !== undefined ? arg.minIntensity : null;
	  m_binned = arg.binned !== undefined ? arg.binned : 'auto';
	  m_updateDelay = arg.updateDelay ? parseInt(arg.updateDelay, 10) : 1000;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set maxIntensity
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.maxIntensity = function (val) {
	    if (val === undefined) {
	      return m_maxIntensity;
	    } else {
	      m_maxIntensity = val;
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set maxIntensity
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.minIntensity = function (val) {
	    if (val === undefined) {
	      return m_minIntensity;
	    } else {
	      m_minIntensity = val;
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set updateDelay
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.updateDelay = function (val) {
	    if (val === undefined) {
	      return m_updateDelay;
	    } else {
	      m_updateDelay = parseInt(val, 10);
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set binned
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.binned = function (val) {
	    if (val === undefined) {
	      return m_binned;
	    } else {
	      if (val === 'true') {
	        val = true;
	      } else if (val === 'false') {
	        val = false;
	      } else if (val !== 'auto' && val !== true && val !== false) {
	        val = parseInt(val, 10);
	        if (val <= 0 || isNaN(val)) {
	          val = false;
	        }
	      }
	      m_binned = val;
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set position accessor
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (val) {
	    if (val === undefined) {
	      return m_position;
	    } else {
	      m_position = val;
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get pre-computed gcs position accessor
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.gcsPosition = function () {
	    this._update();
	    return m_gcsPosition;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set intensity
	   *
	   * @returns {geo.heatmap}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.intensity = function (val) {
	    if (val === undefined) {
	      return m_intensity;
	    } else {
	      m_intensity = val;
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(
	      {},
	      {
	        radius: 10,
	        blurRadius: 10,
	        gaussian: true,
	        color: {0:    {r: 0, g: 0, b: 0.0, a: 0.0},
	                0.25: {r: 0, g: 0, b: 1, a: 0.5},
	                0.5:  {r: 0, g: 1, b: 1, a: 0.6},
	                0.75: {r: 1, g: 1, b: 0, a: 0.7},
	                1:    {r: 1, g: 0, b: 0, a: 0.8}}
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    m_this.style(defaultStyle);

	    if (m_position) {
	      m_this.dataTime().modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var data = m_this.data(),
	        intensity = null,
	        position = [],
	        setMax = (m_maxIntensity === null || m_maxIntensity === undefined),
	        setMin = (m_minIntensity === null || m_minIntensity === undefined);

	    data.forEach(function (d) {
	      position.push(m_this.position()(d));
	      if (setMax || setMin) {
	        intensity = m_this.intensity()(d);
	        if (m_maxIntensity === null || m_maxIntensity === undefined) {
	          m_maxIntensity = intensity;
	        }
	        if (m_minIntensity === null || m_minIntensity === undefined) {
	          m_minIntensity = intensity;
	        }
	        if (setMax && intensity > m_maxIntensity) {
	          m_maxIntensity = intensity;
	        }
	        if (setMin && intensity < m_minIntensity) {
	          m_minIntensity = intensity;
	        }

	      }
	    });
	    if (setMin && setMax && m_minIntensity === m_maxIntensity) {
	      m_minIntensity -= 1;
	    }
	    m_gcsPosition = transform.transformCoordinates(
	        m_this.gcs(), m_this.layer().map().gcs(), position);

	    m_this.buildTime().modified();
	    return m_this;
	  };

	  this._init(arg);
	  return this;
	};

	inherit(heatmapFeature, feature);
	module.exports = heatmapFeature;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var feature = __webpack_require__(78);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class vectorFeature
	 *
	 * @class geo.vectorFeature
	 * @extends geo.feature
	 * @returns {geo.vectorFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var vectorFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof vectorFeature)) {
	    return new vectorFeature(arg);
	  }

	  var $ = __webpack_require__(1);

	  arg = arg || {};
	  feature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      s_style = this.style;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the accessor for the origin of the vector.  This is the point
	   * that the vector base resides at.  Defaults to (0, 0, 0).
	   * @param {geo.accessor|geo.geoPosition} [accessor] The origin accessor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.origin = function (val) {
	    if (val === undefined) {
	      return s_style('origin');
	    } else {
	      s_style('origin', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the accessor for the displacement (coordinates) of the vector.
	   * @param {geo.accessor|geo.geoPosition} [accessor] The accessor
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.delta = function (val) {
	    if (val === undefined) {
	      return s_style('delta');
	    } else {
	      s_style('delta', val);
	      m_this.dataTime().modified();
	      m_this.modified();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);

	    var defaultStyle = $.extend(
	      {},
	      {
	        strokeColor: 'black',
	        strokeWidth: 2.0,
	        strokeOpacity: 1.0,
	        originStyle: 'none',
	        endStyle: 'arrow',
	        origin: {x: 0, y: 0, z: 0},
	        delta: function (d) { return d; },
	        scale: null // size scaling factor (null -> renderer decides)
	      },
	      arg.style === undefined ? {} : arg.style
	    );

	    if (arg.origin !== undefined) {
	      defaultStyle.origin = arg.origin;
	    }

	    m_this.style(defaultStyle);
	    m_this.dataTime().modified();
	  };
	};

	inherit(vectorFeature, feature);
	module.exports = vectorFeature;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ("0.10.1");


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ("24d0bb148517e21409b6de1d95815411c75e12e1");


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var geo_event = __webpack_require__(5);
	geo_event.d3 = {
	  rescale: __webpack_require__(236)
	};

	/**
	 * @namespace geo.d3
	 */
	module.exports = {
	  graphFeature: __webpack_require__(237),
	  lineFeature: __webpack_require__(238),
	  object: __webpack_require__(239),
	  pathFeature: __webpack_require__(241),
	  pointFeature: __webpack_require__(242),
	  quadFeature: __webpack_require__(243),
	  renderer: __webpack_require__(244),
	  tileLayer: __webpack_require__(245),
	  uniqueID: __webpack_require__(240),
	  vectorFeature: __webpack_require__(246)
	};


/***/ },
/* 236 */
/***/ function(module, exports) {

	module.exports = 'geo_d3_rescale';


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var graphFeature = __webpack_require__(221);

	/**
	 * @class geo.d3.graphFeature
	 * @extends geo.graphFeature
	 */
	var d3_graphFeature = function (arg) {
	  'use strict';

	  var m_this = this;

	  if (!(this instanceof d3_graphFeature)) {
	    return new d3_graphFeature(arg);
	  }
	  graphFeature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Returns a d3 selection for the graph elements
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.select = function () {
	    var renderer = m_this.renderer(),
	        selection = {},
	        node = m_this.nodeFeature(),
	        links = m_this.linkFeatures();
	    selection.nodes = renderer.select(node._d3id());
	    selection.links = links.map(function (link) {
	      return renderer.select(link._d3id());
	    });
	    return selection;
	  };

	  return this;
	};

	inherit(d3_graphFeature, graphFeature);

	registerFeature('d3', 'graph', d3_graphFeature);

	module.exports = d3_graphFeature;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var lineFeature = __webpack_require__(77);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class lineFeature
	 *
	 * @class geo.d3.lineFeature
	 * @extends geo.lineFeature
	 * @extends geo.d3.object
	 * @returns {geo.d3.lineFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var d3_lineFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof d3_lineFeature)) {
	    return new d3_lineFeature(arg);
	  }

	  var d3 = __webpack_require__(213);
	  var object = __webpack_require__(239);
	  var timestamp = __webpack_require__(195);
	  var util = __webpack_require__(196);

	  arg = arg || {};
	  lineFeature.call(this, arg);
	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      m_buildTime = timestamp(),
	      s_update = this._update;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var data = m_this.data() || [],
	        s_style = m_this.style(),
	        m_renderer = m_this.renderer(),
	        pos_func = m_this.position(),
	        line;

	    s_update.call(m_this);
	    s_style.fill = function () { return false; };

	    data.forEach(function (item, idx) {
	      var m_style;
	      var ln = m_this.line()(item, idx);

	      var style = {}, key;
	      function wrapStyle(func) {
	        if (util.isFunction(func)) {
	          return function () {
	            return func(ln[0], 0, item, idx);
	          };
	        } else {
	          return func;
	        }
	      }
	      for (key in s_style) {
	        if (s_style.hasOwnProperty(key)) {
	          style[key] = wrapStyle(s_style[key]);
	        }
	      }

	      line = d3.svg.line()
	          .x(function (d) { return m_this.featureGcsToDisplay(d).x; })
	          .y(function (d) { return m_this.featureGcsToDisplay(d).y; })
	          .interpolate(m_this.style.get('closed')(item, idx) && ln.length > 2 ?
	                       'linear-closed' : 'linear');
	      // item is an object representing a single line
	      // m_this.line()(item) is an array of coordinates
	      m_style = {
	        data: [ln.map(function (d, i) { return pos_func(d, i, item, idx); })],
	        append: 'path',
	        attributes: {
	          d: line
	        },
	        id: m_this._d3id() + idx,
	        classes: ['d3LineFeature', 'd3SubLine-' + idx],
	        style: style
	      };

	      m_renderer._drawFeatures(m_style);
	    });

	    m_buildTime.modified();
	    m_this.updateTime().modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);

	    if (m_this.getMTime() >= m_buildTime.getMTime()) {
	      m_this._build();
	    }

	    return m_this;
	  };

	  this._init(arg);
	  return this;
	};

	inherit(d3_lineFeature, lineFeature);

	// Now register it
	var capabilities = {};
	capabilities[lineFeature.capabilities.basic] = true;
	capabilities[lineFeature.capabilities.multicolor] = false;

	registerFeature('d3', 'line', d3_lineFeature, capabilities);

	module.exports = d3_lineFeature;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var sceneObject = __webpack_require__(79);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * D3 specific subclass of object which adds an id property for d3 selections
	 * on groups of objects by class id.
	 * @class geo.d3.object
	 * @extends geo.sceneObject
	 */
	//////////////////////////////////////////////////////////////////////////////

	var d3_object = function (arg) {
	  'use strict';

	  var object = __webpack_require__(80);
	  var uniqueID = __webpack_require__(240);

	  // this is used to extend other geojs classes, so only generate
	  // a new object when that is not the case... like if this === window
	  if (!(this instanceof object)) {
	    return new d3_object(arg);
	  }
	  sceneObject.call(this);

	  var m_id = 'd3-' + uniqueID(),
	      s_exit = this._exit,
	      m_this = this,
	      s_draw = this.draw;

	  this._d3id = function () {
	    return m_id;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Returns a d3 selection for the feature elements
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.select = function () {
	    return m_this.renderer().select(m_this._d3id());
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Redraw the object.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	    m_this._update();
	    s_draw();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Removes the element from the svg and the renderer
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.renderer()._removeFeature(m_this._d3id());
	    s_exit();
	  };

	  return this;
	};

	inherit(d3_object, sceneObject);
	module.exports = d3_object;


/***/ },
/* 240 */
/***/ function(module, exports) {

	var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz',
	    strLength = 8;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Get a random string to use as a div ID
	 * @function geo.d3.uniqueID
	 * @returns {string}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var uniqueID = function () {
	  var strArray = [],
	      i;
	  strArray.length = strLength;
	  for (i = 0; i < strLength; i += 1) {
	    strArray[i] = chars.charAt(Math.floor(Math.random() * chars.length));
	  }
	  return strArray.join('');
	};

	module.exports = uniqueID;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var pathFeature = __webpack_require__(230);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class pathFeature
	 *
	 * @class geo.d3.pathFeature
	 * @extends geo.pathFeature
	 * @extends geo.d3.object
	 * @returns {geo.d3.pathFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var d3_pathFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof d3_pathFeature)) {
	    return new d3_pathFeature(arg);
	  }

	  var $ = __webpack_require__(1);
	  var d3 = __webpack_require__(213);
	  var object = __webpack_require__(239);
	  var timestamp = __webpack_require__(195);

	  arg = arg || {};
	  pathFeature.call(this, arg);
	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      m_buildTime = timestamp(),
	      s_update = this._update,
	      m_style = {};

	  m_style.style = {};

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var data = m_this.data() || [],
	        s_style = m_this.style(),
	        tmp, diag;
	    s_update.call(m_this);

	    diag = function (d) {
	      var p = {
	        source: d.source,
	        target: d.target
	      };
	      return d3.svg.diagonal()(p);
	    };
	    tmp = [];
	    data.forEach(function (d, i) {
	      var src, trg;
	      if (i < data.length - 1) {
	        src = d;
	        trg = data[i + 1];
	        tmp.push({
	          source: m_this.featureGcsToDisplay(src),
	          target: m_this.featureGcsToDisplay(trg)
	        });
	      }
	    });
	    m_style.data = tmp;
	    m_style.attributes = {
	      d: diag
	    };

	    m_style.id = m_this._d3id();
	    m_style.append = 'path';
	    m_style.classes = ['d3PathFeature'];
	    m_style.style = $.extend({
	      'fill': function () { return false; },
	      'fillColor': function () { return { r: 0, g: 0, b: 0 }; }
	    }, s_style);

	    m_this.renderer()._drawFeatures(m_style);

	    m_buildTime.modified();
	    m_this.updateTime().modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);

	    if (m_this.dataTime().getMTime() >= m_buildTime.getMTime()) {
	      m_this._build();
	    }

	    return m_this;
	  };

	  this._init(arg);
	  return this;
	};

	inherit(d3_pathFeature, pathFeature);

	registerFeature('d3', 'path', d3_pathFeature);

	module.exports = d3_pathFeature;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var pointFeature = __webpack_require__(203);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 *
	 * Create a new instance of pointFeature
	 *
	 * @class geo.d3.pointFeature
	 * @extends geo.pointFeature
	 * @extends geo.d3.object
	 * @returns {geo.d3.pointFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var d3_pointFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof d3_pointFeature)) {
	    return new d3_pointFeature(arg);
	  }

	  var d3_object = __webpack_require__(239);
	  var timestamp = __webpack_require__(195);

	  arg = arg || {};
	  pointFeature.call(this, arg);
	  d3_object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      s_update = this._update,
	      m_buildTime = timestamp(),
	      m_style = {};

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var data = m_this.data(),
	        s_style = m_this.style.get(),
	        m_renderer = m_this.renderer(),
	        pos_func = m_this.position();

	    // call super-method
	    s_update.call(m_this);

	    // default to empty data array
	    if (!data) { data = []; }

	    // fill in d3 renderer style object defaults
	    m_style.id = m_this._d3id();
	    m_style.data = data;
	    m_style.append = 'circle';
	    m_style.attributes = {
	      r: m_renderer._convertScale(s_style.radius),
	      cx: function (d) {
	        return m_this.featureGcsToDisplay(pos_func(d)).x;
	      },
	      cy: function (d) {
	        return m_this.featureGcsToDisplay(pos_func(d)).y;
	      }
	    };
	    m_style.style = s_style;
	    m_style.classes = ['d3PointFeature'];

	    // pass to renderer to draw
	    m_this.renderer()._drawFeatures(m_style);

	    // update time stamps
	    m_buildTime.modified();
	    m_this.updateTime().modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);

	    if (m_this.getMTime() >= m_buildTime.getMTime()) {
	      m_this._build();
	    }

	    return m_this;
	  };

	  this._init(arg);
	  return this;
	};

	inherit(d3_pointFeature, pointFeature);

	// Now register it
	registerFeature('d3', 'point', d3_pointFeature);

	module.exports = d3_pointFeature;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var quadFeature = __webpack_require__(211);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class quadFeature
	 *
	 * @class geo.d3.quadFeature
	 * @param {Object} arg Options object
	 * @extends geo.quadFeature
	 * @returns {geo.d3.quadFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var d3_quadFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof d3_quadFeature)) {
	    return new d3_quadFeature(arg);
	  }

	  var $ = __webpack_require__(1);
	  var d3 = __webpack_require__(213);
	  var object = __webpack_require__(239);

	  quadFeature.call(this, arg);
	  object.call(this);

	  var m_this = this,
	      s_exit = this._exit,
	      s_init = this._init,
	      s_update = this._update,
	      m_quads;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build this feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    if (!this.position()) {
	      return;
	    }
	    var renderer = this.renderer(),
	        map = renderer.layer().map();

	    m_quads = this._generateQuads();

	    var data = [];
	    $.each(m_quads.clrQuads, function (idx, quad) {
	      data.push({type: 'clr', quad: quad, zIndex: quad.pos[2]});
	    });
	    $.each(m_quads.imgQuads, function (idx, quad) {
	      if (quad.image) {
	        data.push({type: 'img', quad: quad, zIndex: quad.pos[2]});
	      }
	    });

	    var feature = {
	      id: this._d3id(),
	      data: data,
	      dataIndex: function (d) {
	        return d.quad.quadId;
	      },
	      append: function (d) {
	        var ns = this.namespaceURI,
	            element = d.type === 'clr' ? 'polygon' : 'image';
	        return (ns ? document.createElementNS(ns, element) :
	                document.createElement(element));
	      },
	      attributes: {
	        fill: function (d) {
	          if (d.type === 'clr') {
	            return d3.rgb(255 * d.quad.color.r, 255 * d.quad.color.g,
	                          255 * d.quad.color.b);
	          }
	          /* set some styles here */
	          if (d.quad.opacity !== 1) {
	            d3.select(this).style('opacity', d.quad.opacity);
	          }
	        },
	        height: function (d) {
	          return d.type === 'clr' ? undefined : 1;
	        },
	        points: function (d) {
	          if (d.type === 'clr' && !d.points) {
	            var points = [], i;
	            for (i = 0; i < d.quad.pos.length; i += 3) {
	              var p = {
	                x: d.quad.pos[i],
	                y: d.quad.pos[i + 1],
	                z: d.quad.pos[i + 2]
	              };
	              /* We don't use 'p = m_this.featureGcsToDisplay(p);' because the
	               * quads have already been converted to the map's gcs (no longer
	               * the feature's gcs or map's ingcs). */
	              p = map.gcsToDisplay(p, null);
	              p = renderer.baseToLocal(p);
	              points.push('' + p.x + ',' + p.y);
	            }
	            d.points = (points[0] + ' ' + points[1] + ' ' + points[3] + ' ' +
	                        points[2]);
	          }
	          return d.type === 'clr' ? d.points : undefined;
	        },
	        preserveAspectRatio: function (d) {
	          return d.type === 'clr' ? undefined : 'none';
	        },
	        reference: function (d) {
	          return d.quad.reference;
	        },
	        stroke: false,
	        transform: function (d) {
	          if (d.type === 'img' && d.quad.image && !d.svgTransform) {
	            var pos = [], area, maxarea = -1, maxv, i, imgscale,
	                imgw = d.quad.image.width, imgh = d.quad.image.height;
	            for (i = 0; i < d.quad.pos.length; i += 3) {
	              var p = {
	                x: d.quad.pos[i],
	                y: d.quad.pos[i + 1],
	                z: d.quad.pos[i + 2]
	              };
	              /* We don't use 'p = m_this.featureGcsToDisplay(p);' because the
	               * quads have already been converted to the map's gcs (no longer
	               * the feature's gcs or map's ingcs). */
	              p = map.gcsToDisplay(p, null);
	              p = renderer.baseToLocal(p);
	              pos.push(p);
	            }
	            /* We can only fit three corners of the quad to the image, but we
	             * get to pick which three.  We choose to always include the
	             * largest of the triangles formed by a set of three vertices.  The
	             * image is always rendered as a parallelogram, so it may be larger
	             * than desired, and, for convex quads, miss some of the intended
	             * area. */
	            for (i = 0; i < 4; i += 1) {
	              area = Math.abs(
	                pos[(i + 1) % 4].x * (pos[(i + 2) % 4].y - pos[(i + 3) % 4].y) +
	                pos[(i + 2) % 4].x * (pos[(i + 3) % 4].y - pos[(i + 1) % 4].y) +
	                pos[(i + 3) % 4].x * (pos[(i + 1) % 4].y - pos[(i + 2) % 4].y)) / 2;
	              if (area > maxarea) {
	                maxarea = area;
	                maxv = i;
	              }
	            }
	            d.svgTransform = [
	              maxv === 3 || maxv === 2 ? pos[1].x - pos[0].x : pos[3].x - pos[2].x,
	              maxv === 3 || maxv === 2 ? pos[1].y - pos[0].y : pos[3].y - pos[2].y,
	              maxv === 0 || maxv === 2 ? pos[1].x - pos[3].x : pos[0].x - pos[2].x,
	              maxv === 0 || maxv === 2 ? pos[1].y - pos[3].y : pos[0].y - pos[2].y,
	              maxv === 2 ? pos[3].x + pos[0].x - pos[1].x : pos[2].x,
	              maxv === 2 ? pos[3].y + pos[0].y - pos[1].y : pos[2].y
	            ];
	            if (Math.abs(d.svgTransform[1] / imgw) < 1e-6 &&
	                Math.abs(d.svgTransform[2] / imgh) < 1e-6) {
	              imgscale = d.svgTransform[0] / imgw;
	              d.svgTransform[4] = Math.round(d.svgTransform[4] / imgscale) * imgscale;
	              imgscale = d.svgTransform[3] / imgh;
	              d.svgTransform[5] = Math.round(d.svgTransform[5] / imgscale) * imgscale;
	            }
	          }
	          return ((d.type !== 'img' || !d.quad.image) ? undefined :
	                  'matrix(' + d.svgTransform.join(' ') + ')');
	        },
	        width: function (d) {
	          return d.type === 'clr' ? undefined : 1;
	        },
	        x: function (d) {
	          return d.type === 'clr' ? undefined : 0;
	        },
	        'xlink:href': function (d) {
	          return ((d.type === 'clr' || !d.quad.image) ? undefined :
	                  d.quad.image.src);
	        },
	        y: function (d) {
	          return d.type === 'clr' ? undefined : 0;
	        }
	      },
	      style: {
	        fillOpacity: function (d) {
	          return d.type === 'clr' ? d.quad.opacity : undefined;
	        }
	      },
	      onlyRenderNew: !this.style('previewColor') && !this.style('previewImage'),
	      sortByZ: true,
	      classes: ['d3QuadFeature']
	    };
	    renderer._drawFeatures(feature);

	    this.buildTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);
	    if (m_this.buildTime().getMTime() <= m_this.dataTime().getMTime() ||
	        m_this.buildTime().getMTime() < m_this.getMTime()) {
	      m_this._build();
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    s_init.call(m_this, arg);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    s_exit.call(m_this);
	  };

	  m_this._init(arg);
	  return this;
	};

	inherit(d3_quadFeature, quadFeature);

	// Now register it
	var capabilities = {};
	capabilities[quadFeature.capabilities.color] = true;
	capabilities[quadFeature.capabilities.image] = true;
	capabilities[quadFeature.capabilities.imageCrop] = false;
	capabilities[quadFeature.capabilities.imageFull] = false;

	registerFeature('d3', 'quad', d3_quadFeature, capabilities);
	module.exports = d3_quadFeature;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerRenderer = __webpack_require__(76).registerRenderer;
	var renderer = __webpack_require__(217);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class d3Renderer
	 *
	 * @class geo.d3.renderer
	 * @extends geo.renderer
	 * @returns {geo.d3.d3Renderer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var d3Renderer = function (arg) {
	  'use strict';

	  var d3 = __webpack_require__(213);
	  var object = __webpack_require__(239);
	  var util = __webpack_require__(196);
	  var geo_event = __webpack_require__(5);
	  var d3Rescale = __webpack_require__(236);

	  if (!(this instanceof d3Renderer)) {
	    return new d3Renderer(arg);
	  }
	  renderer.call(this, arg);

	  var s_exit = this._exit;

	  object.call(this, arg);

	  arg = arg || {};

	  var m_this = this,
	      m_sticky = null,
	      m_features = {},
	      m_corners = null,
	      m_width = null,
	      m_height = null,
	      m_diagonal = null,
	      m_scale = 1,
	      m_transform = {dx: 0, dy: 0, rx: 0, ry: 0, rotation: 0},
	      m_renderAnimFrameRef = null,
	      m_renderIds = {},
	      m_removeIds = {},
	      m_svg = null,
	      m_defs = null;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set attributes to a d3 selection.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function setAttrs(select, attrs) {
	    var key;
	    for (key in attrs) {
	      if (attrs.hasOwnProperty(key)) {
	        select.attr(key, attrs[key]);
	      }
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Meta functions for converting from geojs styles to d3.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._convertColor = function (f, g) {
	    f = util.ensureFunction(f);
	    g = g || function () { return true; };
	    return function () {
	      var c = 'none';
	      if (g.apply(m_this, arguments)) {
	        c = f.apply(m_this, arguments);
	        if (c.hasOwnProperty('r') &&
	            c.hasOwnProperty('g') &&
	            c.hasOwnProperty('b')) {
	          c = d3.rgb(255 * c.r, 255 * c.g, 255 * c.b);
	        }
	      }
	      return c;
	    };
	  };

	  this._convertScale = function (f) {
	    f = util.ensureFunction(f);
	    return function () {
	      return f.apply(m_this, arguments) / m_scale;
	    };
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set styles to a d3 selection. Ignores unkown style keys.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function setStyles(select, styles) {
	    var key, k, f;
	    function fillFunc() {
	      if (styles.fill.apply(m_this, arguments)) {
	        return null;
	      } else {
	        return 'none';
	      }
	    }
	    function strokeFunc() {
	      if (styles.stroke.apply(m_this, arguments)) {
	        return null;
	      } else {
	        return 'none';
	      }
	    }
	    for (key in styles) {
	      if (styles.hasOwnProperty(key)) {
	        f = null;
	        k = null;
	        if (key === 'strokeColor') {
	          k = 'stroke';
	          f = m_this._convertColor(styles[key], styles.stroke);
	        } else if (key === 'stroke' && styles[key] &&
	                   !styles.hasOwnProperty('strokeColor')) {
	          k = 'stroke';
	          f = strokeFunc;
	        } else if (key === 'strokeWidth') {
	          k = 'stroke-width';
	          f = m_this._convertScale(styles[key]);
	        } else if (key === 'strokeOpacity') {
	          k = 'stroke-opacity';
	          f = styles[key];
	        } else if (key === 'fillColor') {
	          k = 'fill';
	          f = m_this._convertColor(styles[key], styles.fill);
	        } else if (key === 'fill' && !styles.hasOwnProperty('fillColor')) {
	          k = 'fill';
	          f = fillFunc;
	        } else if (key === 'fillOpacity') {
	          k = 'fill-opacity';
	          f = styles[key];
	        }
	        if (k) {
	          select.style(k, f);
	        }
	      }
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the svg group element associated with this renderer instance, or of a
	   * group within the render instance.
	   *
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function getGroup(parentId) {
	    if (parentId) {
	      return m_svg.select('.group-' + parentId);
	    }
	    return m_svg.select('.group-' + m_this._d3id());
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set the initial lat-lon coordinates of the map view.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function initCorners() {
	    var layer = m_this.layer(),
	        map = layer.map(),
	        width = map.size().width,
	        height = map.size().height;

	    m_width = width;
	    m_height = height;
	    if (!m_width || !m_height) {
	      throw 'Map layer has size 0';
	    }
	    m_diagonal = Math.pow(width * width + height * height, 0.5);
	    m_corners = {
	      upperLeft: map.displayToGcs({'x': 0, 'y': 0}, null),
	      lowerRight: map.displayToGcs({'x': width, 'y': height}, null),
	      center: map.displayToGcs({'x': width / 2, 'y': height / 2}, null)
	    };
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Set the translation, scale, and zoom for the current view.
	   * @note rotation not yet supported
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._setTransform = function () {
	    if (!m_corners) {
	      initCorners();
	    }

	    if (!m_sticky) {
	      return;
	    }

	    var layer = m_this.layer();

	    var map = layer.map(),
	        upperLeft = map.gcsToDisplay(m_corners.upperLeft, null),
	        lowerRight = map.gcsToDisplay(m_corners.lowerRight, null),
	        center = map.gcsToDisplay(m_corners.center, null),
	        group = getGroup(),
	        dx, dy, scale, rotation, rx, ry;

	    scale = Math.sqrt(
	      Math.pow(lowerRight.y - upperLeft.y, 2) +
	      Math.pow(lowerRight.x - upperLeft.x, 2)) / m_diagonal;
	    // calculate the translation
	    rotation = map.rotation();
	    rx = -m_width / 2;
	    ry = -m_height / 2;
	    dx = scale * rx + center.x;
	    dy = scale * ry + center.y;

	    // set the group transform property
	    if (!rotation) {
	      dx = Math.round(dx);
	      dy = Math.round(dy);
	    }
	    var transform = 'matrix(' + [scale, 0, 0, scale, dx, dy].join() + ')';
	    if (rotation) {
	      transform += ' rotate(' + [
	        rotation * 180 / Math.PI, -rx, -ry].join() + ')';
	    }
	    group.attr('transform', transform);

	    // set internal variables
	    m_scale = scale;
	    m_transform.dx = dx;
	    m_transform.dy = dy;
	    m_transform.rx = rx;
	    m_transform.ry = ry;
	    m_transform.rotation = rotation;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from screen pixel coordinates to the local coordinate system
	   * in the SVG group element taking into account the transform.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.baseToLocal = function (pt) {
	    pt = {
	      x: (pt.x - m_transform.dx) / m_scale,
	      y: (pt.y - m_transform.dy) / m_scale
	    };
	    if (m_transform.rotation) {
	      var sinr = Math.sin(-m_transform.rotation),
	          cosr = Math.cos(-m_transform.rotation);
	      var x = pt.x + m_transform.rx, y = pt.y + m_transform.ry;
	      pt = {
	        x: x * cosr - y * sinr - m_transform.rx,
	        y: x * sinr + y * cosr - m_transform.ry
	      };
	    }
	    return pt;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Convert from the local coordinate system in the SVG group element
	   * to screen pixel coordinates.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.localToBase = function (pt) {
	    if (m_transform.rotation) {
	      var sinr = Math.sin(m_transform.rotation),
	          cosr = Math.cos(m_transform.rotation);
	      var x = pt.x + m_transform.rx, y = pt.y + m_transform.ry;
	      pt = {
	        x: x * cosr - y * sinr - m_transform.rx,
	        y: x * sinr + y * cosr - m_transform.ry
	      };
	    }
	    pt = {
	      x: pt.x * m_scale + m_transform.dx,
	      y: pt.y * m_scale + m_transform.dy
	    };
	    return pt;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    if (!m_this.canvas()) {
	      var canvas;
	      arg.widget = arg.widget || false;

	      if ('d3Parent' in arg) {
	        m_svg = d3.select(arg.d3Parent).append('svg');
	      } else {
	        m_svg = d3.select(m_this.layer().node().get(0)).append('svg');
	      }

	      // create a global svg definitions element
	      m_defs = m_svg.append('defs');

	      var shadow = m_defs
	        .append('filter')
	          .attr('id', 'geo-highlight')
	          .attr('x', '-100%')
	          .attr('y', '-100%')
	          .attr('width', '300%')
	          .attr('height', '300%');
	      shadow
	        .append('feMorphology')
	          .attr('operator', 'dilate')
	          .attr('radius', 2)
	          .attr('in', 'SourceAlpha')
	          .attr('result', 'dilateOut');
	      shadow
	        .append('feGaussianBlur')
	          .attr('stdDeviation', 5)
	          .attr('in', 'dilateOut')
	          .attr('result', 'blurOut');
	      shadow
	        .append('feColorMatrix')
	          .attr('type', 'matrix')
	          .attr('values', '-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0')
	          .attr('in', 'blurOut')
	          .attr('result', 'invertOut');
	      shadow
	        .append('feBlend')
	          .attr('in', 'SourceGraphic')
	          .attr('in2', 'invertOut')
	          .attr('mode', 'normal');

	      if (!arg.widget) {
	        canvas = m_svg.append('g');
	      }

	      shadow = m_defs.append('filter')
	          .attr('id', 'geo-blur')
	          .attr('x', '-100%')
	          .attr('y', '-100%')
	          .attr('width', '300%')
	          .attr('height', '300%');

	      shadow
	        .append('feGaussianBlur')
	          .attr('stdDeviation', 20)
	          .attr('in', 'SourceGraphic');

	      m_sticky = m_this.layer().sticky();
	      m_svg.attr('class', m_this._d3id());
	      m_svg.attr('width', m_this.layer().node().width());
	      m_svg.attr('height', m_this.layer().node().height());

	      if (!arg.widget) {
	        canvas.attr('class', 'group-' + m_this._d3id());

	        m_this.canvas(canvas);
	      } else {
	        m_this.canvas(m_svg);
	      }
	    }
	    m_this._setTransform();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get API used by the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.api = function () {
	    return 'd3';
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the current scaling factor to build features that shouldn't
	   * change size during zooms.  For example:
	   *
	   *  selection.append('circle')
	   *    .attr('r', r0 / renderer.scaleFactor());
	   *
	   * This will create a circle element with radius r0 independent of the
	   * current zoom level.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.scaleFactor = function () {
	    return m_scale;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle resize event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._resize = function (x, y, w, h) {
	    if (!m_corners) {
	      initCorners();
	    }
	    m_svg.attr('width', w);
	    m_svg.attr('height', h);
	    m_this._setTransform();
	    m_this.layer().geoTrigger(geo_event.d3Rescale, { scale: m_scale }, true);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update noop for geo.d3.object api.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Exit
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_features = {};
	    m_this.canvas().remove();
	    m_svg.remove();
	    m_svg = undefined;
	    m_defs.remove();
	    m_defs = undefined;
	    m_renderIds = {};
	    m_removeIds = {};
	    s_exit();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the definitions dom element for the layer
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._definitions = function () {
	    return m_defs;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create a new feature element from an object that describes the feature
	   * attributes.  To be called from feature classes only.
	   *
	   * Input:
	   *  {
	   *    id:         A unique string identifying the feature.
	   *    data:       Array of data objects used in a d3 data method.
	   *    dataIndex:  A function that returns a unique id for each data element.
	   *    defs:       If set, a dictionary with values to render in the defs
	   *                section.  This can contain data, index, append, attributes,
	   *                classes, style, and enter.  enter is a function that is
	   *                called on new elements.
	   *    style:      An object containing element CSS styles.
	   *    attributes: An object containing element attributes.
	   *    classes:    An array of classes to add to the elements.
	   *    append:     The element type as used in d3 append methods.
	   *    onlyRenderNew: a boolean.  If true, features only get attributes and
	   *                styles set when new.  If false, features always have
	   *                attributes and styles updated.
	   *    sortByZ:    a boolean.  If true, sort features by the d.zIndex.
	   *    parentId:   If set, the group ID of the parent element.
	   *  }
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._drawFeatures = function (arg) {
	    m_features[arg.id] = {
	      data: arg.data,
	      index: arg.dataIndex,
	      style: arg.style,
	      attributes: arg.attributes,
	      classes: arg.classes,
	      append: arg.append,
	      onlyRenderNew: arg.onlyRenderNew,
	      sortByZ: arg.sortByZ,
	      parentId: arg.parentId
	    };
	    return m_this.__render(arg.id, arg.parentId);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Updates a feature by performing a d3 data join.  If no input id is
	  *  provided then this method will update all features.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.__render = function (id, parentId) {
	    var key;
	    if (id === undefined) {
	      for (key in m_features) {
	        if (m_features.hasOwnProperty(key)) {
	          m_this.__render(key);
	        }
	      }
	      return m_this;
	    }
	    if (parentId) {
	      m_this._renderFeature(id, parentId);
	    } else {
	      m_renderIds[id] = true;
	      if (m_renderAnimFrameRef === null) {
	        m_renderAnimFrameRef = window.requestAnimationFrame(m_this._renderFrame);
	      }
	    }
	  };

	  this._renderFrame = function () {
	    var id;
	    for (id in m_removeIds) {
	      m_this.select(id).remove();
	      m_defs.selectAll('.' + id).remove();
	    }
	    m_removeIds = {};
	    var ids = m_renderIds;
	    m_renderIds = {};
	    m_renderAnimFrameRef = null;
	    for (id in ids) {
	      if (ids.hasOwnProperty(id)) {
	        m_this._renderFeature(id);
	      }
	    }
	  };

	  this._renderFeature = function (id, parentId) {
	    if (!m_features[id]) {
	      return;
	    }
	    var data = m_features[id].data,
	        index = m_features[id].index,
	        style = m_features[id].style,
	        attributes = m_features[id].attributes,
	        classes = m_features[id].classes,
	        append = m_features[id].append,
	        selection = m_this.select(id, parentId).data(data, index),
	        entries, rendersel;
	    entries = selection.enter().append(append);
	    selection.exit().remove();
	    rendersel = m_features[id].onlyRenderNew ? entries : selection;
	    setAttrs(rendersel, attributes);
	    rendersel.attr('class', classes.concat([id]).join(' '));
	    setStyles(rendersel, style);
	    if (entries.size() && m_features[id].sortByZ) {
	      selection.sort(function (a, b) {
	        return (a.zIndex || 0) - (b.zIndex || 0);
	      });
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Returns a d3 selection for the given feature id.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.select = function (id, parentId) {
	    return getGroup(parentId).selectAll('.' + id);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Removes a feature from the layer.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this._removeFeature = function (id) {
	    m_removeIds[id] = true;
	    if (m_renderAnimFrameRef === null) {
	      m_renderAnimFrameRef = window.requestAnimationFrame(m_this._renderFrame);
	    }
	    delete m_features[id];
	    if (m_renderIds[id]) {
	      delete m_renderIds[id];
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Override draw method to do nothing.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	  };

	  // connect to pan event
	  this.layer().geoOn(geo_event.pan, m_this._setTransform);

	  // connect to rotate event
	  this.layer().geoOn(geo_event.rotate, m_this._setTransform);

	  // connect to zoom event
	  this.layer().geoOn(geo_event.zoom, function () {
	    m_this._setTransform();
	    m_this.__render();
	    m_this.layer().geoTrigger(d3Rescale, { scale: m_scale }, true);
	  });

	  this.layer().geoOn(geo_event.resize, function (event) {
	    m_this._resize(event.x, event.y, event.width, event.height);
	  });

	  this._init(arg);
	  return this;
	};

	inherit(d3Renderer, renderer);

	registerRenderer('d3', d3Renderer);

	(function () {
	  'use strict';

	  /**
	   * Report if the d3 renderer is supported.  This is just a check if d3 is
	   * available.
	   *
	   * @returns {boolean} true if available.
	   */
	  d3Renderer.supported = function () {
	    return !!__webpack_require__.m[/*require.resolve*/(213)]; // eslint-disable-line
	  };

	  /**
	   * If the d3 renderer is not supported, supply the name of a renderer that
	   * should be used instead.  This asks for the null renderer.
	   *
	   * @returns null for the null renderer.
	   */
	  d3Renderer.fallback = function () {
	    return null;
	  };
	})();

	module.exports = d3Renderer;


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var registerLayerAdjustment = __webpack_require__(76).registerLayerAdjustment;

	var d3_tileLayer = function () {
	  'use strict';
	  var m_this = this,
	      s_init = this._init,
	      s_exit = this._exit,
	      m_quadFeature,
	      m_nextTileId = 0,
	      m_tiles = [];

	  this._drawTile = function (tile) {
	    if (!m_quadFeature) {
	      return;
	    }
	    var bounds = m_this._tileBounds(tile),
	        level = tile.index.level || 0,
	        to = this._tileOffset(level),
	        quad = {};
	    quad.ul = this.fromLocal(this.fromLevel({
	      x: bounds.left - to.x, y: bounds.top - to.y
	    }, level), 0);
	    quad.ll = this.fromLocal(this.fromLevel({
	      x: bounds.left - to.x, y: bounds.bottom - to.y
	    }, level), 0);
	    quad.ur = this.fromLocal(this.fromLevel({
	      x: bounds.right - to.x, y: bounds.top - to.y
	    }, level), 0);
	    quad.lr = this.fromLocal(this.fromLevel({
	      x: bounds.right - to.x, y: bounds.bottom - to.y
	    }, level), 0);
	    quad.ul.z = quad.ll.z = quad.ur.z = quad.lr.z = level * 1e-5;
	    m_nextTileId += 1;
	    quad.id = m_nextTileId;
	    tile.quadId = quad.id;
	    quad.image = tile.image;
	    quad.reference = tile.toString();
	    m_tiles.push(quad);
	    m_quadFeature.data(m_tiles);
	    m_quadFeature._update();
	    m_this.draw();
	  };

	  /* Remove the tile feature. */
	  this._remove = function (tile) {
	    if (tile.quadId !== undefined && m_quadFeature) {
	      for (var i = 0; i < m_tiles.length; i += 1) {
	        if (m_tiles[i].id === tile.quadId) {
	          m_tiles.splice(i, 1);
	          break;
	        }
	      }
	      m_quadFeature.data(m_tiles);
	      m_quadFeature._update();
	      m_this.draw();
	    }
	  };

	  /**
	   * Clean up the layer.
	   */
	  this._exit = function () {
	    m_this.deleteFeature(m_quadFeature);
	    m_quadFeature = null;
	    m_tiles = [];
	    s_exit.apply(m_this, arguments);
	  };

	  /* Initialize the tile layer.  This creates a series of sublayers so that
	   * the different layers will stack in the proper order.
	   */
	  this._init = function () {
	    s_init.apply(m_this, arguments);
	    m_quadFeature = this.createFeature('quad', {
	      previewColor: m_this._options.previewColor,
	      previewImage: m_this._options.previewImage
	    });
	    m_quadFeature.geoTrigger = undefined;
	    m_quadFeature.gcs(m_this._options.gcs || m_this.map().gcs());
	    m_quadFeature.data(m_tiles);
	    m_quadFeature._update();
	  };

	  this._getSubLayer = function () {};
	  this._updateSubLayers = undefined;
	};

	registerLayerAdjustment('d3', 'tile', d3_tileLayer);
	module.exports = d3_tileLayer;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var vectorFeature = __webpack_require__(232);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of vectorFeature
	 *
	 * @class geo.d3.vectorFeature
	 * @extends geo.vectorFeature
	 * @extends geo.d3.object
	 * @returns {geo.d3.vectorFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var d3_vectorFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof d3_vectorFeature)) {
	    return new d3_vectorFeature(arg);
	  }

	  var object = __webpack_require__(239);
	  var timestamp = __webpack_require__(195);
	  var d3 = __webpack_require__(213);

	  arg = arg || {};
	  vectorFeature.call(this, arg);
	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_init = this._init,
	      s_exit = this._exit,
	      s_update = this._update,
	      m_buildTime = timestamp(),
	      m_style = {};

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Generate a unique ID for a marker definition
	   * @private
	   * @param {object} d Unused datum (for d3 compat)
	   * @param {number} i The marker index
	   * @param {string} position The marker's vector position (head or tail)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function markerID(d, i, position) {
	    return m_this._d3id() + '_marker_' + i + '_' + position;
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add marker styles for vector arrows.
	   * @private
	   * @param {object[]} data The vector data array
	   * @param {function} stroke The stroke accessor
	   * @param {function} opacity The opacity accessor
	   * @param {function} originStyle The marker style for the vector head
	   * @param {function} endStyle The marker style for the vector tail
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  function updateMarkers(data, stroke, opacity, originStyle, endStyle) {

	    var markerConfigs = {
	      'arrow': {
	        attrs: {'class': 'geo-vector-arrow geo-vector-marker', 'viewBox': '0 0 10 10', 'refX': '1', 'refY': '5', 'markerHeight': '5', 'markerWidth': '5', 'orient': 'auto'},
	        path: 'M 0 0 L 10 5 L 0 10 z'
	      },
	      'point': {
	        attrs: {'class': 'geo-vector-point geo-vector-marker', 'viewBox': '0 0 12 12', 'refX': '6', 'refY': '6', 'markerHeight': '8', 'markerWidth': '8', 'orient': 'auto'},
	        path: 'M 6 3 A 3 3 0 1 1 5.99999 3 Z'
	      },
	      'bar': {
	        attrs: {'class': 'geo-vector-bar geo-vector-marker', 'viewBox': '0 0 10 10', 'refX': '0', 'refY': '5', 'markerHeight': '6', 'markerWidth': '6', 'orient': 'auto'},
	        path: 'M 0 0 L 2 0 L 2 10 L 0 10 z'
	      },
	      'wedge': {
	        attrs: {'class': 'geo-vector-wedge geo-vector-marker', 'viewBox': '0 0 10 10', 'refX': '10', 'refY': '5', 'markerHeight': '5', 'markerWidth': '5', 'orient': 'auto'},
	        path: 'M 0 0 L 1 0 L 10 5 L 1 10 L 0 10 L 9 5 L 0 0'
	      }
	    };

	    //this allows for multiple VectorFeatures in a layer
	    var markerGroup = m_this.renderer()._definitions()
	      .selectAll('g.marker-group#' + m_this._d3id())
	      .data(data.length ? [1] : []);

	    markerGroup
	      .enter()
	      .append('g')
	      .attr('id', m_this._d3id)
	      .attr('class', 'marker-group');

	    markerGroup.exit().remove();

	    var markers = data.reduce(function (markers, d, i) {
	      var head = markerConfigs[endStyle(d, i)];
	      var tail = markerConfigs[originStyle(d, i)];
	      if (head) {
	        markers.push({
	          data: d,
	          dataIndex: i,
	          head: true
	        });
	      }
	      if (tail) {
	        markers.push({
	          data: d,
	          dataIndex: i,
	          head: false
	        });
	      }
	      return markers;
	    }, []);

	    var sel = markerGroup
	      .selectAll('marker.geo-vector-marker')
	      .data(markers);

	    sel.enter()
	      .append('marker')
	      .append('path');

	    var renderer = m_this.renderer();

	    sel
	      .each(function (d) {
	        var marker = d3.select(this);
	        var markerData = d.head ? markerConfigs[endStyle(d.data, d.dataIndex)] : markerConfigs[originStyle(d.data, d.dataIndex)];
	        Object.keys(markerData.attrs).map(function (attrName) {
	          marker.attr(attrName, markerData.attrs[attrName]);
	        });
	      })
	      .attr('id', function (d) {
	        return markerID(d.data, d.dataIndex, d.head ? 'head' : 'tail');
	      })
	      .style('stroke', function (d) {
	        return renderer._convertColor(stroke)(d.data, d.dataIndex);
	      })
	      .style('fill', function (d) {
	        return renderer._convertColor(stroke)(d.data, d.dataIndex);
	      })
	      .style('opacity', function (d) {
	        return opacity(d.data, d.dataIndex);
	      })
	      .select('path')
	      .attr('d', function (d) {
	        return d.head ? markerConfigs[endStyle(d.data, d.dataIndex)].path : markerConfigs[originStyle(d.data, d.dataIndex)].path;
	      });

	    sel.exit().remove();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var data = m_this.data(),
	        s_style = m_this.style.get(),
	        m_renderer = m_this.renderer(),
	        orig_func = m_this.origin(),
	        size_func = m_this.delta(),
	        cache = [],
	        scale = m_this.style('scale'),
	        max = Number.NEGATIVE_INFINITY;

	    // call super-method
	    s_update.call(m_this);

	    // default to empty data array
	    if (!data) { data = []; }

	    // cache the georeferencing
	    cache = data.map(function (d, i) {
	      var origin = m_this.featureGcsToDisplay(orig_func(d, i)),
	          delta = size_func(d, i);
	      max = Math.max(max, delta.x * delta.x + delta.y * delta.y);
	      return {
	        x1: origin.x,
	        y1: origin.y,
	        dx: delta.x,
	        dy: -delta.y
	      };
	    });

	    max = Math.sqrt(max);
	    if (!scale) {
	      scale = 75 / max;
	    }

	    function getScale() {
	      return scale / m_renderer.scaleFactor();
	    }

	    // fill in d3 renderer style object defaults
	    m_style.id = m_this._d3id();
	    m_style.data = data;
	    m_style.append = 'line';
	    m_style.attributes = {
	      x1: function (d, i) {
	        return cache[i].x1;
	      },
	      y1: function (d, i) {
	        return cache[i].y1;
	      },
	      x2: function (d, i) {
	        return cache[i].x1 + getScale() * cache[i].dx;
	      },
	      y2: function (d, i) {
	        return cache[i].y1 + getScale() * cache[i].dy;
	      },
	      'marker-start': function (d, i) {
	        return 'url(#' + markerID(d, i, 'tail') + ')';
	      },
	      'marker-end': function (d, i) {
	        return 'url(#' + markerID(d, i, 'head') + ')';
	      }
	    };
	    m_style.style = {
	      stroke: function () { return true; },
	      strokeColor: s_style.strokeColor,
	      strokeWidth: s_style.strokeWidth,
	      strokeOpacity: s_style.strokeOpacity,
	      originStyle: s_style.originStyle,
	      endStyle: s_style.endStyle
	    };
	    m_style.classes = ['d3VectorFeature'];

	    // Add markers to the defition list
	    updateMarkers(data, s_style.strokeColor, s_style.strokeOpacity, s_style.originStyle, s_style.endStyle);

	    // pass to renderer to draw
	    m_this.renderer()._drawFeatures(m_style);

	    // update time stamps
	    m_buildTime.modified();
	    m_this.updateTime().modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);

	    if (m_this.getMTime() >= m_buildTime.getMTime()) {
	      m_this._build();
	    } else {
	      updateMarkers(
	        m_style.data,
	        m_style.style.strokeColor,
	        m_style.style.strokeOpacity,
	        m_style.style.originStyle,
	        m_style.style.endStyle
	      );
	    }

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Exit
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    s_exit.call(m_this);
	    m_style = {};
	    updateMarkers([], null, null, null, null);
	  };

	  this._init(arg);
	  return this;
	};

	inherit(d3_vectorFeature, vectorFeature);

	// Now register it
	registerFeature('d3', 'vector', d3_vectorFeature);
	module.exports = d3_vectorFeature;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @namespace geo.gl
	 */
	module.exports = {
	  choroplethFeature: __webpack_require__(248),
	  contourFeature: __webpack_require__(249),
	  ellipsoid: __webpack_require__(251),
	  geomFeature: __webpack_require__(252),
	  lineFeature: __webpack_require__(253),
	  pointFeature: __webpack_require__(254),
	  polygonFeature: __webpack_require__(255),
	  quadFeature: __webpack_require__(257),
	  tileLayer: __webpack_require__(258),
	  vglRenderer: __webpack_require__(259)
	};


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var choroplethFeature = __webpack_require__(212);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of choroplethFeature
	 *
	 * @class geo.gl.choroplethFeature
	 * @extends geo.choroplethFeature
	 * @returns {geo.gl.choroplethFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_choroplethFeature = function (arg) {
	  'use strict';

	  if (!(this instanceof gl_choroplethFeature)) {
	    return new gl_choroplethFeature(arg);
	  }
	  arg = arg || {};
	  choroplethFeature.call(this, arg);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      m_gl_polygons = null,
	      s_exit = this._exit,
	      s_init = this._init,
	      s_draw = this.draw,
	      s_update = this._update;

	  /* Create the choropleth.  This calls the base class to generate the contours,
	   * into the various gl uniforms and buffers.
	   */
	  function createGLChoropleth() {
	    return m_this.createChoropleth();
	  }

	  this.draw = function () {
	    m_this._update();
	    if (m_gl_polygons) {
	      for (var idx = 0; idx < m_gl_polygons.length; idx += 1) {
	        m_gl_polygons[idx].draw();
	      }
	    }
	    s_draw();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    s_init.call(m_this, arg);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    m_this.buildTime().modified();
	    return (m_gl_polygons = createGLChoropleth());
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);
	    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||
	        m_this.updateTime().getMTime() <= m_this.getMTime()) {
	      m_this._wipePolygons();
	      m_this._build();
	    }
	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy Polygon Sub-Features
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._wipePolygons = function () {
	    if (m_gl_polygons) {
	      m_gl_polygons.map(function (polygon) {
	        return polygon._exit();
	      });
	    }
	    m_gl_polygons = null;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this._wipePolygons();
	    s_exit();
	  };

	  this._init(arg);
	  return this;
	};

	inherit(gl_choroplethFeature, choroplethFeature);

	// Now register it
	registerFeature('vgl', 'choropleth', gl_choroplethFeature);

	module.exports = gl_choroplethFeature;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var contourFeature = __webpack_require__(215);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of contourFeature
	 *
	 * @class geo.gl.contourFeature
	 * @extends geo.contourFeature
	 * @returns {geo.gl.contourFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_contourFeature = function (arg) {
	  'use strict';

	  if (!(this instanceof gl_contourFeature)) {
	    return new gl_contourFeature(arg);
	  }
	  arg = arg || {};
	  contourFeature.call(this, arg);

	  var vgl = __webpack_require__(81);
	  var transform = __webpack_require__(6);
	  var util = __webpack_require__(196);
	  var object = __webpack_require__(250);

	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_exit = this._exit,
	      m_textureUnit = 7,
	      m_actor = null,
	      m_mapper = null,
	      m_material = null,
	      m_texture = null,
	      m_minColorUniform = null,
	      m_maxColorUniform = null,
	      m_stepsUniform = null,
	      m_steppedUniform = null,
	      m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
	      s_init = this._init,
	      s_update = this._update;

	  function createVertexShader() {
	    var vertexShaderSource = [
	          '#ifdef GL_ES',
	          '  precision highp float;',
	          '#endif',
	          'attribute vec3 pos;',
	          'attribute float value;',
	          'attribute float opacity;',
	          'uniform mat4 modelViewMatrix;',
	          'uniform mat4 projectionMatrix;',
	          'varying float valueVar;',
	          'varying float opacityVar;',

	          'void main(void)',
	          '{',
	      /* Don't use z values; something is rotten in one of our matrices */
	          '  vec4 scrPos = projectionMatrix * modelViewMatrix * vec4(pos.xy, 0, 1);',
	          '  if (scrPos.w != 0.0) {',
	          '    scrPos = scrPos / scrPos.w;',
	          '  }',
	          '  valueVar = value;',
	          '  opacityVar = opacity;',
	          '  gl_Position = scrPos;',
	          '}'
	        ].join('\n'),
	        shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
	    shader.setShaderSource(vertexShaderSource);
	    return shader;
	  }

	  function createFragmentShader() {
	    var fragmentShaderSource = [
	          '#ifdef GL_ES',
	          '  precision highp float;',
	          '#endif',
	          'uniform vec4 minColor;',
	          'uniform vec4 maxColor;',
	          'uniform float steps;',
	          'uniform bool stepped;',
	          'uniform sampler2D sampler2d;',
	          'varying float valueVar;',
	          'varying float opacityVar;',
	          'void main () {',
	          '  vec4 clr;',
	          '  if (valueVar < 0.0) {',
	          '    clr = minColor;',
	          '  } else if (valueVar > steps) {',
	          '    clr = maxColor;',
	          '  } else {',
	          '    float step;',
	          '    if (stepped) {',
	          '      step = floor(valueVar) + 0.5;',
	          '      if (step > steps) {',
	          '        step = steps - 0.5;',
	          '      }',
	          '    } else {',
	          '      step = valueVar;',
	          '    }',
	          '    clr = texture2D(sampler2d, vec2(step / steps, 0.0));',
	          '  }',
	          '  gl_FragColor = vec4(clr.rgb, clr.a * opacityVar);',
	          '}'
	        ].join('\n'),
	        shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
	    shader.setShaderSource(fragmentShaderSource);
	    return shader;
	  }

	  /* Create the contours.  This calls the base class to generate the geometry,
	   * color map, and other parameters.  The generated geoemtry is then loaded
	   * into the various gl uniforms and buffers.
	   */
	  function createGLContours() {
	    var contour = m_this.createContours(),
	        numPts = contour.elements.length,
	        colorTable = [],
	        i, i3, j, j3,
	        posBuf, opacityBuf, valueBuf, indicesBuf,
	        geom = m_mapper.geometryData();

	    m_minColorUniform.set([contour.minColor.r, contour.minColor.g,
	                           contour.minColor.b, contour.minColor.a]);
	    m_maxColorUniform.set([contour.maxColor.r, contour.maxColor.g,
	                           contour.maxColor.b, contour.maxColor.a]);
	    m_stepsUniform.set(contour.colorMap.length);
	    m_steppedUniform.set(contour.stepped);
	    for (i = 0; i < contour.colorMap.length; i += 1) {
	      colorTable.push(contour.colorMap[i].r * 255);
	      colorTable.push(contour.colorMap[i].g * 255);
	      colorTable.push(contour.colorMap[i].b * 255);
	      colorTable.push(contour.colorMap[i].a * 255);
	    }
	    m_texture.setColorTable(colorTable);
	    contour.pos = transform.transformCoordinates(
	        m_this.gcs(), m_this.layer().map().gcs(), contour.pos, 3);
	    posBuf = util.getGeomBuffer(geom, 'pos', numPts * 3);
	    opacityBuf = util.getGeomBuffer(geom, 'opacity', numPts);
	    valueBuf = util.getGeomBuffer(geom, 'value', numPts);
	    for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
	      j = contour.elements[i];
	      j3 = j * 3;
	      posBuf[i3] = contour.pos[j3];
	      posBuf[i3 + 1] = contour.pos[j3 + 1];
	      posBuf[i3 + 2] = contour.pos[j3 + 2];
	      opacityBuf[i] = contour.opacity[j];
	      valueBuf[i] = contour.value[j];
	    }
	    indicesBuf = geom.primitive(0).indices();
	    if (!(indicesBuf instanceof Uint16Array) || indicesBuf.length !== numPts) {
	      indicesBuf = new Uint16Array(numPts);
	      geom.primitive(0).setIndices(indicesBuf);
	    }
	    geom.boundsDirty(true);
	    m_mapper.modified();
	    m_mapper.boundsDirtyTimestamp().modified();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    var blend = vgl.blend(),
	        prog = vgl.shaderProgram(),
	        mat = vgl.material(),
	        tex = vgl.lookupTable(),
	        geom = vgl.geometryData(),
	        modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	        projectionUniform = new vgl.projectionUniform('projectionMatrix'),
	        samplerUniform = new vgl.uniform(vgl.GL.INT, 'sampler2d'),
	        vertexShader = createVertexShader(),
	        fragmentShader = createFragmentShader(),
	        posAttr = vgl.vertexAttribute('pos'),
	        valueAttr = vgl.vertexAttribute('value'),
	        opacityAttr = vgl.vertexAttribute('opacity'),
	        sourcePositions = vgl.sourceDataP3fv({'name': 'pos'}),
	        sourceValues = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.One, {'name': 'value'}),
	        sourceOpacity = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Two, {'name': 'opacity'}),
	        primitive = new vgl.triangles();

	    s_init.call(m_this, arg);
	    m_mapper = vgl.mapper({dynamicDraw: m_dynamicDraw});

	    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
	    prog.addVertexAttribute(valueAttr, vgl.vertexAttributeKeysIndexed.One);
	    prog.addVertexAttribute(opacityAttr, vgl.vertexAttributeKeysIndexed.Two);

	    prog.addUniform(modelViewUniform);
	    prog.addUniform(projectionUniform);
	    m_minColorUniform = new vgl.uniform(vgl.GL.FLOAT_VEC4, 'minColor');
	    prog.addUniform(m_minColorUniform);
	    m_maxColorUniform = new vgl.uniform(vgl.GL.FLOAT_VEC4, 'maxColor');
	    prog.addUniform(m_maxColorUniform);
	    /* steps is always an integer, but it is more efficient if we use a float
	     */
	    m_stepsUniform = new vgl.uniform(vgl.GL.FLOAT, 'steps');
	    prog.addUniform(m_stepsUniform);
	    m_steppedUniform = new vgl.uniform(vgl.GL.BOOL, 'stepped');
	    prog.addUniform(m_steppedUniform);

	    prog.addShader(fragmentShader);
	    prog.addShader(vertexShader);

	    prog.addUniform(samplerUniform);
	    tex.setTextureUnit(m_textureUnit);
	    samplerUniform.set(m_textureUnit);

	    m_material = mat;
	    m_material.addAttribute(prog);
	    m_material.addAttribute(blend);
	    m_texture = tex;
	    m_material.addAttribute(m_texture);

	    m_actor = vgl.actor();
	    m_actor.setMaterial(m_material);
	    m_actor.setMapper(m_mapper);

	    geom.addSource(sourcePositions);
	    geom.addSource(sourceValues);
	    geom.addSource(sourceOpacity);
	    geom.addPrimitive(primitive);
	    m_mapper.setGeometryData(geom);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    if (m_actor) {
	      m_this.renderer().contextRenderer().removeActor(m_actor);
	    }

	    createGLContours();

	    m_this.renderer().contextRenderer().addActor(m_actor);
	    m_this.buildTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);

	    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||
	        m_this.updateTime().getMTime() <= m_this.getMTime()) {
	      m_this._build();
	    }

	    m_actor.setVisible(m_this.visible());
	    m_actor.material().setBinNumber(m_this.bin());
	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.renderer().contextRenderer().removeActor(m_actor);
	    s_exit();
	  };

	  this._init(arg);
	  return this;
	};

	inherit(gl_contourFeature, contourFeature);

	// Now register it
	registerFeature('vgl', 'contour', gl_contourFeature);

	module.exports = gl_contourFeature;


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * VGL specific subclass of object which rerenders when the object is drawn.
	 * @class geo.gl.object
	 * @extends geo.sceneObject
	 */
	//////////////////////////////////////////////////////////////////////////////

	var gl_object = function (arg) {
	  'use strict';

	  var object = __webpack_require__(80);

	  // this is used to extend other geojs classes, so only generate
	  // a new object when that is not the case... like if this === window
	  if (!(this instanceof object)) {
	    return new gl_object(arg);
	  }

	  var m_this = this,
	      s_draw = this.draw;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Redraw the object.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	    m_this._update({mayDelay: true});
	    m_this.renderer()._render();
	    s_draw();
	    return m_this;
	  };

	  return this;
	};

	module.exports = gl_object;



/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create an instance of quadratic surface generator
	 * in Cartesian coordinates by the equation
	 * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>. Used
	 * primarily to create planetary bodies
	 *
	 * @class geo.gl.ellipsoid
	 * @param {Number} [x=0]  Radius in X direction
	 * @param {Number} [y=0]  Radius in Y direction
	 * @param {Number} [z=0]  Radius in Z direction
	 *
	 * @returns {geo.gl.ellipsoid}
	 */
	 //////////////////////////////////////////////////////////////////////////////
	var ellipsoid = function (x, y, z) {
	  'use strict';
	  if (!(this instanceof ellipsoid)) {
	    return new ellipsoid(x, y, z);
	  }

	  var vgl = __webpack_require__(81);
	  var util = __webpack_require__(196);
	  var vec3 = __webpack_require__(133);

	  x = vgl.defaultValue(x, 0.0);
	  y = vgl.defaultValue(y, 0.0);
	  z = vgl.defaultValue(z, 0.0);

	  if (x < 0.0 || y < 0.0 || z < 0.0) {
	    return console.log('[error] Al radii components must be greater than zero');
	  }

	  var m_this = this,
	      m_radii = [x, y, z],
	      m_radiiSquared = [x * x, y * y, z * z],
	      m_minimumRadius = Math.min(x, y, z),
	      m_maximumRadius = Math.max(x, y, z);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return radii of ellipsoid
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.radii = function () {
	    return m_radii;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return squared radii of the ellipsoid
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.radiiSquared = function () {
	    return m_radiiSquared;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return maximum radius of the ellipsoid
	   *
	   * @return {Number} The maximum radius of the ellipsoid
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.maximumRadius = function () {
	    return m_maximumRadius;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return minimum radius of the ellipsoid
	   *
	   * @return {Number} The maximum radius of the ellipsoid
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.minimumRadius = function () {
	    return m_minimumRadius;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Computes the normal of the plane tangent to the surface of
	   * the ellipsoid at the provided position
	   *
	   * @param {Number} lat The cartographic latitude for which
	   *  to to determine the geodetic normal
	   * @param {Number} lon The cartographic longitude for which
	   *  to to determine the geodetic normal
	   *
	   * @return {vec3}
	   *
	   * @exception {DeveloperError} cartographic is required.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.computeGeodeticSurfaceNormal = function (lat, lon) {
	    if (typeof lat === 'undefined' || typeof lon === 'undefined') {
	      throw '[error] Valid latitude and longitude is required';
	    }

	    var cosLatitude = Math.cos(lat),
	        result = util.vec3AsArray();

	    result[0] = cosLatitude * Math.cos(lon);
	    result[1] = cosLatitude * Math.sin(lon);
	    result[2] = Math.sin(lat);

	    vec3.normalize(result, result);
	    return result;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Converts the provided geographic latitude, longitude,
	   * and height to WGS84 coordinate system
	   *
	   * @param {Number} lat Latitude in radians
	   * @param {Number} lon Longitude in radians
	   * @param {Number} elev Elevation
	   * @return {vec3} Position in the WGS84 coordinate system
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.transformPoint = function (lat, lon, elev) {
	    lat = lat * (Math.PI / 180.0);
	    lon = lon * (Math.PI / 180.0);

	    var n = m_this.computeGeodeticSurfaceNormal(lat, lon),
	        k = util.vec3AsArray(),
	        gamma = Math.sqrt(vec3.dot(n, k)),
	        result = util.vec3AsArray();

	    vec3.multiply(k, m_radiiSquared, n);
	    vec3.scale(k, k, 1 / gamma);
	    vec3.scale(n, n, elev);
	    vec3.add(result, n, k);
	    return result;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Converts the provided geographic latitude, longitude,
	   * and height to WGS84 coordinate system
	   *
	   * @param {vgl.geometryData} geom
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.transformGeometry = function (geom) {
	    if (!geom) {
	      throw '[error] Failed to transform to cartesian. Invalid geometry.';
	    }

	    var sourceData = geom.sourceData(vgl.vertexAttributeKeys.Position),
	        sourceDataArray = sourceData.data(),
	        noOfComponents = sourceData.attributeNumberOfComponents(
	          vgl.vertexAttributeKeys.Position),
	        stride = sourceData.attributeStride(
	          vgl.vertexAttributeKeys.Position),
	        offset = sourceData.attributeOffset(
	          vgl.vertexAttributeKeys.Position),
	        sizeOfDataType = sourceData.sizeOfAttributeDataType(
	          vgl.vertexAttributeKeys.Position),
	        index = null,
	        count = sourceDataArray.length * (1.0 / noOfComponents),
	        gamma = null,
	        n = null,
	        j = 0,
	        k = util.vec3AsArray(),
	        result = util.vec3AsArray();

	    stride /= sizeOfDataType;
	    offset /= sizeOfDataType;

	    if (noOfComponents !== 3) {
	      throw ('[error] Requires positions with three components');
	    }

	    for (j = 0; j < count; j += 1) {
	      index = j * stride + offset;

	      sourceDataArray[index] = sourceDataArray[index] * (Math.PI / 180.0);
	      sourceDataArray[index + 1] = sourceDataArray[index + 1] * (Math.PI / 180.0);

	      n = m_this.computeGeodeticSurfaceNormal(sourceDataArray[index + 1],
	                                            sourceDataArray[index]);
	      vec3.multiply(k, m_radiiSquared, n);
	      gamma = Math.sqrt(vec3.dot(n, k));
	      vec3.scale(k, k, 1 / gamma);
	      vec3.scale(n, n, sourceDataArray[index + 2]);
	      vec3.add(result, n, k);

	      sourceDataArray[index] = result[0];
	      sourceDataArray[index + 1] = result[1];
	      sourceDataArray[index + 2] = result[2];
	    }
	  };

	  return m_this;
	};

	module.exports = ellipsoid;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var geomFeature = __webpack_require__(220);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of geomFeature
	 *
	 * @class geo.gl.geomFeature
	 * @extends geo.geomFeature
	 * @param {vgl.geometryData} arg
	 * @returns {geo.gl.geomFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_geomFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof gl_geomFeature)) {
	    return new gl_geomFeature(arg);
	  }

	  var vgl = __webpack_require__(81);

	  arg = arg || {};
	  geomFeature.call(this, arg);
	  var object = __webpack_require__(250);

	  object.call(this);

	  // Initialize
	  var m_this = this,
	      m_geom = arg.geom || null,
	      m_actor = vgl.actor(),
	      m_mapper = vgl.mapper(),
	      m_material = null,
	      m_scalar = null,
	      m_color = arg.color || [1.0, 1.0, 1.0],
	      m_buildTime = null,
	      m_noOfPrimitives = 0;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var style = m_this.style();

	    // Vertex color gets the preference
	    if (m_geom !== null) {
	      m_scalar = m_geom.sourceData(vgl.vertexAttributeKeys.Scalar);
	      m_color = m_geom.sourceData(vgl.vertexAttributeKeys.Color);
	      m_mapper.setGeometryData(m_geom);
	    }

	    m_this.setMapper(m_mapper);

	    if (style.point_sprites !== undefined && style.point_sprites &&
	        style.point_sprites_image !== undefined &&
	        style.point_sprites_image !== null &&
	        m_noOfPrimitives === 1 &&
	        m_geom.primitive(0).primitiveType() === vgl.GL.POINTS) {
	      m_material = vgl.utils.createPointSpritesMaterial(
	                     style.point_sprites_image);
	    } else if (m_scalar) {
	      if (m_color instanceof vgl.lookupTable) {
	        m_color.updateRange(m_scalar.scalarRange());
	        m_material = vgl.utils.createColorMappedMaterial(m_color);
	      } else {
	        m_color = vgl.lookupTable();
	        m_color.updateRange(m_scalar.scalarRange());
	        m_material = vgl.utils.createColorMappedMaterial(m_color);
	      }
	    } else if (m_color) {
	      m_material = vgl.utils.createColorMaterial();
	    } else {
	      m_material = vgl.utils.createSolidColorMaterial();
	    }
	    m_actor.setMaterial(m_material);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @private
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    if (m_buildTime &&
	        m_buildTime.getMTime() < m_this.getMTime()) {
	      if (m_color instanceof vgl.lookupTable) {
	        vgl.utils.updateColorMappedMaterial(m_this.material(),
	          m_this.style.color);
	      }/* else {
	        // TODO
	      }*/
	    } else {
	      m_buildTime = vgl.timestamp();
	      m_buildTime.modified();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set geometry
	   *
	   * @returns {geo.gl.geomFeature}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.geometry = function (val) {
	    if (val === undefined) {
	      return m_geom;
	    } else {
	      m_geom = val;
	      m_this.modified();
	      return m_this;
	    }
	  };

	  return this;
	};

	inherit(gl_geomFeature, geomFeature);
	module.exports = gl_geomFeature;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var lineFeature = __webpack_require__(77);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of lineFeature
	 *
	 * @class geo.gl.lineFeature
	 * @extends geo.lineFeature
	 * @returns {geo.gl.lineFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_lineFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof gl_lineFeature)) {
	    return new gl_lineFeature(arg);
	  }
	  arg = arg || {};
	  lineFeature.call(this, arg);

	  var vgl = __webpack_require__(81);
	  var transform = __webpack_require__(6);
	  var util = __webpack_require__(196);
	  var object = __webpack_require__(250);

	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_exit = this._exit,
	      m_actor = null,
	      m_mapper = null,
	      m_material = null,
	      m_pixelWidthUnif = null,
	      m_aspectUniform = null,
	      m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
	      s_init = this._init,
	      s_update = this._update;

	  function createVertexShader() {
	    var vertexShaderSource = [
	          '#ifdef GL_ES',
	          '  precision highp float;',
	          '#endif',
	          'attribute vec3 pos;',
	          'attribute vec3 prev;',
	          'attribute vec3 next;',
	          'attribute float offset;',

	          'attribute vec3 strokeColor;',
	          'attribute float strokeOpacity;',
	          'attribute float strokeWidth;',

	          'uniform mat4 modelViewMatrix;',
	          'uniform mat4 projectionMatrix;',
	          'uniform float pixelWidth;',
	          'uniform float aspect;',

	          'varying vec4 strokeColorVar;',

	          'void main(void)',
	          '{',
	          /* If any vertex has been deliberately set to a negative opacity,
	           * skip doing computations on it. */
	          '  if (strokeOpacity < 0.0) {',
	          '    gl_Position = vec4(2, 2, 0, 1);',
	          '    return;',
	          '  }',
	          '  const float PI = 3.14159265358979323846264;',
	          '  vec4 worldPos = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1);',
	          '  if (worldPos.w != 0.0) {',
	          '    worldPos = worldPos/worldPos.w;',
	          '  }',
	          '  vec4 worldNext = projectionMatrix * modelViewMatrix * vec4(next.xyz, 1);',
	          '  if (worldNext.w != 0.0) {',
	          '    worldNext = worldNext/worldNext.w;',
	          '  }',
	          '  vec4 worldPrev = projectionMatrix* modelViewMatrix * vec4(prev.xyz, 1);',
	          '  if (worldPrev.w != 0.0) {',
	          '    worldPrev = worldPrev/worldPrev.w;',
	          '  }',
	          '  strokeColorVar = vec4(strokeColor, strokeOpacity);',
	          '  vec2 deltaNext = worldNext.xy - worldPos.xy;',
	          '  vec2 deltaPrev = worldPos.xy - worldPrev.xy;',
	          '  float angleNext = 0.0, anglePrev = 0.0;',
	          '  if (deltaNext.xy != vec2(0.0, 0.0))',
	          '    angleNext = atan(deltaNext.y / aspect, deltaNext.x);',
	          '  if (deltaPrev.xy == vec2(0.0, 0.0)) anglePrev = angleNext;',
	          '  else  anglePrev = atan(deltaPrev.y / aspect, deltaPrev.x);',
	          '  if (deltaNext.xy == vec2(0.0, 0.0)) angleNext = anglePrev;',
	          '  float angle = (anglePrev + angleNext) / 2.0;',
	          '  if (abs(anglePrev - angleNext) >= PI)',
	          '    angle += PI;',
	          '  float cosAngle = cos(anglePrev - angle);',
	          '  if (cosAngle < 0.1) { cosAngle = sign(cosAngle) * 1.0; angle = 0.0; }',
	          '  float distance = (offset * strokeWidth * pixelWidth) /',
	          '                    cosAngle;',
	          '  worldPos.x += distance * sin(angle);',
	          '  worldPos.y -= distance * cos(angle) * aspect;',
	          '  gl_Position = worldPos;',
	          '}'
	        ].join('\n'),
	        shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
	    shader.setShaderSource(vertexShaderSource);
	    return shader;
	  }

	  function createFragmentShader() {
	    var fragmentShaderSource = [
	          '#ifdef GL_ES',
	          '  precision highp float;',
	          '#endif',
	          'varying vec4 strokeColorVar;',
	          'void main () {',
	          '  gl_FragColor = strokeColorVar;',
	          '}'
	        ].join('\n'),
	        shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
	    shader.setShaderSource(fragmentShaderSource);
	    return shader;
	  }

	  function createGLLines() {
	    var data = m_this.data(),
	        i, j, k, v, lidx,
	        numSegments = 0, len,
	        lineItem, lineItemData,
	        vert = [{}, {}], vertTemp,
	        pos, posIdx3, firstpos, firstPosIdx3,
	        position = [],
	        posFunc = m_this.position(),
	        strkWidthFunc = m_this.style.get('strokeWidth'),
	        strkColorFunc = m_this.style.get('strokeColor'),
	        strkOpacityFunc = m_this.style.get('strokeOpacity'),
	        order = m_this.featureVertices(),
	        posBuf, nextBuf, prevBuf, offsetBuf, indicesBuf,
	        strokeWidthBuf, strokeColorBuf, strokeOpacityBuf,
	        dest, dest3,
	        geom = m_mapper.geometryData(),
	        closedFunc = m_this.style.get('closed'), closed = [];

	    for (i = 0; i < data.length; i += 1) {
	      lineItem = m_this.line()(data[i], i);
	      if (lineItem.length < 2) {
	        continue;
	      }
	      numSegments += lineItem.length - 1;
	      for (j = 0; j < lineItem.length; j += 1) {
	        pos = posFunc(lineItem[j], j, lineItem, i);
	        position.push(pos.x);
	        position.push(pos.y);
	        position.push(pos.z || 0.0);
	        if (!j) {
	          firstpos = pos;
	        }
	      }
	      if (lineItem.length > 2 && closedFunc(data[i], i)) {
	        /* line is closed */
	        if (pos.x !== firstpos.x || pos.y !== firstpos.y ||
	            pos.z !== firstpos.z) {
	          numSegments += 1;
	          closed[i] = 2;  /* first and last points are distinct */
	        } else {
	          closed[i] = 1;  /* first point is repeated as last point */
	        }
	      }
	    }

	    position = transform.transformCoordinates(
	                 m_this.gcs(), m_this.layer().map().gcs(),
	                 position, 3);

	    len = numSegments * order.length;
	    posBuf = util.getGeomBuffer(geom, 'pos', len * 3);
	    nextBuf = util.getGeomBuffer(geom, 'next', len * 3);
	    prevBuf = util.getGeomBuffer(geom, 'prev', len * 3);
	    offsetBuf = util.getGeomBuffer(geom, 'offset', len);
	    strokeWidthBuf = util.getGeomBuffer(geom, 'strokeWidth', len);
	    strokeColorBuf = util.getGeomBuffer(geom, 'strokeColor', len * 3);
	    strokeOpacityBuf = util.getGeomBuffer(geom, 'strokeOpacity', len);
	    indicesBuf = geom.primitive(0).indices();
	    if (!(indicesBuf instanceof Uint16Array) || indicesBuf.length !== len) {
	      indicesBuf = new Uint16Array(len);
	      geom.primitive(0).setIndices(indicesBuf);
	    }

	    for (i = posIdx3 = dest = dest3 = 0; i < data.length; i += 1) {
	      lineItem = m_this.line()(data[i], i);
	      if (lineItem.length < 2) {
	        continue;
	      }
	      firstPosIdx3 = posIdx3;
	      for (j = 0; j < lineItem.length + (closed[i] === 2 ? 1 : 0); j += 1, posIdx3 += 3) {
	        lidx = j;
	        if (j === lineItem.length) {
	          lidx = 0;
	          posIdx3 -= 3;
	        }
	        lineItemData = lineItem[lidx];
	        /* swap entries in vert so that vert[0] is the first vertex, and
	         * vert[1] will be reused for the second vertex */
	        if (j) {
	          vertTemp = vert[0];
	          vert[0] = vert[1];
	          vert[1] = vertTemp;
	        }
	        vert[1].pos = j === lidx ? posIdx3 : firstPosIdx3;
	        vert[1].prev = lidx ? posIdx3 - 3 : (closed[i] ?
	            firstPosIdx3 + (lineItem.length - 3 + closed[i]) * 3 : posIdx3);
	        vert[1].next = j + 1 < lineItem.length ? posIdx3 + 3 : (closed[i] ?
	            (j !== lidx ? firstPosIdx3 + 3 : firstPosIdx3 + 6 - closed[i] * 3) :
	            posIdx3);
	        vert[1].strokeWidth = strkWidthFunc(lineItemData, lidx, lineItem, i);
	        vert[1].strokeColor = strkColorFunc(lineItemData, lidx, lineItem, i);
	        vert[1].strokeOpacity = strkOpacityFunc(lineItemData, lidx, lineItem, i);
	        if (j) {
	          for (k = 0; k < order.length; k += 1, dest += 1, dest3 += 3) {
	            v = vert[order[k][0]];
	            posBuf[dest3] = position[v.pos];
	            posBuf[dest3 + 1] = position[v.pos + 1];
	            posBuf[dest3 + 2] = position[v.pos + 2];
	            prevBuf[dest3] = position[v.prev];
	            prevBuf[dest3 + 1] = position[v.prev + 1];
	            prevBuf[dest3 + 2] = position[v.prev + 2];
	            nextBuf[dest3] = position[v.next];
	            nextBuf[dest3 + 1] = position[v.next + 1];
	            nextBuf[dest3 + 2] = position[v.next + 2];
	            offsetBuf[dest] = order[k][1];
	            /* We can ignore the indices (they will all be zero) */
	            strokeWidthBuf[dest] = v.strokeWidth;
	            strokeColorBuf[dest3] = v.strokeColor.r;
	            strokeColorBuf[dest3 + 1] = v.strokeColor.g;
	            strokeColorBuf[dest3 + 2] = v.strokeColor.b;
	            strokeOpacityBuf[dest] = v.strokeOpacity;
	          }
	        }
	      }
	    }

	    geom.boundsDirty(true);
	    m_mapper.modified();
	    m_mapper.boundsDirtyTimestamp().modified();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the arrangement of vertices used for each line segment.
	   *
	   * @returns {Number}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.featureVertices = function () {
	    return [[0, 1], [1, -1], [0, -1], [0, 1], [1, 1], [1, -1]];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the number of vertices used for each line segment.
	   *
	   * @returns {Number}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.verticesPerFeature = function () {
	    return m_this.featureVertices().length;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    var prog = vgl.shaderProgram(),
	        vs = createVertexShader(),
	        fs = createFragmentShader(),
	        // Vertex attributes
	        posAttr = vgl.vertexAttribute('pos'),
	        prvAttr = vgl.vertexAttribute('prev'),
	        nxtAttr = vgl.vertexAttribute('next'),
	        offAttr = vgl.vertexAttribute('offset'),
	        strkWidthAttr = vgl.vertexAttribute('strokeWidth'),
	        strkColorAttr = vgl.vertexAttribute('strokeColor'),
	        strkOpacityAttr = vgl.vertexAttribute('strokeOpacity'),
	        // Shader uniforms
	        mviUnif = new vgl.modelViewUniform('modelViewMatrix'),
	        prjUnif = new vgl.projectionUniform('projectionMatrix'),
	        geom = vgl.geometryData(),
	        // Sources
	        posData = vgl.sourceDataP3fv({'name': 'pos'}),
	        prvPosData = vgl.sourceDataAnyfv(
	            3, vgl.vertexAttributeKeysIndexed.Four, {'name': 'prev'}),
	        nxtPosData = vgl.sourceDataAnyfv(
	            3, vgl.vertexAttributeKeysIndexed.Five, {'name': 'next'}),
	        offPosData = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Six, {'name': 'offset'}),
	        strkWidthData = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.One, {'name': 'strokeWidth'}),
	        strkColorData = vgl.sourceDataAnyfv(
	            3, vgl.vertexAttributeKeysIndexed.Two, {'name': 'strokeColor'}),
	        strkOpacityData = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Three,
	            {'name': 'strokeOpacity'}),
	        // Primitive indices
	        triangles = vgl.triangles();

	    m_pixelWidthUnif = new vgl.floatUniform('pixelWidth',
	                          1.0 / m_this.renderer().width());
	    m_aspectUniform = new vgl.floatUniform('aspect',
	        m_this.renderer().width() / m_this.renderer().height());

	    s_init.call(m_this, arg);
	    m_material = vgl.material();
	    m_mapper = vgl.mapper({dynamicDraw: m_dynamicDraw});

	    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
	    prog.addVertexAttribute(strkWidthAttr, vgl.vertexAttributeKeysIndexed.One);
	    prog.addVertexAttribute(strkColorAttr, vgl.vertexAttributeKeysIndexed.Two);
	    prog.addVertexAttribute(strkOpacityAttr, vgl.vertexAttributeKeysIndexed.Three);
	    prog.addVertexAttribute(prvAttr, vgl.vertexAttributeKeysIndexed.Four);
	    prog.addVertexAttribute(nxtAttr, vgl.vertexAttributeKeysIndexed.Five);
	    prog.addVertexAttribute(offAttr, vgl.vertexAttributeKeysIndexed.Six);

	    prog.addUniform(mviUnif);
	    prog.addUniform(prjUnif);
	    prog.addUniform(m_pixelWidthUnif);
	    prog.addUniform(m_aspectUniform);

	    prog.addShader(fs);
	    prog.addShader(vs);

	    m_material.addAttribute(prog);
	    m_material.addAttribute(vgl.blend());

	    m_actor = vgl.actor();
	    m_actor.setMaterial(m_material);
	    m_actor.setMapper(m_mapper);

	    geom.addSource(posData);
	    geom.addSource(prvPosData);
	    geom.addSource(nxtPosData);
	    geom.addSource(strkWidthData);
	    geom.addSource(strkColorData);
	    geom.addSource(strkOpacityData);
	    geom.addSource(offPosData);
	    geom.addPrimitive(triangles);
	    m_mapper.setGeometryData(geom);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return list of actors
	   *
	   * @returns {vgl.actor[]}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.actors = function () {
	    if (!m_actor) {
	      return [];
	    }
	    return [m_actor];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    if (m_actor) {
	      m_this.renderer().contextRenderer().removeActor(m_actor);
	    }

	    createGLLines();

	    m_this.renderer().contextRenderer().addActor(m_actor);
	    m_this.buildTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);

	    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||
	        m_this.updateTime().getMTime() <= m_this.getMTime()) {
	      m_this._build();
	    }

	    m_pixelWidthUnif.set(1.0 / m_this.renderer().width());
	    m_aspectUniform.set(m_this.renderer().width() /
	                        m_this.renderer().height());
	    m_actor.setVisible(m_this.visible());
	    m_actor.material().setBinNumber(m_this.bin());
	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.renderer().contextRenderer().removeActor(m_actor);
	    m_actor = null;
	    s_exit();
	  };

	  this._init(arg);
	  return this;
	};

	inherit(gl_lineFeature, lineFeature);

	// Now register it
	var capabilities = {};
	capabilities[lineFeature.capabilities.basic] = true;
	capabilities[lineFeature.capabilities.multicolor] = true;

	// Now register it
	registerFeature('vgl', 'line', gl_lineFeature, capabilities);

	module.exports = gl_lineFeature;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var pointFeature = __webpack_require__(203);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of pointFeature
	 *
	 * @class geo.gl.pointFeature
	 * @extends geo.pointFeature
	 * @returns {geo.gl.pointFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_pointFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof gl_pointFeature)) {
	    return new gl_pointFeature(arg);
	  }
	  arg = arg || {};
	  pointFeature.call(this, arg);

	  var vgl = __webpack_require__(81);
	  var transform = __webpack_require__(6);
	  var util = __webpack_require__(196);
	  var object = __webpack_require__(250);

	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_exit = this._exit,
	      m_actor = null,
	      m_mapper = null,
	      m_pixelWidthUniform = null,
	      m_aspectUniform = null,
	      m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
	      m_primitiveShape = 'sprite', // arg can change this, below
	      s_init = this._init,
	      s_update = this._update,
	      vertexShaderSource = null,
	      fragmentShaderSource = null;

	  if (arg.primitiveShape === 'triangle' ||
	      arg.primitiveShape === 'square' ||
	      arg.primitiveShape === 'sprite') {
	    m_primitiveShape = arg.primitiveShape;
	  }

	  vertexShaderSource = [
	    '#ifdef GL_ES',
	    '  precision highp float;',
	    '#endif',
	    'attribute vec3 pos;',
	    'attribute float rad;',
	    'attribute vec3 fillColor;',
	    'attribute vec3 strokeColor;',
	    'attribute float fillOpacity;',
	    'attribute float strokeWidth;',
	    'attribute float strokeOpacity;',
	    'attribute float fill;',
	    'attribute float stroke;',
	    'uniform float pixelWidth;',
	    'uniform float aspect;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'varying vec4 fillColorVar;',
	    'varying vec4 strokeColorVar;',
	    'varying float radiusVar;',
	    'varying float strokeWidthVar;',
	    'varying float fillVar;',
	    'varying float strokeVar;'
	  ];

	  if (m_primitiveShape !== 'sprite') {
	    vertexShaderSource = vertexShaderSource.concat([
	      'attribute vec2 unit;',
	      'varying vec3 unitVar;'
	    ]);
	  }

	  vertexShaderSource.push.apply(vertexShaderSource, [
	    'void main(void)',
	    '{',
	    '  strokeWidthVar = strokeWidth;',
	    '  // No stroke or fill implies nothing to draw',
	    '  if (stroke < 1.0 || strokeWidth <= 0.0 || strokeOpacity <= 0.0) {',
	    '    strokeVar = 0.0;',
	    '    strokeWidthVar = 0.0;',
	    '  }',
	    '  else',
	    '    strokeVar = 1.0;',
	    '  if (fill < 1.0 || rad <= 0.0 || fillOpacity <= 0.0)',
	    '    fillVar = 0.0;',
	    '  else',
	    '    fillVar = 1.0;',
	    /* If the point has no visible pixels, skip doing computations on it. */
	    '  if (fillVar == 0.0 && strokeVar == 0.0) {',
	    '    gl_Position = vec4(2, 2, 0, 1);',
	    '    return;',
	    '  }',
	    '  fillColorVar = vec4 (fillColor, fillOpacity);',
	    '  strokeColorVar = vec4 (strokeColor, strokeOpacity);',
	    '  radiusVar = rad;'
	  ]);

	  if (m_primitiveShape === 'sprite') {
	    vertexShaderSource.push.apply(vertexShaderSource, [
	      '  gl_Position = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;',
	      '  gl_PointSize = 2.0 * (rad + strokeWidthVar); ',
	      '}'
	    ]);
	  } else {
	    vertexShaderSource.push.apply(vertexShaderSource, [
	      '  unitVar = vec3 (unit, 1.0);',
	      '  vec4 p = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;',
	      '  if (p.w != 0.0) {',
	      '    p = p / p.w;',
	      '  }',
	      '  p += (rad + strokeWidthVar) * ',
	      '       vec4 (unit.x * pixelWidth, unit.y * pixelWidth * aspect, 0.0, 1.0);',
	      '  gl_Position = vec4(p.xyz, 1.0);',
	      '}'
	    ]);
	  }
	  vertexShaderSource = vertexShaderSource.join('\n');

	  fragmentShaderSource = [
	    '#ifdef GL_ES',
	    '  precision highp float;',
	    '#endif',
	    'uniform float aspect;',
	    'varying vec4 fillColorVar;',
	    'varying vec4 strokeColorVar;',
	    'varying float radiusVar;',
	    'varying float strokeWidthVar;',
	    'varying float fillVar;',
	    'varying float strokeVar;'
	  ];

	  if (m_primitiveShape !== 'sprite') {
	    fragmentShaderSource.push('varying vec3 unitVar;');
	  }

	  fragmentShaderSource.push.apply(fragmentShaderSource, [
	    'void main () {',
	    '  vec4 strokeColor, fillColor;',
	    '  float endStep;',
	    '  // No stroke or fill implies nothing to draw',
	    '  if (fillVar == 0.0 && strokeVar == 0.0)',
	    '    discard;'
	  ]);

	  if (m_primitiveShape === 'sprite') {
	    fragmentShaderSource.push(
	      '  float rad = 2.0 * length (gl_PointCoord - vec2(0.5));');
	  } else {
	    fragmentShaderSource.push(
	      '  float rad = length (unitVar.xy);');
	  }

	  fragmentShaderSource.push.apply(fragmentShaderSource, [
	    '  if (rad > 1.0)',
	    '    discard;',
	    '  // If there is no stroke, the fill region should transition to nothing',
	    '  if (strokeVar == 0.0) {',
	    '    strokeColor = vec4 (fillColorVar.rgb, 0.0);',
	    '    endStep = 1.0;',
	    '  } else {',
	    '    strokeColor = strokeColorVar;',
	    '    endStep = radiusVar / (radiusVar + strokeWidthVar);',
	    '  }',
	    '  // Likewise, if there is no fill, the stroke should transition to nothing',
	    '  if (fillVar == 0.0)',
	    '    fillColor = vec4 (strokeColor.rgb, 0.0);',
	    '  else',
	    '    fillColor = fillColorVar;',
	    '  // Distance to antialias over',
	    '  float antialiasDist = 3.0 / (2.0 * radiusVar);',
	    '  if (rad < endStep) {',
	    '    float step = smoothstep (endStep - antialiasDist, endStep, rad);',
	    '    gl_FragColor = mix (fillColor, strokeColor, step);',
	    '  } else {',
	    '    float step = smoothstep (1.0 - antialiasDist, 1.0, rad);',
	    '    gl_FragColor = mix (strokeColor, vec4 (strokeColor.rgb, 0.0), step);',
	    '  }',
	    '}'
	  ]);

	  fragmentShaderSource = fragmentShaderSource.join('\n');

	  function createVertexShader() {
	    var shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
	    shader.setShaderSource(vertexShaderSource);
	    return shader;
	  }

	  function createFragmentShader() {
	    var shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
	    shader.setShaderSource(fragmentShaderSource);
	    return shader;
	  }

	  function pointPolygon(x, y, w, h) {
	    var verts;
	    switch (m_primitiveShape) {
	      case 'triangle':
	        /* Use an equilateral triangle.  While this has 30% more area than a
	         * square, the reduction in vertices should help more than the
	         * processing the additional fragments. */
	        verts = [
	          x, y - h * 2,
	          x - w * Math.sqrt(3.0), y + h,
	          x + w * Math.sqrt(3.0), y + h
	        ];
	        break;
	      case 'sprite':
	        /* Point sprite uses only one vertex per point. */
	        verts = [x, y];
	        break;
	      default: // "square"
	        /* Use a surrounding square split diagonally into two triangles. */
	        verts = [
	          x - w, y + h,
	          x - w, y - h,
	          x + w, y + h,
	          x - w, y - h,
	          x + w, y - h,
	          x + w, y + h
	        ];
	        break;
	    }
	    return verts;
	  }

	  function createGLPoints() {
	    // unit and associated data is not used when drawing sprite
	    var i, j, numPts = m_this.data().length,
	        unit = pointPolygon(0, 0, 1, 1),
	        position = new Array(numPts * 3), posBuf, posVal, posFunc,
	        unitBuf, indices,
	        radius, radiusVal, radFunc,
	        stroke, strokeVal, strokeFunc,
	        strokeWidth, strokeWidthVal, strokeWidthFunc,
	        strokeOpacity, strokeOpacityVal, strokeOpacityFunc,
	        strokeColor, strokeColorVal, strokeColorFunc,
	        fill, fillVal, fillFunc,
	        fillOpacity, fillOpacityVal, fillOpacityFunc,
	        fillColor, fillColorVal, fillColorFunc,
	        vpf = m_this.verticesPerFeature(),
	        data = m_this.data(),
	        item, ivpf, ivpf3, iunit, i3,
	        geom = m_mapper.geometryData(), nonzeroZ;

	    posFunc = m_this.position();
	    radFunc = m_this.style.get('radius');
	    strokeFunc = m_this.style.get('stroke');
	    strokeWidthFunc = m_this.style.get('strokeWidth');
	    strokeOpacityFunc = m_this.style.get('strokeOpacity');
	    strokeColorFunc = m_this.style.get('strokeColor');
	    fillFunc = m_this.style.get('fill');
	    fillOpacityFunc = m_this.style.get('fillOpacity');
	    fillColorFunc = m_this.style.get('fillColor');

	    /* It is more efficient to do a transform on a single array rather than on
	     * an array of arrays or an array of objects. */
	    for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
	      posVal = posFunc(data[i]);
	      position[i3] = posVal.x;
	      position[i3 + 1] = posVal.y;
	      position[i3 + 2] = posVal.z || 0;
	      nonzeroZ = nonzeroZ || position[i3 + 2];
	    }
	    position = transform.transformCoordinates(
	                  m_this.gcs(), m_this.layer().map().gcs(),
	                  position, 3);
	    /* Some transforms modify the z-coordinate.  If we started with all zero z
	     * coordinates, don't modify them.  This could be changed if the
	     * z-coordinate space of the gl cube is scaled appropriately. */
	    if (!nonzeroZ && m_this.gcs() !== m_this.layer().map().gcs()) {
	      for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
	        position[i3 + 2] = 0;
	      }
	    }

	    posBuf = util.getGeomBuffer(geom, 'pos', vpf * numPts * 3);

	    if (m_primitiveShape !== 'sprite') {
	      unitBuf = util.getGeomBuffer(geom, 'unit', vpf * numPts * 2);
	    }

	    radius = util.getGeomBuffer(geom, 'rad', vpf * numPts);
	    stroke = util.getGeomBuffer(geom, 'stroke', vpf * numPts);
	    strokeWidth = util.getGeomBuffer(geom, 'strokeWidth', vpf * numPts);
	    strokeOpacity = util.getGeomBuffer(geom, 'strokeOpacity', vpf * numPts);
	    strokeColor = util.getGeomBuffer(geom, 'strokeColor', vpf * numPts * 3);
	    fill = util.getGeomBuffer(geom, 'fill', vpf * numPts);
	    fillOpacity = util.getGeomBuffer(geom, 'fillOpacity', vpf * numPts);
	    fillColor = util.getGeomBuffer(geom, 'fillColor', vpf * numPts * 3);
	    indices = geom.primitive(0).indices();
	    if (!(indices instanceof Uint16Array) || indices.length !== vpf * numPts) {
	      indices = new Uint16Array(vpf * numPts);
	      geom.primitive(0).setIndices(indices);
	    }

	    for (i = ivpf = ivpf3 = iunit = i3 = 0; i < numPts; i += 1, i3 += 3) {
	      item = data[i];
	      if (m_primitiveShape !== 'sprite') {
	        for (j = 0; j < unit.length; j += 1, iunit += 1) {
	          unitBuf[iunit] = unit[j];
	        }
	      }
	      /* We can ignore the indicies (they will all be zero) */
	      radiusVal = radFunc(item);
	      strokeVal = strokeFunc(item) ? 1.0 : 0.0;
	      strokeWidthVal = strokeWidthFunc(item);
	      strokeOpacityVal = strokeOpacityFunc(item);
	      strokeColorVal = strokeColorFunc(item);
	      fillVal = fillFunc(item) ? 1.0 : 0.0;
	      fillOpacityVal = fillOpacityFunc(item);
	      fillColorVal = fillColorFunc(item);
	      for (j = 0; j < vpf; j += 1, ivpf += 1, ivpf3 += 3) {
	        posBuf[ivpf3] = position[i3];
	        posBuf[ivpf3 + 1] = position[i3 + 1];
	        posBuf[ivpf3 + 2] = position[i3 + 2];
	        radius[ivpf] = radiusVal;
	        stroke[ivpf] = strokeVal;
	        strokeWidth[ivpf] = strokeWidthVal;
	        strokeOpacity[ivpf] = strokeOpacityVal;
	        strokeColor[ivpf3] = strokeColorVal.r;
	        strokeColor[ivpf3 + 1] = strokeColorVal.g;
	        strokeColor[ivpf3 + 2] = strokeColorVal.b;
	        fill[ivpf] = fillVal;
	        fillOpacity[ivpf] = fillOpacityVal;
	        fillColor[ivpf3] = fillColorVal.r;
	        fillColor[ivpf3 + 1] = fillColorVal.g;
	        fillColor[ivpf3 + 2] = fillColorVal.b;
	      }
	    }

	    geom.boundsDirty(true);
	    m_mapper.modified();
	    m_mapper.boundsDirtyTimestamp().modified();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return list of actors
	   *
	   * @returns {vgl.actor[]}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.actors = function () {
	    if (!m_actor) {
	      return [];
	    }
	    return [m_actor];
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the number of vertices used for each point.
	   *
	   * @returns {Number}
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.verticesPerFeature = function () {
	    var unit = pointPolygon(0, 0, 1, 1);
	    return unit.length / 2;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    var prog = vgl.shaderProgram(),
	        vertexShader = createVertexShader(),
	        fragmentShader = createFragmentShader(),
	        posAttr = vgl.vertexAttribute('pos'),
	        unitAttr = vgl.vertexAttribute('unit'),
	        radAttr = vgl.vertexAttribute('rad'),
	        strokeWidthAttr = vgl.vertexAttribute('strokeWidth'),
	        fillColorAttr = vgl.vertexAttribute('fillColor'),
	        fillAttr = vgl.vertexAttribute('fill'),
	        strokeColorAttr = vgl.vertexAttribute('strokeColor'),
	        strokeAttr = vgl.vertexAttribute('stroke'),
	        fillOpacityAttr = vgl.vertexAttribute('fillOpacity'),
	        strokeOpacityAttr = vgl.vertexAttribute('strokeOpacity'),
	        modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	        projectionUniform = new vgl.projectionUniform('projectionMatrix'),
	        mat = vgl.material(),
	        blend = vgl.blend(),
	        geom = vgl.geometryData(),
	        sourcePositions = vgl.sourceDataP3fv({'name': 'pos'}),
	        sourceUnits = vgl.sourceDataAnyfv(
	            2, vgl.vertexAttributeKeysIndexed.One, {'name': 'unit'}),
	        sourceRadius = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Two, {'name': 'rad'}),
	        sourceStrokeWidth = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Three, {'name': 'strokeWidth'}),
	        sourceFillColor = vgl.sourceDataAnyfv(
	            3, vgl.vertexAttributeKeysIndexed.Four, {'name': 'fillColor'}),
	        sourceFill = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Five, {'name': 'fill'}),
	        sourceStrokeColor = vgl.sourceDataAnyfv(
	            3, vgl.vertexAttributeKeysIndexed.Six, {'name': 'strokeColor'}),
	        sourceStroke = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Seven, {'name': 'stroke'}),
	        sourceAlpha = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Eight, {'name': 'fillOpacity'}),
	        sourceStrokeOpacity = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Nine, {'name': 'strokeOpacity'}),
	        primitive = new vgl.triangles();

	    if (m_primitiveShape === 'sprite') {
	      primitive = new vgl.points();
	    }

	    m_pixelWidthUniform = new vgl.floatUniform('pixelWidth',
	                            2.0 / m_this.renderer().width());
	    m_aspectUniform = new vgl.floatUniform('aspect',
	                        m_this.renderer().width() / m_this.renderer().height());

	    s_init.call(m_this, arg);
	    m_mapper = vgl.mapper({dynamicDraw: m_dynamicDraw});

	    // TODO: Right now this is ugly but we will fix it.
	    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
	    if (m_primitiveShape !== 'sprite') {
	      prog.addVertexAttribute(unitAttr, vgl.vertexAttributeKeysIndexed.One);
	    }

	    prog.addVertexAttribute(radAttr, vgl.vertexAttributeKeysIndexed.Two);
	    prog.addVertexAttribute(strokeWidthAttr, vgl.vertexAttributeKeysIndexed.Three);
	    prog.addVertexAttribute(fillColorAttr, vgl.vertexAttributeKeysIndexed.Four);
	    prog.addVertexAttribute(fillAttr, vgl.vertexAttributeKeysIndexed.Five);
	    prog.addVertexAttribute(strokeColorAttr, vgl.vertexAttributeKeysIndexed.Six);
	    prog.addVertexAttribute(strokeAttr, vgl.vertexAttributeKeysIndexed.Seven);
	    prog.addVertexAttribute(fillOpacityAttr, vgl.vertexAttributeKeysIndexed.Eight);
	    prog.addVertexAttribute(strokeOpacityAttr, vgl.vertexAttributeKeysIndexed.Nine);

	    prog.addUniform(m_pixelWidthUniform);
	    prog.addUniform(m_aspectUniform);
	    prog.addUniform(modelViewUniform);
	    prog.addUniform(projectionUniform);

	    prog.addShader(fragmentShader);
	    prog.addShader(vertexShader);

	    mat.addAttribute(prog);
	    mat.addAttribute(blend);

	    m_actor = vgl.actor();
	    m_actor.setMaterial(mat);
	    m_actor.setMapper(m_mapper);

	    geom.addSource(sourcePositions);
	    geom.addSource(sourceUnits);
	    geom.addSource(sourceRadius);
	    geom.addSource(sourceStrokeWidth);
	    geom.addSource(sourceFillColor);
	    geom.addSource(sourceFill);
	    geom.addSource(sourceStrokeColor);
	    geom.addSource(sourceStroke);
	    geom.addSource(sourceAlpha);
	    geom.addSource(sourceStrokeOpacity);
	    geom.addPrimitive(primitive);
	    m_mapper.setGeometryData(geom);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {

	    if (m_actor) {
	      m_this.renderer().contextRenderer().removeActor(m_actor);
	    }

	    createGLPoints();

	    m_this.renderer().contextRenderer().addActor(m_actor);
	    m_this.renderer().contextRenderer().render();
	    m_this.buildTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {

	    s_update.call(m_this);

	    // For now build if the data or style changes. In the future we may
	    // we able to partially update the data using dynamic gl buffers.
	    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||
	        m_this.updateTime().getMTime() < m_this.getMTime()) {
	      m_this._build();
	    }

	    // Update uniforms
	    m_pixelWidthUniform.set(2.0 / m_this.renderer().width());
	    m_aspectUniform.set(m_this.renderer().width() /
	                        m_this.renderer().height());

	    m_actor.setVisible(m_this.visible());
	    m_actor.material().setBinNumber(m_this.bin());

	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.renderer().contextRenderer().removeActor(m_actor);
	    s_exit();
	  };

	  m_this._init();
	  return this;
	};

	inherit(gl_pointFeature, pointFeature);

	// Now register it
	registerFeature('vgl', 'point', gl_pointFeature);

	module.exports = gl_pointFeature;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var polygonFeature = __webpack_require__(205);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of polygonFeature
	 *
	 * @class geo.gl.polygonFeature
	 * @extends geo.polygonFeature
	 * @returns {geo.gl.polygonFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_polygonFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof gl_polygonFeature)) {
	    return new gl_polygonFeature(arg);
	  }
	  arg = arg || {};
	  polygonFeature.call(this, arg);

	  var vgl = __webpack_require__(81);
	  var earcut = __webpack_require__(256);
	  var transform = __webpack_require__(6);
	  var util = __webpack_require__(196);
	  var object = __webpack_require__(250);

	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var m_this = this,
	      s_exit = this._exit,
	      m_actor = vgl.actor(),
	      m_mapper = vgl.mapper(),
	      m_material = vgl.material(),
	      m_geometry,
	      s_init = this._init,
	      s_update = this._update,
	      m_updateAnimFrameRef;

	  function createVertexShader() {
	    var vertexShaderSource = [
	          'attribute vec3 pos;',
	          'attribute vec3 fillColor;',
	          'attribute float fillOpacity;',
	          'uniform mat4 modelViewMatrix;',
	          'uniform mat4 projectionMatrix;',
	          'varying vec4 fillColorVar;',

	          'void main(void)',
	          '{',
	          '  vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1);',
	          '  if (clipPos.w != 0.0) {',
	          '    clipPos = clipPos/clipPos.w;',
	          '  }',
	          '  fillColorVar = vec4(fillColor, fillOpacity);',
	          '  gl_Position = clipPos;',
	          '}'
	        ].join('\n'),
	        shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
	    shader.setShaderSource(vertexShaderSource);
	    return shader;
	  }

	  function createFragmentShader() {
	    var fragmentShaderSource = [
	          '#ifdef GL_ES',
	          '  precision highp float;',
	          '#endif',
	          'varying vec4 fillColorVar;',
	          'void main () {',
	          '  gl_FragColor = fillColorVar;',
	          '}'
	        ].join('\n'),
	        shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
	    shader.setShaderSource(fragmentShaderSource);
	    return shader;
	  }

	  /**
	   * Create and style the triangles need to render the polygons.
	   *
	   * There are several optimizations to do less work when possible.  If only
	   * styles have changed, the triangulation is not recomputed, nor is the
	   * geometry re-transformed.  If styles use static values (rather than
	   * functions), they are only calculated once.  If a polygon reports that it
	   * has a uniform style, then styles are only calculated once for that polygon
	   * (the uniform property may be different per polygon or per update).
	   * Array.map is slower in Chrome that using a loop, so loops are used in
	   * places that would be conceptually served by maps.
	   *
	   * @memberof geo.gl.polygonFeature
	   * @param {boolean} onlyStyle if true, use the existing geoemtry and just
	   *    recalculate the style.
	   */
	  function createGLPolygons(onlyStyle) {
	    var posBuf, posFunc, polyFunc,
	        fillColor, fillColorFunc, fillColorVal,
	        fillOpacity, fillOpacityFunc, fillOpacityVal,
	        fillFunc, fillVal,
	        uniformPolyFunc, uniform,
	        indices,
	        items = [],
	        target_gcs = m_this.gcs(),
	        map_gcs = m_this.layer().map().gcs(),
	        numPts = 0,
	        geom = m_mapper.geometryData(),
	        color, opacity, fill, d, d3, vertices, i, j, k, n,
	        record, item, itemIndex, original;

	    fillColorFunc = m_this.style.get('fillColor');
	    fillColorVal = util.isFunction(m_this.style('fillColor')) ? undefined : fillColorFunc();
	    fillOpacityFunc = m_this.style.get('fillOpacity');
	    fillOpacityVal = util.isFunction(m_this.style('fillOpacity')) ? undefined : fillOpacityFunc();
	    fillFunc = m_this.style.get('fill');
	    fillVal = util.isFunction(m_this.style('fill')) ? undefined : fillFunc();
	    uniformPolyFunc = m_this.style.get('uniformPolygon');

	    if (!onlyStyle) {
	      posFunc = m_this.style.get('position');
	      polyFunc = m_this.style.get('polygon');
	      m_this.data().forEach(function (item, itemIndex) {
	        var polygon, outer, geometry, c;

	        polygon = polyFunc(item, itemIndex);
	        if (!polygon) {
	          return;
	        }
	        outer = polygon.outer || (polygon instanceof Array ? polygon : []);

	        /* expand to an earcut polygon geometry.  We had been using a map call,
	         * but using loops is much faster in Chrome (4 versus 33 ms for one
	         * test). */
	        geometry = new Array(outer.length * 3);
	        for (i = d3 = 0; i < outer.length; i += 1, d3 += 3) {
	          c = posFunc(outer[i], i, item, itemIndex);
	          geometry[d3] = c.x;
	          geometry[d3 + 1] = c.y;
	          geometry[d3 + 2] = c.z || 0;
	        }
	        geometry = {vertices: geometry, dimensions: 3, holes: []};
	        original = outer;

	        if (polygon.inner) {
	          polygon.inner.forEach(function (hole) {
	            original = original.concat(hole);
	            geometry.holes.push(d3 / 3);
	            for (i = 0; i < hole.length; i += 1, d3 += 3) {
	              c = posFunc(hole[i], i, item, itemIndex);
	              geometry.vertices[d3] = c.x;
	              geometry.vertices[d3 + 1] = c.y;
	              geometry.vertices[d3 + 2] = c.z || 0;
	            }
	          });
	        }

	        // tranform to map gcs
	        geometry.vertices = transform.transformCoordinates(
	          target_gcs,
	          map_gcs,
	          geometry.vertices,
	          geometry.dimensions
	        );

	        record = {
	          // triangulate
	          triangles: earcut(geometry.vertices, geometry.holes, geometry.dimensions),
	          vertices: geometry.vertices,
	          original: original,
	          item: item,
	          itemIndex: itemIndex
	        };
	        if (record.triangles.length) {
	          items.push(record);
	          numPts += record.triangles.length;
	        }
	      });
	      posBuf = util.getGeomBuffer(geom, 'pos', numPts * 3);
	      indices = geom.primitive(0).indices();
	      if (!(indices instanceof Uint16Array) || indices.length !== numPts) {
	        indices = new Uint16Array(numPts);
	        geom.primitive(0).setIndices(indices);
	      }
	      m_geometry = {items: items, numPts: numPts};
	    } else {
	      items = m_geometry.items;
	      numPts = m_geometry.numPts;
	    }
	    fillColor = util.getGeomBuffer(geom, 'fillColor', numPts * 3);
	    fillOpacity = util.getGeomBuffer(geom, 'fillOpacity', numPts);
	    d = d3 = 0;
	    color = fillColorVal;
	    opacity = fillOpacityVal;
	    fill = fillVal;
	    for (k = 0; k < items.length; k += 1) {
	      n = items[k].triangles.length;
	      vertices = items[k].vertices;
	      item = items[k].item;
	      itemIndex = items[k].itemIndex;
	      original = items[k].original;
	      uniform = uniformPolyFunc(item, itemIndex);
	      if (uniform) {
	        if (fillColorVal === undefined) {
	          color = fillColorFunc(vertices[0], 0, item, itemIndex);
	        }
	        if (fillOpacityVal === undefined) {
	          opacity = fillOpacityFunc(vertices[0], 0, item, itemIndex);
	        }
	      }
	      if (fillVal === undefined) {
	        fill = fillFunc(item, itemIndex);
	      }
	      if (!fill) {
	        opacity = 0;
	      }
	      if (uniform && onlyStyle && items[k].uniform && items[k].color &&
	          color.r === items[k].color.r && color.g === items[k].color.g &&
	          color.b === items[k].color.b && opacity === items[k].opacity) {
	        d += n;
	        d3 += n * 3;
	        continue;
	      }
	      for (i = 0; i < n; i += 1, d += 1, d3 += 3) {
	        if (onlyStyle && uniform) {
	          fillColor[d3] = color.r;
	          fillColor[d3 + 1] = color.g;
	          fillColor[d3 + 2] = color.b;
	          fillOpacity[d] = opacity;
	        } else {
	          j = items[k].triangles[i] * 3;
	          if (!onlyStyle) {
	            posBuf[d3] = vertices[j];
	            posBuf[d3 + 1] = vertices[j + 1];
	            posBuf[d3 + 2] = vertices[j + 2];
	            indices[d] = i;
	          }
	          if (!uniform && fillColorVal === undefined) {
	            color = fillColorFunc(original[j], j, item, itemIndex);
	          }
	          fillColor[d3] = color.r;
	          fillColor[d3 + 1] = color.g;
	          fillColor[d3 + 2] = color.b;
	          if (!uniform && fillOpacityVal === undefined) {
	            opacity = fillOpacityFunc(original[j], j, item, itemIndex);
	          }
	          fillOpacity[d] = opacity;
	        }
	      }
	      if (uniform || items[k].uniform) {
	        items[k].uniform = uniform;
	        items[k].color = color;
	        items[k].opacity = opacity;
	      }
	    }
	    m_mapper.modified();
	    if (!onlyStyle) {
	      geom.boundsDirty(true);
	      m_mapper.boundsDirtyTimestamp().modified();
	    }
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   * @memberof geo.gl.polygonFeature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function (arg) {
	    var prog = vgl.shaderProgram(),
	        posAttr = vgl.vertexAttribute('pos'),
	        fillColorAttr = vgl.vertexAttribute('fillColor'),
	        fillOpacityAttr = vgl.vertexAttribute('fillOpacity'),
	        modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),
	        projectionUniform = new vgl.projectionUniform('projectionMatrix'),
	        vertexShader = createVertexShader(),
	        fragmentShader = createFragmentShader(),
	        blend = vgl.blend(),
	        geom = vgl.geometryData(),
	        sourcePositions = vgl.sourceDataP3fv({'name': 'pos'}),
	        sourceFillColor = vgl.sourceDataAnyfv(
	            3, vgl.vertexAttributeKeysIndexed.Two, {'name': 'fillColor'}),
	        sourceFillOpacity = vgl.sourceDataAnyfv(
	            1, vgl.vertexAttributeKeysIndexed.Three, {'name': 'fillOpacity'}),
	        trianglePrimitive = vgl.triangles();

	    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
	    prog.addVertexAttribute(fillColorAttr, vgl.vertexAttributeKeysIndexed.Two);
	    prog.addVertexAttribute(fillOpacityAttr, vgl.vertexAttributeKeysIndexed.Three);

	    prog.addUniform(modelViewUniform);
	    prog.addUniform(projectionUniform);

	    prog.addShader(fragmentShader);
	    prog.addShader(vertexShader);

	    m_material.addAttribute(prog);
	    m_material.addAttribute(blend);

	    m_actor.setMaterial(m_material);
	    m_actor.setMapper(m_mapper);

	    geom.addSource(sourcePositions);
	    geom.addSource(sourceFillColor);
	    geom.addSource(sourceFillOpacity);
	    geom.addPrimitive(trianglePrimitive);
	    m_mapper.setGeometryData(geom);

	    s_init.call(m_this, arg);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build
	   *
	   * @memberof geo.gl.polygonFeature
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {

	    createGLPolygons(m_this.dataTime().getMTime() < m_this.buildTime().getMTime() && m_geometry);

	    if (!m_this.renderer().contextRenderer().hasActor(m_actor)) {
	      m_this.renderer().contextRenderer().addActor(m_actor);
	    }
	    m_this.buildTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   *
	   * @memberof geo.gl.polygonFeature
	   * @override
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function (opts) {
	    if (opts && opts.mayDelay) {
	      m_updateAnimFrameRef = window.requestAnimationFrame(this._update);
	      return;
	    }
	    if (m_updateAnimFrameRef) {
	      window.cancelAnimationFrame(m_updateAnimFrameRef);
	      m_updateAnimFrameRef = null;
	    }
	    s_update.call(m_this);

	    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||
	        m_this.updateTime().getMTime() <= m_this.getMTime()) {
	      m_this._build();
	    }

	    m_actor.setVisible(m_this.visible());
	    m_actor.material().setBinNumber(m_this.bin());
	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   * @memberof geo.gl.polygonFeature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.renderer().contextRenderer().removeActor(m_actor);
	    s_exit();
	  };

	  this._init(arg);
	  return this;
	};

	inherit(gl_polygonFeature, polygonFeature);

	// Now register it
	registerFeature('vgl', 'polygon', gl_polygonFeature);
	module.exports = gl_polygonFeature;


/***/ },
/* 256 */
/***/ function(module, exports) {

	'use strict';

	module.exports = earcut;

	function earcut(data, holeIndices, dim) {

	    dim = dim || 2;

	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];

	    if (!outerNode) return triangles;

	    var minX, minY, maxX, maxY, x, y, size;

	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];

	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }

	        // minX, minY and size are later used to transform coords into integers for z-order calculation
	        size = Math.max(maxX - minX, maxY - minY);
	    }

	    earcutLinked(outerNode, triangles, dim, minX, minY, size);

	    return triangles;
	}

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;

	    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
	        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	    } else {
	        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	    }

	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }

	    return last;
	}

	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;

	    var p = start,
	        again;
	    do {
	        again = false;

	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) return null;
	            again = true;

	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);

	    return end;
	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
	    if (!ear) return;

	    // interlink polygon nodes in z-order
	    if (!pass && size) indexCurve(ear, minX, minY, size);

	    var stop = ear,
	        prev, next;

	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;

	        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
	            // cut off the triangle
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);

	            removeNode(ear);

	            // skipping the next vertice leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;

	            continue;
	        }

	        ear = next;

	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

	            // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(ear, triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

	            // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, size);
	            }

	            break;
	        }
	    }
	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // now make sure we don't have other points inside the potential ear
	    var p = ear.next.next;

	    while (p !== ear.prev) {
	        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }

	    return true;
	}

	function isEarHashed(ear, minX, minY, size) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;

	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

	    // triangle bbox; min & max are calculated like this for speed
	    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
	        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
	        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
	        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

	    // z-order range for the current triangle bbox;
	    var minZ = zOrder(minTX, minTY, minX, minY, size),
	        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

	    // first look for points inside the triangle in increasing z-order
	    var p = ear.nextZ;

	    while (p && p.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.nextZ;
	    }

	    // then look for points in decreasing z-order
	    p = ear.prevZ;

	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }

	    return true;
	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;

	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);

	            // remove two nodes involved
	            removeNode(p);
	            removeNode(p.next);

	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);

	    return p;
	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, size) {
	    // look for a valid diagonal that divides the polygon into two
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                // split the polygon in two by the diagonal
	                var c = splitPolygon(a, b);

	                // filter colinear points around the cuts
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);

	                // run earcut on each half
	                earcutLinked(a, triangles, dim, minX, minY, size);
	                earcutLinked(c, triangles, dim, minX, minY, size);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i, len, start, end, list;

	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }

	    queue.sort(compareX);

	    // process holes from left to right
	    for (i = 0; i < queue.length; i++) {
	        eliminateHole(queue[i], outerNode);
	        outerNode = filterPoints(outerNode, outerNode.next);
	    }

	    return outerNode;
	}

	function compareX(a, b) {
	    return a.x - b.x;
	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole(hole, outerNode) {
	    outerNode = findHoleBridge(hole, outerNode);
	    if (outerNode) {
	        var b = splitPolygon(outerNode, hole);
	        filterPoints(b, b.next);
	    }
	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;

	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) return p;
	                    if (hy === p.next.y) return p.next;
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);

	    if (!m) return null;

	    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point

	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;

	    p = m.next;

	    while (p !== stop) {
	        if (hx >= p.x && p.x >= mx &&
	                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

	            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

	            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
	                m = p;
	                tanMin = tan;
	            }
	        }

	        p = p.next;
	    }

	    return m;
	}

	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, size) {
	    var p = start;
	    do {
	        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);

	    p.prevZ.nextZ = null;
	    p.prevZ = null;

	    sortLinked(p);
	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize,
	        inSize = 1;

	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;

	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }

	            qSize = inSize;

	            while (pSize > 0 || (qSize > 0 && q)) {

	                if (pSize === 0) {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                } else if (qSize === 0 || !q) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else if (p.z <= q.z) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }

	                if (tail) tail.nextZ = e;
	                else list = e;

	                e.prevZ = tail;
	                tail = e;
	            }

	            p = q;
	        }

	        tail.nextZ = null;
	        inSize *= 2;

	    } while (numMerges > 1);

	    return list;
	}

	// z-order of a point given coords and size of the data bounding box
	function zOrder(x, y, minX, minY, size) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = 32767 * (x - minX) / size;
	    y = 32767 * (y - minY) / size;

	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;

	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;

	    return x | (y << 1);
	}

	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x) leftmost = p;
	        p = p.next;
	    } while (p !== start);

	    return leftmost;
	}

	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
	           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
	           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
	           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}

	// signed area of a triangle
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	// check if two points are equal
	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}

	// check if two segments intersect
	function intersects(p1, q1, p2, q2) {
	    if ((equals(p1, q1) && equals(p2, q2)) ||
	        (equals(p1, q2) && equals(p2, q1))) return true;
	    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
	           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);

	    return false;
	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ?
	        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
	        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);

	    return inside;
	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
	    var a2 = new Node(a.i, a.x, a.y),
	        b2 = new Node(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;

	    a.next = b;
	    b.prev = a;

	    a2.next = an;
	    an.prev = a2;

	    b2.next = a2;
	    a2.prev = b2;

	    bp.next = b2;
	    b2.prev = bp;

	    return b2;
	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode(i, x, y, last) {
	    var p = new Node(i, x, y);

	    if (!last) {
	        p.prev = p;
	        p.next = p;

	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}

	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;

	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
	    // vertice index in coordinates array
	    this.i = i;

	    // vertex coordinates
	    this.x = x;
	    this.y = y;

	    // previous and next vertice nodes in a polygon ring
	    this.prev = null;
	    this.next = null;

	    // z-order curve value
	    this.z = null;

	    // previous and next nodes in z-order
	    this.prevZ = null;
	    this.nextZ = null;

	    // indicates whether this is a steiner point
	    this.steiner = false;
	}

	// return a percentage difference between the polygon area and its triangulation area;
	// used to verify correctness of triangulation
	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }

	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs(
	            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
	            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }

	    return polygonArea === 0 && trianglesArea === 0 ? 0 :
	        Math.abs((trianglesArea - polygonArea) / polygonArea);
	};

	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}

	// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
	earcut.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = {vertices: [], holes: [], dimensions: dim},
	        holeIndex = 0;

	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var quadFeature = __webpack_require__(211);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class quadFeature
	 *
	 * @class geo.gl.quadFeature
	 * @param {Object} arg Options object
	 * @extends geo.quadFeature
	 * @returns {geo.gl.quadFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var gl_quadFeature = function (arg) {
	  'use strict';
	  if (!(this instanceof gl_quadFeature)) {
	    return new gl_quadFeature(arg);
	  }
	  quadFeature.call(this, arg);

	  var $ = __webpack_require__(1);
	  var vgl = __webpack_require__(81);
	  var object = __webpack_require__(250);

	  object.call(this);

	  var m_this = this,
	      s_exit = this._exit,
	      s_init = this._init,
	      s_update = this._update,
	      m_modelViewUniform,
	      m_actor_image, m_actor_color, m_glBuffers = {}, m_imgposbuf,
	      m_clrposbuf, m_clrModelViewUniform,
	      m_glCompileTimestamp = vgl.timestamp(),
	      m_glColorCompileTimestamp = vgl.timestamp(),
	      m_quads;
	  var fragmentShaderImageSource = [
	    'varying highp vec2 iTextureCoord;',
	    'uniform sampler2D sampler2d;',
	    'uniform mediump float opacity;',
	    'uniform highp vec2 crop;',
	    'void main(void) {',
	    '  mediump vec4 color = texture2D(sampler2d, iTextureCoord);',
	    '  if (iTextureCoord.s > crop.s || 1.0 - iTextureCoord.t > crop.t) {',
	    '    discard;',
	    '  }',
	    '  color.w *= opacity;',
	    '  gl_FragColor = color;',
	    '}'].join('\n');
	  var vertexShaderImageSource = [
	    'attribute vec3 vertexPosition;',
	    'attribute vec2 textureCoord;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'varying highp vec2 iTextureCoord;',
	    'void main(void) {',
	    '  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    '  iTextureCoord = textureCoord;',
	    '}'].join('\n');
	  var vertexShaderColorSource = [
	    'attribute vec3 vertexPosition;',
	    'uniform vec3 vertexColor;',
	    'uniform mat4 modelViewMatrix;',
	    'uniform mat4 projectionMatrix;',
	    'varying mediump vec3 iVertexColor;',
	    'void main(void) {',
	    '  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);',
	    '  iVertexColor = vertexColor;',
	    '}'].join('\n');

	  /**
	   * Allocate buffers that we need to control for image quads.  This mimics
	   * the actions from vgl.mapper to some degree.
	   *
	   * @private
	   */
	  function setupDrawObjects(renderState) {
	    var context = renderState.m_context,
	        newbuf = false;

	    if (m_quads.imgQuads.length) {
	      if (!m_imgposbuf || m_imgposbuf.length < m_quads.imgQuads.length * 12 ||
	          !m_glBuffers.imgQuadsPosition) {
	        if (m_glBuffers.imgQuadsPosition) {
	          context.deleteBuffer(m_glBuffers.imgQuadsPosition);
	        }
	        m_glBuffers.imgQuadsPosition = context.createBuffer();
	        m_imgposbuf = new Float32Array(Math.max(
	            128, m_quads.imgQuads.length * 2) * 12);
	        newbuf = true;
	      }
	      $.each(m_quads.imgQuads, function (idx, quad) {
	        for (var i = 0; i < 12; i += 1) {
	          m_imgposbuf[idx * 12 + i] = quad.pos[i] - m_quads.origin[i % 3];
	        }
	      });
	      context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_glBuffers.imgQuadsPosition);
	      if (newbuf) {
	        context.bufferData(vgl.GL.ARRAY_BUFFER, m_imgposbuf, vgl.GL.DYNAMIC_DRAW);
	      } else {
	        context.bufferSubData(vgl.GL.ARRAY_BUFFER, 0, m_imgposbuf);
	      }
	    }
	    m_glCompileTimestamp.modified();
	  }

	  /**
	   * Allocate buffers that we need to control for color quads.  This mimics
	   * the actions from vgl.mapper to some degree.
	   *
	   * @private
	   */
	  function setupColorDrawObjects(renderState) {
	    var context = renderState.m_context,
	        newbuf = false;

	    if (m_quads.clrQuads.length) {
	      if (!m_clrposbuf || m_clrposbuf.length < m_quads.clrQuads.length * 12 ||
	          !m_glBuffers.clrQuadsPosition) {
	        if (m_glBuffers.imgQuadsPosition) {
	          context.deleteBuffer(m_glBuffers.clrQuadsPosition);
	        }
	        m_glBuffers.clrQuadsPosition = context.createBuffer();
	        m_clrposbuf = new Float32Array(Math.max(
	            128, m_quads.clrQuads.length * 2) * 12);
	        newbuf = true;
	      }
	      $.each(m_quads.clrQuads, function (idx, quad) {
	        for (var i = 0; i < 12; i += 1) {
	          m_clrposbuf[idx * 12 + i] = quad.pos[i] - m_quads.origin[i % 3];
	        }
	      });
	      context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_glBuffers.clrQuadsPosition);
	      if (newbuf) {
	        context.bufferData(vgl.GL.ARRAY_BUFFER, m_clrposbuf, vgl.GL.DYNAMIC_DRAW);
	      } else {
	        context.bufferSubData(vgl.GL.ARRAY_BUFFER, 0, m_clrposbuf);
	      }
	    }
	    m_glColorCompileTimestamp.modified();
	  }

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build this feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    var mapper, mat, prog, srctex, unicrop, geom;

	    if (!m_this.position()) {
	      return;
	    }
	    m_quads = this._generateQuads();
	    /* Create an actor to render image quads */
	    if (m_quads.imgQuads.length && !m_actor_image) {
	      m_this.visible(false);
	      mapper = new vgl.mapper({dynamicDraw: true});
	      m_actor_image = new vgl.actor();
	      /* This is similar to vgl.utils.createTextureMaterial */
	      m_actor_image.setMapper(mapper);
	      mat = new vgl.material();
	      prog = new vgl.shaderProgram();
	      prog.addVertexAttribute(new vgl.vertexAttribute('vertexPosition'),
	                              vgl.vertexAttributeKeys.Position);
	      prog.addVertexAttribute(new vgl.vertexAttribute('textureCoord'),
	                              vgl.vertexAttributeKeys.TextureCoordinate);
	      m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix',
	        m_quads.origin);
	      prog.addUniform(m_modelViewUniform);
	      prog.addUniform(new vgl.projectionUniform('projectionMatrix'));
	      prog.addUniform(new vgl.floatUniform('opacity', 1.0));
	      unicrop = new vgl.uniform(vgl.GL.FLOAT_VEC2, 'crop');
	      unicrop.set([1.0, 1.0]);
	      prog.addUniform(unicrop);
	      prog.addShader(vgl.getCachedShader(
	          vgl.GL.VERTEX_SHADER, vgl.GL, vertexShaderImageSource));
	      prog.addShader(vgl.getCachedShader(
	          vgl.GL.FRAGMENT_SHADER, vgl.GL, fragmentShaderImageSource));
	      mat.addAttribute(prog);
	      mat.addAttribute(new vgl.blend());
	      /* This is similar to vgl.planeSource */
	      geom = new vgl.geometryData();
	      m_imgposbuf = undefined;
	      srctex = new vgl.sourceDataT2fv();
	      srctex.pushBack([0, 0, 1, 0, 0, 1, 1, 1]);
	      geom.addSource(srctex);
	      /* We deliberately do not add a primitive to our geometry -- we take care
	       * of that ourselves. */

	      mapper.setGeometryData(geom);
	      m_actor_image.setMaterial(mat);

	      mapper.s_render = mapper.render;
	      mapper.render = m_this._renderImageQuads;
	      m_this.renderer().contextRenderer().addActor(m_actor_image);
	      m_this.visible(true);
	    }
	    /* Create an actor to render color quads */
	    if (m_quads.clrQuads.length && !m_actor_color) {
	      m_this.visible(false);
	      mapper = new vgl.mapper({dynamicDraw: true});
	      m_actor_color = new vgl.actor();
	      /* This is similar to vgl.utils.createTextureMaterial */
	      m_actor_color.setMapper(mapper);
	      mat = new vgl.material();
	      prog = new vgl.shaderProgram();
	      prog.addVertexAttribute(new vgl.vertexAttribute('vertexPosition'),
	                              vgl.vertexAttributeKeys.Position);
	      m_clrModelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix',
	        m_quads.origin);
	      prog.addUniform(m_clrModelViewUniform);
	      prog.addUniform(new vgl.projectionUniform('projectionMatrix'));
	      prog.addUniform(new vgl.floatUniform('opacity', 1.0));
	      prog.addUniform(new vgl.uniform(vgl.GL.FLOAT_VEC3, 'vertexColor'));
	      prog.addShader(vgl.getCachedShader(
	          vgl.GL.VERTEX_SHADER, vgl.GL, vertexShaderColorSource));
	      prog.addShader(vgl.utils.createFragmentShader(vgl.GL));
	      mat.addAttribute(prog);
	      mat.addAttribute(new vgl.blend());
	      /* This is similar to vgl.planeSource */
	      geom = new vgl.geometryData();
	      m_clrposbuf = undefined;
	      /* We deliberately do not add a primitive to our geometry -- we take care
	       * of that ourselves. */

	      mapper.setGeometryData(geom);
	      m_actor_color.setMaterial(mat);

	      mapper.s_render = mapper.render;
	      mapper.render = m_this._renderColorQuads;
	      m_this.renderer().contextRenderer().addActor(m_actor_color);
	      m_this.visible(true);
	    }
	    if (m_modelViewUniform) {
	      m_modelViewUniform.setOrigin(m_quads.origin);
	    }
	    if (m_clrModelViewUniform) {
	      m_clrModelViewUniform.setOrigin(m_quads.origin);
	    }
	    m_this.buildTime().modified();
	  };

	  /**
	   * Check all of the image quads.  If any do not have the correct texture,
	   * update them. */
	  this._updateTextures = function () {
	    var texture;

	    $.each(m_quads.imgQuads, function (idx, quad) {
	      if (!quad.image) {
	        return;
	      }
	      if (quad.image._texture) {
	        quad.texture = quad.image._texture;
	      } else {
	        texture = new vgl.texture();
	        texture.setImage(quad.image);
	        quad.texture = quad.image._texture = texture;
	      }
	    });
	  };

	  /**
	   * Render all of the color quads using a single mapper.
	   *
	   * @param renderState: the render state used for the render.
	   */
	  this._renderColorQuads = function (renderState) {
	    if (!m_quads.clrQuads.length) {
	      return;
	    }
	    var mapper = this;
	    if (mapper.getMTime() > m_glColorCompileTimestamp.getMTime() ||
	        m_this.dataTime().getMTime() > m_glColorCompileTimestamp.getMTime() ||
	        renderState.m_contextChanged || !m_clrposbuf ||
	        m_quads.clrQuads.length * 12 > m_clrposbuf.length) {
	      setupColorDrawObjects(renderState);
	    }
	    mapper.s_render(renderState, true);

	    var context = renderState.m_context, opacity = 1, color;

	    context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_glBuffers.clrQuadsPosition);
	    $.each(m_quads.clrQuads, function (idx, quad) {
	      if (quad.opacity !== opacity) {
	        opacity = quad.opacity;
	        context.uniform1fv(renderState.m_material.shaderProgram(
	            ).uniformLocation('opacity'), new Float32Array([opacity]));
	      }
	      if (!color || color.r !== quad.color.r || color.g !== quad.color.g ||
	          color.b !== quad.color.b) {
	        color = quad.color;
	        context.uniform3fv(renderState.m_material.shaderProgram(
	            ).uniformLocation('vertexColor'), new Float32Array([
	              color.r, color.g, color.b]));
	      }

	      context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_glBuffers.clrQuadsPosition);
	      context.vertexAttribPointer(vgl.vertexAttributeKeys.Position, 3,
	                                  vgl.GL.FLOAT, false, 12, idx * 12 * 4);
	      context.enableVertexAttribArray(vgl.vertexAttributeKeys.Position);

	      context.drawArrays(vgl.GL.TRIANGLE_STRIP, 0, 4);
	    });
	    context.bindBuffer(vgl.GL.ARRAY_BUFFER, null);
	    mapper.undoBindVertexData(renderState);
	  };

	  /**
	   * Render all of the image quads using a single mapper.
	   *
	   * @param renderState: the render state used for the render.
	   */
	  this._renderImageQuads = function (renderState) {
	    if (!m_quads.imgQuads.length) {
	      return;
	    }
	    var mapper = this;
	    if (mapper.getMTime() > m_glCompileTimestamp.getMTime() ||
	        m_this.dataTime().getMTime() > m_glCompileTimestamp.getMTime() ||
	        renderState.m_contextChanged || !m_imgposbuf ||
	        m_quads.imgQuads.length * 12 > m_imgposbuf.length) {
	      setupDrawObjects(renderState);
	    }
	    mapper.s_render(renderState, true);

	    var context = renderState.m_context,
	        opacity = 1,
	        crop = {x: 1, y: 1}, quadcrop;

	    m_this._updateTextures();

	    context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_glBuffers.imgQuadsPosition);
	    $.each(m_quads.imgQuads, function (idx, quad) {
	      if (!quad.image) {
	        return;
	      }
	      quad.texture.bind(renderState);

	      if (quad.opacity !== opacity) {
	        opacity = quad.opacity;
	        context.uniform1fv(renderState.m_material.shaderProgram(
	            ).uniformLocation('opacity'), new Float32Array([opacity]));
	      }
	      quadcrop = quad.crop || {x: 1, y: 1};
	      if (!crop || quadcrop.x !== crop.x || quadcrop.y !== crop.y) {
	        crop = quadcrop;
	        context.uniform2fv(renderState.m_material.shaderProgram(
	            ).uniformLocation('crop'), new Float32Array([crop.x, crop.y]));
	      }
	      context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_glBuffers.imgQuadsPosition);
	      context.vertexAttribPointer(vgl.vertexAttributeKeys.Position, 3,
	                                  vgl.GL.FLOAT, false, 12, idx * 12 * 4);
	      context.enableVertexAttribArray(vgl.vertexAttributeKeys.Position);

	      context.drawArrays(vgl.GL.TRIANGLE_STRIP, 0, 4);
	      quad.texture.undoBind(renderState);
	    });
	    context.bindBuffer(vgl.GL.ARRAY_BUFFER, null);
	    mapper.undoBindVertexData(renderState);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);
	    if (m_this.buildTime().getMTime() <= m_this.dataTime().getMTime() ||
	        m_this.updateTime().getMTime() < m_this.getMTime()) {
	      m_this._build();
	    }
	    if (m_actor_color) {
	      m_actor_color.setVisible(m_this.visible());
	      m_actor_color.material().setBinNumber(m_this.bin());
	    }
	    if (m_actor_image) {
	      m_actor_image.setVisible(m_this.visible());
	      m_actor_image.material().setBinNumber(m_this.bin());
	    }
	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    s_init.call(m_this, arg);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    if (m_actor_image) {
	      m_this.renderer().contextRenderer().removeActor(m_actor_image);
	      m_actor_image = null;
	    }
	    if (m_actor_color) {
	      m_this.renderer().contextRenderer().removeActor(m_actor_color);
	      m_actor_color = null;
	    }
	    s_exit.call(m_this);
	  };

	  m_this._init(arg);
	  return this;
	};

	inherit(gl_quadFeature, quadFeature);

	// Now register it
	var capabilities = {};
	capabilities[quadFeature.capabilities.color] = true;
	capabilities[quadFeature.capabilities.image] = true;
	capabilities[quadFeature.capabilities.imageCrop] = true;
	capabilities[quadFeature.capabilities.imageFull] = true;

	registerFeature('vgl', 'quad', gl_quadFeature, capabilities);
	module.exports = gl_quadFeature;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var registerLayerAdjustment = __webpack_require__(76).registerLayerAdjustment;

	var gl_tileLayer = function () {
	  'use strict';
	  var m_this = this,
	      s_init = this._init,
	      s_exit = this._exit,
	      m_quadFeature,
	      m_nextTileId = 0,
	      m_tiles = [];

	  /* Add a tile to the list of quads */
	  this._drawTile = function (tile) {
	    if (!m_quadFeature) {
	      return;
	    }
	    var bounds = this._tileBounds(tile),
	        level = tile.index.level || 0,
	        to = this._tileOffset(level),
	        crop = this.tileCropFromBounds(tile),
	        quad = {};
	    if (crop) {
	      quad.crop = {
	        x: crop.x / m_this._options.tileWidth,
	        y: crop.y / m_this._options.tileHeight
	      };
	    }
	    quad.ul = this.fromLocal(this.fromLevel({
	      x: bounds.left - to.x, y: bounds.top - to.y
	    }, level), 0);
	    quad.ll = this.fromLocal(this.fromLevel({
	      x: bounds.left - to.x, y: bounds.bottom - to.y
	    }, level), 0);
	    quad.ur = this.fromLocal(this.fromLevel({
	      x: bounds.right - to.x, y: bounds.top - to.y
	    }, level), 0);
	    quad.lr = this.fromLocal(this.fromLevel({
	      x: bounds.right - to.x, y: bounds.bottom - to.y
	    }, level), 0);
	    quad.ul.z = quad.ll.z = quad.ur.z = quad.lr.z = level * 1e-5;
	    m_nextTileId += 1;
	    quad.id = m_nextTileId;
	    tile.quadId = quad.id;
	    quad.image = tile.image;
	    m_tiles.push(quad);
	    m_quadFeature.data(m_tiles);
	    m_quadFeature._update();
	    m_this.draw();
	  };

	  /* Remove the tile feature. */
	  this._remove = function (tile) {
	    if (tile.quadId !== undefined && m_quadFeature) {
	      for (var i = 0; i < m_tiles.length; i += 1) {
	        if (m_tiles[i].id === tile.quadId) {
	          m_tiles.splice(i, 1);
	          break;
	        }
	      }
	      m_quadFeature.data(m_tiles);
	      m_quadFeature._update();
	      m_this.draw();
	    }
	  };

	  /**
	   * Clean up the layer.
	   */
	  this._exit = function () {
	    m_this.deleteFeature(m_quadFeature);
	    m_quadFeature = null;
	    m_tiles = [];
	    s_exit.apply(m_this, arguments);
	  };

	  /**
	   * Initialize after the layer is added to the map.
	   */
	  this._init = function () {
	    s_init.apply(m_this, arguments);
	    m_quadFeature = this.createFeature('quad', {
	      previewColor: m_this._options.previewColor,
	      previewImage: m_this._options.previewImage
	    });
	    m_quadFeature.geoTrigger = undefined;
	    m_quadFeature.gcs(m_this._options.gcs || m_this.map().gcs());
	    m_quadFeature.data(m_tiles);
	    m_quadFeature._update();
	  };

	  /* These functions don't need to do anything. */
	  this._getSubLayer = function () {};
	  this._updateSubLayers = undefined;
	};

	registerLayerAdjustment('vgl', 'tile', gl_tileLayer);

	module.exports = gl_tileLayer;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerRenderer = __webpack_require__(76).registerRenderer;
	var renderer = __webpack_require__(217);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class vglRenderer
	 *
	 * @class geo.gl.vglRenderer
	 * @extends geo.renderer
	 * @param canvas
	 * @returns {geo.gl.vglRenderer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var vglRenderer = function (arg) {
	  'use strict';

	  if (!(this instanceof vglRenderer)) {
	    return new vglRenderer(arg);
	  }
	  arg = arg || {};
	  renderer.call(this, arg);

	  var $ = __webpack_require__(1);
	  var vgl = __webpack_require__(81);
	  var mat4 = __webpack_require__(83);
	  var util = __webpack_require__(196);
	  var geo_event = __webpack_require__(5);

	  var m_this = this,
	      m_contextRenderer = null,
	      m_viewer = null,
	      m_width = 0,
	      m_height = 0,
	      m_renderAnimFrameRef = null,
	      m_lastZoom,
	      s_init = this._init,
	      s_exit = this._exit;

	  /// TODO: Move this API to the base class
	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return width of the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.width = function () {
	    return m_width;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return height of the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.height = function () {
	    return m_height;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get context specific renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.contextRenderer = function () {
	    return m_contextRenderer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get API used by the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.api = function () {
	    return 'vgl';
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    if (m_this.initialized()) {
	      return m_this;
	    }

	    s_init.call(m_this);

	    var canvas = $(document.createElement('canvas'));
	    canvas.attr('class', 'webgl-canvas');
	    $(m_this.layer().node().get(0)).append(canvas);
	    m_viewer = vgl.viewer(canvas.get(0), arg.options);
	    m_viewer.init();
	    m_contextRenderer = m_viewer.renderWindow().activeRenderer();
	    m_contextRenderer.setResetScene(false);

	    if (m_viewer.renderWindow().renderers().length > 0) {
	      m_contextRenderer.setLayer(m_viewer.renderWindow().renderers().length);
	    }
	    m_this.canvas(canvas);
	    /* Initialize the size of the renderer */
	    var map = m_this.layer().map(),
	        mapSize = map.size();
	    m_this._resize(0, 0, mapSize.width, mapSize.height);

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle resize event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._resize = function (x, y, w, h) {
	    var renderWindow = m_viewer.renderWindow();

	    m_width = w;
	    m_height = h;
	    m_this.canvas().attr('width', w);
	    m_this.canvas().attr('height', h);
	    renderWindow.positionAndResize(x, y, w, h);

	    m_this._updateRendererCamera();
	    m_this._render();

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render.  This actually schedules rendering for the next animation frame.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._render = function () {
	    if (m_renderAnimFrameRef) {
	      window.cancelAnimationFrame(m_renderAnimFrameRef);
	    }
	    m_renderAnimFrameRef = window.requestAnimationFrame(this._renderFrame);
	    return m_this;
	  };

	  /**
	   * This clears the render timer and actually renders.
	   */
	  this._renderFrame = function () {
	    m_renderAnimFrameRef = null;
	    m_viewer.render();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Exit
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.canvas().remove();
	    m_viewer.exit();
	    s_exit();
	  };

	  this._updateRendererCamera = function () {
	    var renderWindow = m_viewer.renderWindow(),
	        map = m_this.layer().map(),
	        camera = map.camera(),
	        rotation = map.rotation() || 0,
	        view = camera.view,
	        proj = camera.projectionMatrix;
	    if (proj[15]) {
	      /* we want positive z to be closer to the camera, but webGL does the
	       * converse, so reverse the z coordinates. */
	      proj = mat4.scale(util.mat4AsArray(), proj, [1, 1, -1]);
	    }
	    /* A similar kluge as in the base camera class worldToDisplay4.  With this,
	     * we can show z values from 0 to 1. */
	    proj = mat4.translate(util.mat4AsArray(), proj,
	                          [0, 0, camera.constructor.bounds.far]);
	    /* Check if the rotation is a multiple of 90 */
	    var basis = Math.PI / 2,
	        angle = rotation % basis,  // move to range (-pi/2, pi/2)
	        ortho = (Math.min(Math.abs(angle), Math.abs(angle - basis)) < 0.00001);
	    renderWindow.renderers().forEach(function (renderer) {
	      var cam = renderer.camera();
	      if (util.compareArrays(view, cam.viewMatrix()) &&
	          util.compareArrays(proj, cam.projectionMatrix()) &&
	          m_lastZoom === map.zoom()) {
	        return;
	      }
	      m_lastZoom = map.zoom();
	      cam.setViewMatrix(view, true);
	      cam.setProjectionMatrix(proj);
	      if (proj[1] || proj[2] || proj[3] || proj[4] || proj[6] || proj[7] ||
	          proj[8] || proj[9] || proj[11] || proj[15] !== 1 || !ortho ||
	          (parseFloat(m_lastZoom.toFixed(6)) !==
	           parseFloat(m_lastZoom.toFixed(0)))) {
	        /* Don't align texels */
	        cam.viewAlignment = function () {
	          return null;
	        };
	      } else {
	        /* Set information for texel alignment.  The rounding factors should
	         * probably be divided by window.devicePixelRatio. */
	        cam.viewAlignment = function () {
	          var align = {
	            roundx: 2.0 / camera.viewport.width,
	            roundy: 2.0 / camera.viewport.height
	          };
	          align.dx = (camera.viewport.width % 2) ? align.roundx * 0.5 : 0;
	          align.dy = (camera.viewport.height % 2) ? align.roundy * 0.5 : 0;
	          return align;
	        };
	      }
	    });
	  };

	  // Connect to pan event.  This is sufficient, as all zooms and rotations also
	  // produce a pan
	  m_this.layer().geoOn(geo_event.pan, function (evt) {
	    void (evt);
	    m_this._updateRendererCamera();
	  });

	  // Connect to parallelprojection event
	  m_this.layer().geoOn(geo_event.parallelprojection, function (evt) {
	    var vglRenderer = m_this.contextRenderer(),
	        camera,
	        layer = m_this.layer();

	    if (evt.geo && evt.geo._triggeredBy !== layer) {
	      if (!vglRenderer || !vglRenderer.camera()) {
	        console.log('Parallel projection event triggered on unconnected VGL ' +
	                    'renderer.');
	      }
	      camera = vglRenderer.camera();
	      camera.setEnableParallelProjection(evt.parallelProjection);
	      m_this._updateRendererCamera();
	    }
	  });

	  return this;
	};

	inherit(vglRenderer, renderer);

	registerRenderer('vgl', vglRenderer);

	(function () {
	  'use strict';

	  var checkedWebGL;

	  /**
	   * Report if the vgl renderer is supported.  This is just a check if webGL is
	   * supported and available.
	   *
	   * @returns {boolean} true if available.
	   */
	  vglRenderer.supported = function () {
	    if (checkedWebGL === undefined) {
	      /* This is extracted from what Modernizr uses. */
	      var canvas, ctx, exts; // eslint-disable-line no-unused-vars
	      try {
	        canvas = document.createElement('canvas');
	        ctx = (canvas.getContext('webgl') ||
	               canvas.getContext('experimental-webgl'));
	        exts = ctx.getSupportedExtensions();
	        checkedWebGL = true;
	      } catch (e) {
	        console.error('No webGL support');
	        checkedWebGL = false;
	      }
	      canvas = undefined;
	      ctx = undefined;
	      exts = undefined;
	    }
	    return checkedWebGL;
	  };

	  /**
	   * If the vgl renderer is not supported, supply the name of a renderer that
	   * should be used instead.  This asks for the null renderer.
	   *
	   * @returns null for the null renderer.
	   */
	  vglRenderer.fallback = function () {
	    return null;
	  };

	})();

	module.exports = vglRenderer;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @namespace geo.canvas
	 */
	module.exports = {
	  canvasRenderer: __webpack_require__(261),
	  quadFeature: __webpack_require__(262),
	  heatmapFeature: __webpack_require__(264),
	  tileLayer: __webpack_require__(265)
	};


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerRenderer = __webpack_require__(76).registerRenderer;
	var renderer = __webpack_require__(217);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class canvasRenderer
	 *
	 * @class geo.canvas.renderer
	 * @extends geo.renderer
	 * @param canvas
	 * @returns {geo.canvas.canvasRenderer}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var canvasRenderer = function (arg) {
	  'use strict';

	  var $ = __webpack_require__(1);

	  if (!(this instanceof canvasRenderer)) {
	    return new canvasRenderer(arg);
	  }
	  arg = arg || {};
	  renderer.call(this, arg);

	  var m_this = this,
	      m_renderAnimFrameRef = null,
	      m_clearCanvas = true,
	      s_init = this._init,
	      s_exit = this._exit;

	  this.clearCanvas = function (arg) {
	    m_clearCanvas = arg;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get API used by the renderer
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.api = function () {
	    return 'canvas';
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    if (m_this.initialized()) {
	      return m_this;
	    }

	    s_init.call(m_this);

	    var canvas = $(document.createElement('canvas'));
	    m_this.context2d = canvas[0].getContext('2d');

	    canvas.attr('class', 'canvas-canvas');
	    $(m_this.layer().node().get(0)).append(canvas);

	    m_this.canvas(canvas);
	    /* Initialize the size of the renderer */
	    var map = m_this.layer().map(),
	        mapSize = map.size();
	    m_this._resize(0, 0, mapSize.width, mapSize.height);

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Handle resize event
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._resize = function (x, y, w, h) {
	    m_this.canvas().attr('width', w);
	    m_this.canvas().attr('height', h);
	    m_this._render();

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._render = function () {
	    if (m_renderAnimFrameRef === null) {
	      m_renderAnimFrameRef = window.requestAnimationFrame(function () {
	        m_renderAnimFrameRef = null;

	        var layer = m_this.layer(),
	            map = layer.map(),
	            camera = map.camera(),
	            viewport = camera._viewport;

	        // Clear the canvas.
	        if (m_clearCanvas) {
	          m_this.context2d.setTransform(1, 0, 0, 1, 0, 0);
	          m_this.context2d.clearRect(0, 0, viewport.width, viewport.height);
	        }

	        var features = layer.features();
	        for (var i = 0; i < features.length; i += 1) {
	          features[i]._renderOnCanvas(m_this.context2d, map);
	        }
	      });
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Exit
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_this.canvas().remove();
	    s_exit();
	  };

	  return this;
	};

	inherit(canvasRenderer, renderer);

	registerRenderer('canvas', canvasRenderer);

	(function () {
	  'use strict';

	  var checkedCanvas;

	  /**
	   * Report if the canvas renderer is supported.
	   *
	   * @returns {boolean} true if available.
	   */
	  canvasRenderer.supported = function () {
	    if (checkedCanvas === undefined) {
	      /* This is extracted from what Modernizr uses. */
	      var canvas; // eslint-disable-line no-unused-vars
	      try {
	        canvas = document.createElement('canvas');
	        checkedCanvas = !!(canvas.getContext && canvas.getContext('2d'));
	      } catch (e) {
	        checkedCanvas = false;
	      }
	      canvas = undefined;
	    }
	    return checkedCanvas;
	  };

	  /**
	   * If the canvas renderer is not supported, supply the name of a renderer that
	   * should be used instead.  This asks for the null renderer.
	   *
	   * @returns null for the null renderer.
	   */
	  canvasRenderer.fallback = function () {
	    return null;
	  };
	})();

	module.exports = canvasRenderer;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var quadFeature = __webpack_require__(211);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class quadFeature
	 *
	 * @class geo.canvas.quadFeature
	 * @param {Object} arg Options object
	 * @extends geo.quadFeature
	 * @returns {geo.canvas.quadFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var canvas_quadFeature = function (arg) {
	  'use strict';

	  if (!(this instanceof canvas_quadFeature)) {
	    return new canvas_quadFeature(arg);
	  }
	  quadFeature.call(this, arg);

	  var object = __webpack_require__(263);
	  object.call(this);

	  var $ = __webpack_require__(1);

	  var m_this = this,
	      s_exit = this._exit,
	      s_init = this._init,
	      s_update = this._update,
	      m_quads;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Build this feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._build = function () {
	    if (!m_this.position()) {
	      return;
	    }
	    m_quads = this._generateQuads();

	    if (m_quads.imgQuads) {
	      m_quads.imgQuads.sort(function (a, b) {
	        return a.pos[2] - b.pos[2];
	      });
	    }
	    m_this.buildTime().modified();
	  };

	  /**
	   * Render all of the color quads using a single mapper.
	   *
	   * @param renderState: the render state used for the render.
	   */
	  this._renderColorQuads = function (renderState) {
	      // ....
	      // Not implemented yet.
	  };

	  /**
	   * Render all of the image quads using a single mapper.
	   *
	   * @param renderState: the render state used for the render.
	   */
	  this._renderImageQuads = function (context2d, map) {
	    if (!m_quads.imgQuads.length) {
	      return;
	    }

	    var oldAlpha = context2d.globalAlpha;
	    var opacity = oldAlpha;
	    $.each(m_quads.imgQuads, function (idx, quad) {
	      if (!quad.image) {
	        return;
	      }
	      var w = quad.image.width,
	          h = quad.image.height;
	      // Canvas transform is affine, so quad has to be a parallelogram
	      // Also, canvas has no way to render z.
	      var p0 = map.gcsToDisplay({x:quad.pos[0], y:quad.pos[1]}, null),
	          p3 = map.gcsToDisplay({x:quad.pos[9], y:quad.pos[10]}, null),
	          p2 = map.gcsToDisplay({x:quad.pos[6], y:quad.pos[7]}, null);
	      context2d.setTransform((p3.x - p2.x) / w, (p3.y - p2.y) / h,
	                             (p0.x - p2.x) / w, (p0.y - p2.y) / h,
	                             p2.x, p2.y);
	      if (quad.opacity !== opacity) {
	        opacity = quad.opacity;
	        context2d.globalAlpha = opacity;
	      }
	      if (!quad.crop) {
	        context2d.drawImage(quad.image, 0, 0);
	      } else {
	        context2d.drawImage(quad.image, 0, 0, quad.crop.x, quad.crop.y, 0, 0,
	                            quad.crop.x, quad.crop.y);
	      }
	    });
	    if (opacity !== oldAlpha) {
	      context2d.globalAlpha = oldAlpha;
	    }
	  };

	  this._renderOnCanvas = function (context, map) {
	    this._renderImageQuads(context, map);
	    this._renderColorQuads(context, map);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);
	    if (m_this.buildTime().getMTime() <= m_this.dataTime().getMTime() ||
	        m_this.updateTime().getMTime() < m_this.getMTime()) {
	      m_this._build();
	    }

	    m_this.updateTime().modified();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    s_init.call(m_this, arg);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {

	    s_exit.call(m_this);
	  };

	  m_this._init(arg);
	  return this;
	};

	inherit(canvas_quadFeature, quadFeature);

	// Now register it
	var capabilities = {};
	capabilities[quadFeature.capabilities.color] = false;
	capabilities[quadFeature.capabilities.image] = true;
	capabilities[quadFeature.capabilities.imageCrop] = true;
	capabilities[quadFeature.capabilities.imageFull] = false;

	registerFeature('canvas', 'quad', canvas_quadFeature, capabilities);
	module.exports = canvas_quadFeature;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var sceneObject = __webpack_require__(79);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Canvas specific subclass of object which rerenders when the object is drawn.
	 * @class geo.canvas.object
	 * @extends geo.sceneObject
	 */
	//////////////////////////////////////////////////////////////////////////////

	var canvas_object = function (arg) {
	  'use strict';

	  var object = __webpack_require__(80);

	  // this is used to extend other geojs classes, so only generate
	  // a new object when that is not the case... like if this === window
	  if (!(this instanceof object)) {
	    return new canvas_object(arg);
	  }
	  sceneObject.call(this);

	  var m_this = this,
	      s_draw = this.draw;

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	  *  Redraw the object.
	  */
	  ////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {
	    m_this._update();
	    m_this.renderer()._render();
	    s_draw();
	    return m_this;
	  };

	  return this;
	};

	inherit(canvas_object, sceneObject);
	module.exports = canvas_object;



/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var registerFeature = __webpack_require__(76).registerFeature;
	var heatmapFeature = __webpack_require__(231);
	var timestamp = __webpack_require__(195);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class heatmapFeature
	 * Inspired from
	 *    https://github.com/mourner/simpleheat/blob/gh-pages/simpleheat.js
	 *
	 * @class geo.canvas.heatmapFeature
	 * @param {Object} arg Options object
	 * @extends geo.heatmapFeature
	 * @returns {canvas_heatmapFeature}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var canvas_heatmapFeature = function (arg) {
	  'use strict';

	  if (!(this instanceof canvas_heatmapFeature)) {
	    return new canvas_heatmapFeature(arg);
	  }
	  heatmapFeature.call(this, arg);
	  var object = __webpack_require__(263);

	  object.call(this);

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  var geo_event = __webpack_require__(5);

	  var m_this = this,
	      m_typedBuffer,
	      m_typedClampedBuffer,
	      m_typedBufferData,
	      m_heatMapPosition,
	      s_exit = this._exit,
	      s_init = this._init,
	      s_update = this._update,
	      m_renderTime = timestamp();

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Meta functions for converting from geojs styles to canvas.
	   * @private
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._convertColor = function (c) {
	    var color;
	    if (c.hasOwnProperty('r') &&
	      c.hasOwnProperty('g') &&
	      c.hasOwnProperty('b') &&
	      c.hasOwnProperty('a')) {
	      color = 'rgba(' + 255 * c.r + ',' + 255 * c.g + ','
	                    + 255 * c.b + ',' + c.a + ')';
	    }
	    return color;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute gradient (color lookup table)
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._computeGradient = function () {
	    var canvas, stop, context2d, gradient, colors;

	    colors = m_this.style('color');
	    if (!m_this._grad || m_this._gradColors !== colors) {
	      canvas = document.createElement('canvas');
	      context2d = canvas.getContext('2d');
	      gradient = context2d.createLinearGradient(0, 0, 0, 256);

	      canvas.width = 1;
	      canvas.height = 256;

	      for (stop in colors) {
	        gradient.addColorStop(stop, m_this._convertColor(colors[stop]));
	      }

	      context2d.fillStyle = gradient;
	      context2d.fillRect(0, 0, 1, 256);
	      m_this._grad = context2d.getImageData(0, 0, 1, 256).data;
	      m_this._gradColors = colors;
	    }

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create circle for each data point
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._createCircle = function () {
	    var circle, ctx, r, r2, blur, gaussian;
	    r = m_this.style('radius');
	    blur = m_this.style('blurRadius');
	    gaussian = m_this.style('gaussian');
	    if (!m_this._circle || m_this._circle.gaussian !== gaussian ||
	        m_this._circle.radius !== r || m_this._circle.blurRadius !== blur) {
	      circle = m_this._circle = document.createElement('canvas');
	      ctx = circle.getContext('2d');
	      r2 = blur + r;
	      circle.width = circle.height = r2 * 2;
	      if (!gaussian) {
	        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
	        ctx.shadowBlur = blur;
	        ctx.shadowColor = 'black';
	        ctx.beginPath();
	        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
	        ctx.closePath();
	        ctx.fill();
	      } else {
	        /* This approximates a gaussian distribution by using a 10-step
	         * piecewise linear radial gradient.  Strictly, it should not stop at
	         * the radius, but should be attenuated further.  The scale has been
	         * selected such that the values at the radius are around 1/256th of
	         * the maximum, and therefore would not be visible using an 8-bit alpha
	         * channel for the summation.  The values for opacity were generated by
	         * the python expression:
	         *   from scipy.stats import norm
	         *   for r in [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]:
	         *     opacity = norm.pdf(r, scale=0.3) / norm.pdf(0, scale=0.3)
	         * Usng a 10-interval approximation is accurate to within 0.5% of the
	         * actual Gaussian magnitude.  Switching to a 20-interval approximation
	         * would get within 0.1%, at which point there is more error from using
	         * a Gaussian truncated at the radius than from the approximation.
	         */
	        var grad = ctx.createRadialGradient(r2, r2, 0, r2, r2, r2);
	        grad.addColorStop(0.0, 'rgba(255,255,255,1)');
	        grad.addColorStop(0.1, 'rgba(255,255,255,0.946)');
	        grad.addColorStop(0.2, 'rgba(255,255,255,0.801)');
	        grad.addColorStop(0.3, 'rgba(255,255,255,0.607)');
	        grad.addColorStop(0.4, 'rgba(255,255,255,0.411)');
	        grad.addColorStop(0.5, 'rgba(255,255,255,0.249)');
	        grad.addColorStop(0.6, 'rgba(255,255,255,0.135)');
	        grad.addColorStop(0.7, 'rgba(255,255,255,0.066)');
	        grad.addColorStop(0.8, 'rgba(255,255,255,0.029)');
	        grad.addColorStop(0.9, 'rgba(255,255,255,0.011)');
	        grad.addColorStop(1.0, 'rgba(255,255,255,0)');
	        ctx.fillStyle = grad;
	        ctx.fillRect(0, 0, r2 * 2, r2 * 2);
	      }
	      circle.radius = r;
	      circle.blurRadius = blur;
	      circle.gaussian = gaussian;
	      m_this._circle = circle;
	    }
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Compute color for each pixel on the screen
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._colorize = function (pixels, gradient) {
	    var grad = new Uint32Array(gradient.buffer),
	        pixlen = pixels.length,
	        i, j, k;
	    if (!m_typedBuffer || m_typedBuffer.length !== pixlen) {
	      m_typedBuffer = new ArrayBuffer(pixlen);
	      m_typedClampedBuffer = new Uint8ClampedArray(m_typedBuffer);
	      m_typedBufferData = new Uint32Array(m_typedBuffer);
	    }
	    for (i = 3, k = 0; i < pixlen; i += 4, k += 1) {
	      // Get opacity from the temporary canvas image and look up the final
	      // value from gradient
	      j = pixels[i];
	      if (j) {
	        m_typedBufferData[k] = grad[j];
	      }
	    }
	    pixels.set(m_typedClampedBuffer);
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render individual data points on the canvas.
	   * @protected
	   * @param {object} context2d the canvas context to draw in.
	   * @param {object} map the parent map object.
	   * @param {Array} data the main data array.
	   * @param {number} radius the sum of radius and blurRadius.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._renderPoints = function (context2d, map, data, radius) {
	    var position = m_this.gcsPosition(),
	        intensityFunc = m_this.intensity(),
	        minIntensity = m_this.minIntensity(),
	        rangeIntensity = (m_this.maxIntensity() - minIntensity) || 1,
	        idx, pos, intensity;

	    for (idx = data.length - 1; idx >= 0; idx -= 1) {
	      pos = map.worldToDisplay(position[idx]);
	      intensity = (intensityFunc(data[idx]) - minIntensity) / rangeIntensity;
	      if (intensity <= 0) {
	        continue;
	      }
	      // Small values are not visible because globalAlpha < .01
	      // cannot be read from imageData
	      context2d.globalAlpha = intensity < 0.01 ? 0.01 : (intensity > 1 ? 1 : intensity);
	      context2d.drawImage(m_this._circle, pos.x - radius, pos.y - radius);
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render data points on the canvas by binning.
	   * @protected
	   * @param {object} context2d the canvas context to draw in.
	   * @param {object} map the parent map object.
	   * @param {Array} data the main data array.
	   * @param {number} radius the sum of radius and blurRadius.
	   * @param {number} binSize size of the bins in pixels.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._renderBinnedData = function (context2d, map, data, radius, binSize) {
	    var position = m_this.gcsPosition(),
	        intensityFunc = m_this.intensity(),
	        minIntensity = m_this.minIntensity(),
	        rangeIntensity = (m_this.maxIntensity() - minIntensity) || 1,
	        viewport = map.camera()._viewport,
	        bins = [],
	        rw = Math.ceil(radius / binSize),
	        maxx = Math.ceil(viewport.width / binSize) + rw * 2 + 2,
	        maxy = Math.ceil(viewport.height / binSize) + rw * 2 + 2,
	        datalen = data.length,
	        idx, pos, intensity, x, y, binrow, offsetx, offsety;

	    /* We create bins of size (binSize) pixels on a side.  We only track bins
	     * that are on the viewport or within the radius of it, plus one extra bin
	     * width. */
	    for (idx = 0; idx < datalen; idx += 1) {
	      pos = map.worldToDisplay(position[idx]);
	      /* To make the results look more stable, we use the first data point as a
	       * hard-reference to where the bins should line up.  Otherwise, as we pan
	       * points would shift which bin they are in and the display would ripple
	       * oddly. */
	      if (isNaN(pos.x) || isNaN(pos.y)) {
	        continue;
	      }
	      if (offsetx === undefined) {
	        offsetx = ((pos.x % binSize) + binSize) % binSize;
	        offsety = ((pos.y % binSize) + binSize) % binSize;
	      }
	      /* We handle points that are in the viewport, plus the radius on either
	       * side, as they will add into the visual effect, plus one additional bin
	       * to account for the offset alignment. */
	      x = Math.floor((pos.x - offsetx) / binSize) + rw + 1;
	      if (x < 0 || x >= maxx) {
	        continue;
	      }
	      y = Math.floor((pos.y - offsety) / binSize) + rw + 1;
	      if (y < 0 || y >= maxy) {
	        continue;
	      }
	      intensity = (intensityFunc(data[idx]) - minIntensity) / rangeIntensity;
	      if (intensity <= 0) {
	        continue;
	      }
	      if (intensity > 1) {
	        intensity = 1;
	      }
	      /* bins is an array of arrays.  The subarrays would be conceptually
	       * better represented as an array of dicts, but having a sparse array is
	       * uses much less memory and is faster.  Each bin uses four array entries
	       * that are (weight, intensity, x, y).  The weight is the sum of the
	       * intensities for all points in the bin.  The intensity is the geometric
	       * sum of the intensities to approximate what happens to the unbinned
	       * data on the alpha channel of the canvas.  The x and y coordinates are
	       * weighted by the intensity of each point. */
	      bins[y] = bins[y] || [];
	      x *= 4;
	      binrow = bins[y];
	      if (!binrow[x]) {
	        binrow[x] = binrow[x + 1] = intensity;
	        binrow[x + 2] = pos.x * intensity;
	        binrow[x + 3] = pos.y * intensity;
	      } else {
	        binrow[x] += intensity;  // weight
	        binrow[x + 1] += (1 - binrow[x + 1]) * intensity;
	        binrow[x + 2] += pos.x * intensity;
	        binrow[x + 3] += pos.y * intensity;
	      }
	    }
	    /* For each bin, render a point on the canvas. */
	    for (y = bins.length - 1; y >= 0; y -= 1) {
	      binrow = bins[y];
	      if (binrow) {
	        for (x = binrow.length - 4; x >= 0; x -= 4) {
	          if (binrow[x]) {
	            intensity = binrow[x + 1];
	            context2d.globalAlpha = intensity < 0.01 ? 0.01 : (intensity > 1 ? 1 : intensity);
	            /* The position is eighted by the intensities, so we have to divide
	             * it to get the necessary position */
	            context2d.drawImage(
	              m_this._circle,
	              binrow[x + 2] / binrow[x] - radius,
	              binrow[x + 3] / binrow[x] - radius);
	          }
	        }
	      }
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Render the data on the canvas, then colorize the resulting opacity map.
	   * @protected
	   * @param {object} context2d the canvas context to draw in.
	   * @param {object} map the parent map object.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._renderOnCanvas = function (context2d, map) {

	    if (m_renderTime.getMTime() < m_this.buildTime().getMTime()) {
	      var data = m_this.data() || [],
	          radius = m_this.style('radius') + m_this.style('blurRadius'),
	          binned = m_this.binned(),
	          canvas, pixelArray,
	          layer = m_this.layer(),
	          viewport = map.camera()._viewport;

	      /* Determine if we should bin the data */
	      if (binned === true || binned === 'auto') {
	        binned = Math.max(Math.floor(radius / 8), 3);
	        if (m_this.binned() === 'auto') {
	          var numbins = (Math.ceil((viewport.width + radius * 2) / binned) *
	                         Math.ceil((viewport.height + radius * 2) / binned));
	          if (numbins >= data.length) {
	            binned = 0;
	          }
	        }
	      }
	      if (binned < 1 || isNaN(binned)) {
	        binned = false;
	      }
	      /* Store what we did, in case this is ever useful elsewhere */
	      m_this._binned = binned;

	      context2d.setTransform(1, 0, 0, 1, 0, 0);
	      context2d.clearRect(0, 0, viewport.width, viewport.height);
	      layer.canvas().css({transform: '', 'transform-origin': '0px 0px'});

	      m_this._createCircle();
	      m_this._computeGradient();
	      if (!binned) {
	        m_this._renderPoints(context2d, map, data, radius);
	      } else {
	        m_this._renderBinnedData(context2d, map, data, radius, binned);
	      }
	      canvas = layer.canvas()[0];
	      pixelArray = context2d.getImageData(0, 0, canvas.width, canvas.height);
	      m_this._colorize(pixelArray.data, m_this._grad);
	      context2d.putImageData(pixelArray, 0, 0);

	      m_heatMapPosition = {
	        zoom: map.zoom(),
	        gcsOrigin: map.displayToGcs({x: 0, y: 0}, null),
	        rotation: map.rotation(),
	        lastScale: undefined,
	        lastOrigin: {x: 0, y: 0},
	        lastRotation: undefined
	      };
	      m_renderTime.modified();
	      layer.renderer().clearCanvas(false);
	    }

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    s_init.call(m_this, arg);

	    m_this.geoOn(geo_event.pan, m_this._animatePan);

	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._update = function () {
	    s_update.call(m_this);
	    if (m_this.buildTime().getMTime() <= m_this.dataTime().getMTime() ||
	        m_this.updateTime().getMTime() < m_this.getMTime()) {
	      m_this._build();
	    }
	    m_this.updateTime().modified();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Animate pan (and zoom)
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._animatePan = function (e) {

	    var map = m_this.layer().map(),
	        zoom = map.zoom(),
	        scale = Math.pow(2, (zoom - m_heatMapPosition.zoom)),
	        origin = map.gcsToDisplay(m_heatMapPosition.gcsOrigin, null),
	        rotation = map.rotation();

	    if (m_heatMapPosition.lastScale === scale &&
	        m_heatMapPosition.lastOrigin.x === origin.x &&
	        m_heatMapPosition.lastOrigin.y === origin.y &&
	        m_heatMapPosition.lastRotation === rotation) {
	      return;
	    }

	    var transform = '' +
	        ' translate(' + origin.x + 'px' + ',' + origin.y + 'px' + ')' +
	        ' scale(' + scale + ')' +
	        ' rotate(' + ((rotation - m_heatMapPosition.rotation) * 180 / Math.PI) + 'deg)';

	    m_this.layer().canvas()[0].style.transform = transform;

	    m_heatMapPosition.lastScale = scale;
	    m_heatMapPosition.lastOrigin.x = origin.x;
	    m_heatMapPosition.lastOrigin.y = origin.y;
	    m_heatMapPosition.lastRotation = rotation;

	    if (m_heatMapPosition.timeout) {
	      window.clearTimeout(m_heatMapPosition.timeout);
	      m_heatMapPosition.timeout = undefined;
	    }
	    /* This conditional can change if we compute the heatmap beyond the visable
	     * viewport so that we don't have to update on pans as often.  If we are
	     * close to where the heatmap was originally computed, don't bother
	     * updating it. */
	    if (parseFloat(scale.toFixed(4)) !== 1 ||
	        parseFloat((rotation - m_heatMapPosition.rotation).toFixed(4)) !== 0 ||
	        parseFloat(origin.x.toFixed(1)) !== 0 ||
	        parseFloat(origin.y.toFixed(1)) !== 0) {
	      m_heatMapPosition.timeout = window.setTimeout(function () {
	        m_heatMapPosition.timeout = undefined;
	        m_this.buildTime().modified();
	        m_this.layer().draw();
	      }, m_this.updateDelay());
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Destroy
	   * @protected
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    s_exit.call(m_this);
	  };

	  m_this._init(arg);
	  return this;
	};

	inherit(canvas_heatmapFeature, heatmapFeature);

	// Now register it
	registerFeature('canvas', 'heatmap', canvas_heatmapFeature);
	module.exports = canvas_heatmapFeature;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var registerLayerAdjustment = __webpack_require__(76).registerLayerAdjustment;

	var canvas_tileLayer = function () {
	  'use strict';
	  var m_this = this,
	      s_init = this._init,
	      s_exit = this._exit,
	      m_quadFeature,
	      m_nextTileId = 0,
	      m_tiles = [];

	  /* Add a tile to the list of quads */
	  this._drawTile = function (tile) {
	    if (!m_quadFeature) {
	      return;
	    }
	    var bounds = this._tileBounds(tile),
	        level = tile.index.level || 0,
	        to = this._tileOffset(level),
	        crop = this.tileCropFromBounds(tile),
	        quad = {};
	    if (crop) {
	      quad.crop = crop;
	    }
	    quad.ul = this.fromLocal(this.fromLevel({
	      x: bounds.left - to.x, y: bounds.top - to.y
	    }, level), 0);
	    quad.ll = this.fromLocal(this.fromLevel({
	      x: bounds.left - to.x, y: bounds.bottom - to.y
	    }, level), 0);
	    quad.ur = this.fromLocal(this.fromLevel({
	      x: bounds.right - to.x, y: bounds.top - to.y
	    }, level), 0);
	    quad.lr = this.fromLocal(this.fromLevel({
	      x: bounds.right - to.x, y: bounds.bottom - to.y
	    }, level), 0);
	    quad.ul.z = quad.ll.z = quad.ur.z = quad.lr.z = level * 1e-5;
	    m_nextTileId += 1;
	    quad.id = m_nextTileId;
	    tile.quadId = quad.id;
	    quad.image = tile.image;
	    m_tiles.push(quad);
	    m_quadFeature.data(m_tiles);
	    m_quadFeature._update();
	    m_this.draw();
	  };

	  /* Remove the tile feature. */
	  this._remove = function (tile) {
	    if (tile.quadId !== undefined && m_quadFeature) {
	      for (var i = 0; i < m_tiles.length; i += 1) {
	        if (m_tiles[i].id === tile.quadId) {
	          m_tiles.splice(i, 1);
	          break;
	        }
	      }
	      m_quadFeature.data(m_tiles);
	      m_quadFeature._update();
	      m_this.draw();
	    }
	  };

	  /**
	   * Clean up the layer.
	   */
	  this._exit = function () {
	    m_this.deleteFeature(m_quadFeature);
	    m_quadFeature = null;
	    m_tiles = [];
	    s_exit.apply(m_this, arguments);
	  };

	  /**
	   * Initialize after the layer is added to the map.
	   */
	  this._init = function () {
	    s_init.apply(m_this, arguments);
	    m_quadFeature = this.createFeature('quad', {
	      previewColor: m_this._options.previewColor,
	      previewImage: m_this._options.previewImage
	    });
	    m_quadFeature.geoTrigger = undefined;
	    m_quadFeature.gcs(m_this._options.gcs || m_this.map().gcs());
	    m_quadFeature.data(m_tiles);
	    m_quadFeature._update();
	  };

	  /* These functions don't need to do anything. */
	  this._getSubLayer = function () {};
	  this._updateSubLayers = undefined;
	};

	registerLayerAdjustment('canvas', 'tile', canvas_tileLayer);
	module.exports = canvas_tileLayer;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @namespace geo.gui
	 */
	module.exports = {
	  domWidget: __webpack_require__(267),
	  legendWidget: __webpack_require__(269),
	  sliderWidget: __webpack_require__(271),
	  svgWidget: __webpack_require__(270),
	  uiLayer: __webpack_require__(226),
	  widget: __webpack_require__(268)
	};


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var widget = __webpack_require__(268);
	var inherit = __webpack_require__(4);
	var registerWidget = __webpack_require__(76).registerWidget;

	var domWidget = function (arg) {
	  'use strict';
	  if (!(this instanceof domWidget)) {
	    return new domWidget(arg);
	  }

	  widget.call(this, arg);

	  var m_this = this,
	      m_default_canvas = 'div';

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initializes DOM Widget.
	   * Sets the canvas for the widget, does parent/child relationship management,
	   * appends it to it's parent and handles any positioning logic.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    if (arg.hasOwnProperty('parent')) {
	      arg.parent.addChild(m_this);
	    }

	    m_this._createCanvas();
	    m_this._appendChild();

	    m_this.canvas().addEventListener('mousedown', function (e) {
	      e.stopPropagation();
	    });

	    m_this.reposition();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Creates the widget canvas.
	   * This is just a simple DOM element (based on args.el, or defaults to a div)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._createCanvas = function () {
	    m_this.canvas(document.createElement(arg.el || m_default_canvas));
	  };

	  return this;
	};

	inherit(domWidget, widget);

	registerWidget('dom', 'dom', domWidget);
	module.exports = domWidget;


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var inherit = __webpack_require__(4);
	var sceneObject = __webpack_require__(79);

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class widget
	 *
	 * @class geo.gui.widget
	 * @extends {geo.sceneObject}
	 * @returns {geo.gui.widget}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var widget = function (arg) {
	  'use strict';
	  if (!(this instanceof widget)) {
	    return new widget(arg);
	  }
	  sceneObject.call(this, arg);

	  var geo_event = __webpack_require__(5);
	  var createFeature = __webpack_require__(76).createFeature;

	  var m_this = this,
	      s_exit = this._exit,
	      m_layer = arg.layer,
	      m_canvas = null;

	  arg.position = arg.position === undefined ? { left: 0, top: 0 } : arg.position;

	  if (arg.parent !== undefined && !(arg.parent instanceof widget)) {
	    throw 'Parent must be of type geo.gui.widget';
	  }

	  this._init = function () {
	    m_this.modified();
	  };

	  this._exit = function () {
	    m_this.children().forEach(function (child) {
	      m_this._deleteFeature(child);
	    });

	    m_this.layer().geoOff(geo_event.pan, m_this.repositionEvent);
	    m_this.parentCanvas().removeChild(m_this.canvas());
	    s_exit();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create feature give a name
	   *
	   * @returns {geo.Feature} Will return a new feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._createFeature = function (featureName, arg) {

	    var newFeature = createFeature(
	      featureName, m_this, m_this.renderer(), arg);

	    m_this.addChild(newFeature);
	    m_this.modified();
	    return newFeature;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Delete feature
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._deleteFeature = function (feature) {
	    m_this.removeChild(feature);
	    feature._exit();
	    return m_this;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Return the layer associated with this widget.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.layer = function () {
	    return m_layer;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Create the canvas this widget will operate on.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._createCanvas = function () {
	    throw 'Must be defined in derived classes';
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get/Set the canvas for the widget
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.canvas = function (val) {
	    if (val === undefined) {
	      return m_canvas;
	    } else {
	      m_canvas = val;
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Appends a child to the widget
	   * The widget determines how to append itself to a parent, the parent can either
	   * be another widget, or the UI Layer.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._appendChild = function () {
	    m_this.parentCanvas().appendChild(m_this.canvas());
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the parent canvas (top level widgets define their layer as their parent canvas)
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.parentCanvas = function () {
	    if (m_this.parent === undefined) {
	      return m_this.layer().canvas();
	    } else {
	      return m_this.parent().canvas();
	    }
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Gets the CSS positioning that a widget should be placed at.
	   * { top: 0, left: 0 } by default.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.position = function (pos) {
	    if (pos !== undefined) {
	      arg.position = pos;
	      this.reposition();
	      return this;
	    }
	    var position;

	    if (arg &&
	        arg.hasOwnProperty('position') &&
	        arg.position.hasOwnProperty('x') &&
	        arg.position.hasOwnProperty('y')) {

	      position = m_this.layer().map().gcsToDisplay(arg.position);

	      return {
	        left: position.x,
	        top: position.y
	      };
	    }

	    return arg.position;
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Repositions a widget based on the argument passed, or calling position on
	   * the widget itself.
	   * @param {object} position A position with the form:
	   * { top: m, left: n }
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.reposition = function (position) {
	    position = position || m_this.position();
	    m_this.canvas().style.position = 'absolute';

	    for (var cssAttr in position) {
	      if (position.hasOwnProperty(cssAttr)) {
	        m_this.canvas().style[cssAttr] = position[cssAttr] + 'px';
	      }
	    }
	  };

	  this.repositionEvent = function () {
	    return m_this.reposition();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Determines whether or not the widget is completely within the viewport.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this.isInViewport = function () {
	    var position = m_this.position();
	    var layer = m_this.layer();

	    return ((position.left >= 0 && position.top >= 0) &&
	            (position.left <= layer.width() && position.top <= layer.height()));
	  };

	  if (arg &&
	      arg.hasOwnProperty('position') &&
	      arg.position.hasOwnProperty('x') &&
	      arg.position.hasOwnProperty('y')) {
	    this.layer().geoOn(geo_event.pan, m_this.repositionEvent);
	  }
	};
	inherit(widget, sceneObject);
	module.exports = widget;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var svgWidget = __webpack_require__(270);
	var inherit = __webpack_require__(4);
	var registerWidget = __webpack_require__(76).registerWidget;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class legendWidget
	 *
	 * @class geo.gui.legendWidget
	 * @extends geo.gui.svgWidget
	 * @returns {geo.gui.legendWidget}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var legendWidget = function (arg) {
	  'use strict';
	  if (!(this instanceof legendWidget)) {
	    return new legendWidget(arg);
	  }
	  svgWidget.call(this, arg);

	  var d3 = __webpack_require__(213);
	  var geo_event = __webpack_require__(5);

	  /** @private */
	  var m_this = this,
	      m_categories = [],
	      m_top = null,
	      m_group = null,
	      m_border = null,
	      m_spacing = 20, // distance in pixels between lines
	      m_padding = 12, // padding in pixels inside the border
	      s_createCanvas = this._createCanvas,
	      s_appendChild = this._appendChild;

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get or set the category array associated with
	   * the legend.  Each element of this array is
	   * an object: ::
	   *     {
	   *         name: string,
	   *         style: object,
	   *         type: 'point' | 'line' | ...
	   *     }
	   *
	   * The style property can contain the following feature styles:
	   *     * fill: bool
	   *     * fillColor: object | string
	   *     * fillOpacity: number
	   *     * stroke: bool
	   *     * strokeColor: object | string
	   *     * strokeWidth: number
	   *     * strokeOpacity: number
	   *
	   * The type controls how the element is displayed, point as a circle,
	   * line as a line segment.  Any other value will display as a rounded
	   * rectangle.
	   *
	   * @param {object[]?} categories The categories to display
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.categories = function (arg) {
	    if (arg === undefined) {
	      return m_categories.slice();
	    }
	    m_categories = arg.slice().map(function (d) {
	      if (d.type === 'line') {
	        d.style.fill = false;
	        d.style.stroke = true;
	      }
	      return d;
	    });
	    m_this.draw();
	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get the widget's size
	   * @return {{width: number, height: number}} The size in pixels
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.size = function () {
	    var width = 1, height;
	    var test = d3.select(m_this.canvas()).append('text')
	          .style('opacity', 1e-6);

	    m_categories.forEach(function (d) {
	      test.text(d.name);
	      width = Math.max(width, test.node().getBBox().width);
	    });
	    test.remove();

	    height = m_spacing * (m_categories.length + 1);
	    return {
	      width: width + 50,
	      height: height
	    };
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Redraw the legend
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this.draw = function () {

	    m_this._init();
	    function applyColor(selection) {
	      selection.style('fill', function (d) {
	        if (d.style.fill || d.style.fill === undefined) {
	          return d.style.fillColor;
	        } else {
	          return 'none';
	        }
	      })
	        .style('fill-opacity', function (d) {
	          if (d.style.fillOpacity === undefined) {
	            return 1;
	          }
	          return d.style.fillOpacity;
	        })
	        .style('stroke', function (d) {
	          if (d.style.stroke || d.style.stroke === undefined) {
	            return d.style.strokeColor;
	          } else {
	            return 'none';
	          }
	        })
	        .style('stroke-opacity', function (d) {
	          if (d.style.strokeOpacity === undefined) {
	            return 1;
	          }
	          return d.style.strokeOpacity;
	        })
	        .style('stroke-width', function (d) {
	          if (d.style.strokeWidth === undefined) {
	            return 1.5;
	          }
	          return d.style.strokeWidth;
	        });
	    }

	    m_border.attr('height', m_this.size().height + 2 * m_padding)
	      .style('display', null);

	    var scale = m_this._scale();

	    var labels = m_group.selectAll('g.geo-label')
	          .data(m_categories, function (d) { return d.name; });

	    var g = labels.enter().append('g')
	          .attr('class', 'geo-label')
	          .attr('transform', function (d, i) {
	            return 'translate(0,' + scale.y(i) + ')';
	          });

	    applyColor(g.filter(function (d) {
	      return d.type !== 'point' && d.type !== 'line';
	    }).append('rect')
	               .attr('x', 0)
	               .attr('y', -6)
	               .attr('rx', 5)
	               .attr('ry', 5)
	               .attr('width', 40)
	               .attr('height', 12)
	              );

	    applyColor(g.filter(function (d) {
	      return d.type === 'point';
	    }).append('circle')
	               .attr('cx', 20)
	               .attr('cy', 0)
	               .attr('r', 6)
	              );

	    applyColor(g.filter(function (d) {
	      return d.type === 'line';
	    }).append('line')
	               .attr('x1', 0)
	               .attr('y1', 0)
	               .attr('x2', 40)
	               .attr('y2', 0)
	              );

	    g.append('text')
	      .attr('x', '50px')
	      .attr('y', 0)
	      .attr('dy', '0.3em')
	      .text(function (d) {
	        return d.name;
	      });

	    m_this.reposition();

	    return m_this;
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Get scales for the x and y axis for the current size.
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._scale = function () {
	    return {
	      x: d3.scale.linear()
	        .domain([0, 1])
	        .range([0, m_this.size().width]),
	      y: d3.scale.linear()
	        .domain([0, m_categories.length - 1])
	        .range([m_padding / 2, m_this.size().height - m_padding / 2])
	    };
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Private initialization.  Creates the widget's DOM container and internal
	   * variables.
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    // adding categories redraws the entire thing by calling _init, see
	    // the m_top.remove() line below
	    if (!m_top) {
	      s_createCanvas();
	      s_appendChild();
	    }

	    // total size = interior size + 2 * padding + 2 * width of the border
	    var w = m_this.size().width + 2 * m_padding + 4,
	        h = m_this.size().height + 2 * m_padding + 4;

	    // @todo - removing after creating to maintain the appendChild structure
	    if (m_top) {
	      m_top.remove();
	    }

	    d3.select(m_this.canvas()).attr('width', w).attr('height', h);

	    m_top = d3.select(m_this.canvas()).append('g');
	    m_group = m_top
	      .append('g')
	      .attr('transform', 'translate(' + [m_padding + 2, m_padding + 2] + ')');
	    m_border = m_group.append('rect')
	      .attr('x', -m_padding)
	      .attr('y', -m_padding)
	      .attr('width', w - 4)
	      .attr('height', h - 4)
	      .attr('rx', 3)
	      .attr('ry', 3)
	      .style({
	        'stroke': 'black',
	        'stroke-width': '1.5px',
	        'fill': 'white',
	        'fill-opacity': 0.75,
	        'display': 'none'
	      });
	    m_group.on('mousedown', function () {
	      d3.event.stopPropagation();
	    });
	    m_group.on('mouseover', function () {
	      m_border.transition()
	        .duration(250)
	        .style('fill-opacity', 1);
	    });
	    m_group.on('mouseout', function () {
	      m_border.transition()
	        .duration(250)
	        .style('fill-opacity', 0.75);
	    });

	    m_this.reposition();
	  };

	  this.geoOn(geo_event.resize, function () {
	    m_this.draw();
	  });

	};

	inherit(legendWidget, svgWidget);

	registerWidget('dom', 'legend', legendWidget);
	module.exports = legendWidget;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var domWidget = __webpack_require__(267);
	var inherit = __webpack_require__(4);
	var registerWidget = __webpack_require__(76).registerWidget;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class geo.gui.svgWidget
	 *
	 * Due to the nature of d3 creating DOM elements as it inserts them, calls to appendChild
	 * don't appear in this widget.
	 *
	 * The canvas of an svgWidget always refers to the actual svg element.
	 * The parentCanvas can refer to another widgets svg element, dom element, or the
	 * UI layers dom element.
	 * See {@link geo.gui.widget#parentCanvas}.
	 *
	 * @class geo.gui.svgWidget
	 * @extends geo.gui.domWidget
	 * @returns {geo.gui.svgWidget}
	 *
	 */
	//////////////////////////////////////////////////////////////////////////////
	var svgWidget = function (arg) {
	  'use strict';
	  if (!(this instanceof svgWidget)) {
	    return new svgWidget(arg);
	  }

	  domWidget.call(this, arg);

	  var d3Renderer = __webpack_require__(244);

	  var m_this = this,
	      m_renderer = null;

	  this._init = function (arg) {
	    var d3Parent;
	    if (arg.hasOwnProperty('parent')) {
	      arg.parent.addChild(m_this);

	      // Tell the renderer there is an SVG element as a parent
	      d3Parent = arg.parent.canvas();
	    }

	    m_this._createCanvas(d3Parent);

	    m_this.canvas().addEventListener('mousedown', function (e) {
	      e.stopPropagation();
	    });

	    m_this.reposition();
	  };

	  ////////////////////////////////////////////////////////////////////////////
	  /**
	   * Creates the canvas for the svg widget.
	   * This directly uses the {@link geo.d3.d3Renderer} as a helper to do all of the heavy
	   * lifting.
	   */
	  ////////////////////////////////////////////////////////////////////////////
	  this._createCanvas = function (d3Parent) {
	    var rendererOpts = {
	      layer: m_this.layer(),
	      widget: true
	    };

	    if (d3Parent) {
	      rendererOpts.d3Parent = d3Parent;
	    }

	    m_renderer = d3Renderer(rendererOpts);

	    m_this.canvas(m_renderer.canvas()[0][0]);
	  };

	  return this;
	};

	inherit(svgWidget, domWidget);

	registerWidget('dom', 'svg', svgWidget);
	module.exports = svgWidget;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	var svgWidget = __webpack_require__(270);
	var inherit = __webpack_require__(4);
	var registerWidget = __webpack_require__(76).registerWidget;

	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Create a new instance of class sliderWidget
	 *
	 * @class geo.gui.sliderWidget
	 * @extends {geo.gui.svgWidget}
	 * @returns {geo.gui.sliderWidget}
	 */
	//////////////////////////////////////////////////////////////////////////////
	var sliderWidget = function (arg) {
	  'use strict';
	  if (!(this instanceof sliderWidget)) {
	    return new sliderWidget(arg);
	  }
	  svgWidget.call(this, arg);

	  var d3 = __webpack_require__(213);
	  var geo_event = __webpack_require__(5);

	  var m_this = this,
	      s_exit = this._exit,
	      s_createCanvas = this._createCanvas,
	      s_appendChild = this._appendChild,
	      m_xscale,
	      m_yscale,
	      m_plus,
	      m_minus,
	      m_nub,
	      m_width = 20, // Approximate size of the widget in pixels
	      m_height = 100,
	      m_nubSize = 10,
	      m_plusIcon,
	      m_minusIcon,
	      m_group,
	      m_lowContrast,
	      m_highlightDur = 100;

	  /* http://icomoon.io */
	  /* CC BY 3.0 http://creativecommons.org/licenses/by/3.0/ */
	  m_plusIcon = 'M512 81.92c-237.568 0-430.080 192.614-430.080 430.080 0 237.568 192.563 430.080 430.080 430.080s430.080-192.563 430.080-430.080c0-237.517-192.563-430.080-430.080-430.080zM564.326 564.326v206.182h-104.653v-206.182h-206.234v-104.653h206.182v-206.234h104.704v206.182h206.182v104.704h-206.182z';
	  m_minusIcon = 'M512 81.92c-237.568 0-430.080 192.614-430.080 430.080 0 237.568 192.563 430.080 430.080 430.080s430.080-192.563 430.080-430.080c0-237.517-192.563-430.080-430.080-430.080zM770.56 459.674v104.704h-517.12v-104.704h517.12z';

	  // Define off-white gray colors for low contrast ui (unselected).
	  m_lowContrast = {
	    white: '#f4f4f4',
	    black: '#505050'
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Add an icon from a path string.  Returns a d3 group element.
	   *
	   * @function
	   * @argument {String} icon svg path string
	   * @argument {Array} base where to append the element (d3 selection)
	   * @argument {Number} cx Center x-coordinate
	   * @argument {Number} cy Center y-coordinate
	   * @argument {Number} size Icon size in pixels
	   * @returns {object}
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  function put_icon(icon, base, cx, cy, size) {
	    var g = base.append('g');

	    // the scale factor
	    var s = size / 1024;

	    g.append('g')
	      .append('g')
	        .attr(
	          'transform',
	          'translate(' + cx + ',' + cy + ') scale(' + s + ') translate(-512,-512)'
	      )
	      .append('path')
	        .attr('d', icon)
	        .attr('class', 'geo-glyphicon');

	    return g;
	  }

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Initialize the slider widget in the map.
	   *
	   * @function
	   * @returns {geo.gui.sliderWidget}
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._init = function () {
	    s_createCanvas();
	    s_appendChild();

	    m_this.reposition();

	    var svg = d3.select(m_this.canvas()),
	        x0 = 40,
	        y0 = 40 + m_width,
	        map = m_this.layer().map();

	    // create d3 scales for positioning
	    // TODO: make customizable and responsive
	    m_xscale = d3.scale.linear().domain([-4, 4]).range([x0, x0 + m_width]);
	    m_yscale = d3.scale.linear().domain([0, 1]).range([y0, y0 + m_height]);

	    // Create the main group element
	    svg = svg.append('g').classed('geo-ui-slider', true);
	    m_group = svg;

	    // Create + zoom button
	    m_plus = svg.append('g');
	    m_plus.append('circle')
	      .datum({
	        fill: 'white',
	        stroke: null
	      })
	      .classed('geo-zoom-in', true)
	      .attr('cx', m_xscale(0))
	      .attr('cy', m_yscale(0.0) - m_width + 2)
	      .attr('r', m_width / 2)
	      .style({
	        'cursor': 'pointer'
	      })
	      .on('click', function () {
	        var z = map.zoom();
	        map.transition({
	          zoom: z + 1,
	          ease: d3.ease('cubic-in-out'),
	          duration: 500
	        });
	      })
	      .on('mousedown', function () {
	        d3.event.stopPropagation();
	      });

	    put_icon(
	      m_plusIcon,
	      m_plus,
	      m_xscale(0),
	      m_yscale(0) - m_width + 2,
	      m_width + 5
	    ).style('cursor', 'pointer')
	      .style('pointer-events', 'none')
	      .select('path')
	      .datum({
	        fill: 'black',
	        stroke: null
	      });

	    // Create the - zoom button
	    m_minus = svg.append('g');
	    m_minus.append('circle')
	      .datum({
	        fill: 'white',
	        stroke: null
	      })
	      .classed('geo-zoom-out', true)
	      .attr('cx', m_xscale(0))
	      .attr('cy', m_yscale(1.0) + m_width - 2)
	      .attr('r', m_width / 2)
	      .style({
	        'cursor': 'pointer'
	      })
	      .on('click', function () {
	        var z = map.zoom();
	        map.transition({
	          zoom: z - 1,
	          ease: d3.ease('cubic-in-out'),
	          duration: 500
	        });
	      })
	      .on('mousedown', function () {
	        d3.event.stopPropagation();
	      });

	    put_icon(
	      m_minusIcon,
	      m_minus,
	      m_xscale(0),
	      m_yscale(1) + m_width - 2,
	      m_width + 5
	    ).style('cursor', 'pointer')
	      .style('pointer-events', 'none')
	      .select('path')
	      .datum({
	        fill: 'black',
	        stroke: null
	      });

	    // Respond to a mouse event on the widget
	    function respond(evt, trans) {
	      var z = m_yscale.invert(d3.mouse(m_this.layer().node()[0])[1]),
	          zrange = map.zoomRange();
	      z = (1 - z) * (zrange.max - zrange.min) + zrange.min;
	      if (trans) {
	        map.transition({
	          zoom: z,
	          ease: d3.ease('cubic-in-out'),
	          duration: 500,
	          done: m_this._update()
	        });
	      } else {
	        map.zoom(z);
	        m_this._update();
	      }
	      evt.stopPropagation();
	    }

	    // Create the track
	    svg.append('rect')
	      .datum({
	        fill: 'white',
	        stroke: 'black'
	      })
	      .classed('geo-zoom-track', true)
	      .attr('x', m_xscale(0) - m_width / 6)
	      .attr('y', m_yscale(0))
	      .attr('rx', m_width / 10)
	      .attr('ry', m_width / 10)
	      .attr('width', m_width / 3)
	      .attr('height', m_height)
	      .style({
	        'cursor': 'pointer'
	      })
	      .on('click', function () {
	        respond(d3.event, true);
	      });

	    // Create the nub
	    m_nub = svg.append('rect')
	      .datum({
	        fill: 'black',
	        stroke: null
	      })
	      .classed('geo-zoom-nub', true)
	      .attr('x', m_xscale(-4))
	      .attr('y', m_yscale(0.5) - m_nubSize / 2)
	      .attr('rx', 3)
	      .attr('ry', 3)
	      .attr('width', m_width)
	      .attr('height', m_nubSize)
	      .style({
	        'cursor': 'pointer'
	      })
	      .on('mousedown', function () {
	        d3.select(document).on('mousemove.geo.slider', function () {
	          respond(d3.event);
	        });
	        d3.select(document).on('mouseup.geo.slider', function () {
	          respond(d3.event);
	          d3.select(document).on('.geo.slider', null);
	        });
	        d3.event.stopPropagation();
	      });

	    var mouseOver = function () {
	      d3.select(this).attr('filter', 'url(#geo-highlight)');
	      m_group.selectAll('rect,path,circle').transition()
	        .duration(m_highlightDur)
	        .style('fill', function (d) {
	          return d.fill || null;
	        })
	        .style('stroke', function (d) {
	          return d.stroke || null;
	        });

	    };

	    var mouseOut = function () {
	      d3.select(this).attr('filter', null);
	      m_group.selectAll('circle,rect,path').transition()
	        .duration(m_highlightDur)
	        .style('fill', function (d) {
	          return m_lowContrast[d.fill] || null;
	        })
	        .style('stroke', function (d) {
	          return m_lowContrast[d.stroke] || null;
	        });
	    };

	    m_group.selectAll('*')
	      .on('mouseover', mouseOver)
	      .on('mouseout', mouseOut);

	    // Update the nub position on zoom
	    m_this.layer().geoOn(geo_event.zoom, function () {
	      m_this._update();
	    });

	    mouseOut();
	    m_this._update();
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Removes the slider element from the map and unbinds all handlers.
	   *
	   * @function
	   * @returns {geo.gui.sliderWidget}
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._exit = function () {
	    m_group.remove();
	    m_this.layer().geoOff(geo_event.zoom);
	    s_exit();
	  };

	  //////////////////////////////////////////////////////////////////////////////
	  /**
	   * Update the slider widget state in reponse to map changes.  I.e. zoom
	   * range changes.
	   *
	   * @function
	   * @returns {geo.gui.sliderWidget}
	   * @private
	   */
	  //////////////////////////////////////////////////////////////////////////////
	  this._update = function (obj) {
	    var map = m_this.layer().map(),
	        zoomRange = map.zoomRange(),
	        zoom = map.zoom(),
	        zoomScale = d3.scale.linear();

	    obj = obj || {};
	    zoom = obj.value || zoom;
	    zoomScale.domain([zoomRange.min, zoomRange.max])
	      .range([1, 0])
	      .clamp(true);

	    m_nub.attr('y', m_yscale(zoomScale(zoom)) - m_nubSize / 2);
	  };
	};

	inherit(sliderWidget, svgWidget);

	registerWidget('dom', 'slider', sliderWidget);
	module.exports = sliderWidget;


/***/ }
/******/ ])
});
;